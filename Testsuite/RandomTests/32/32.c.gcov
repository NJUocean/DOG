        -:    0:Source:32.c
        -:    0:Graph:32.gcno
        -:    0:Data:32.gcda
        -:    0:Runs:1
        -:    1:// Options:   --concise --max-struct-fields 5 --max-funcs 2 --max-array-len-per-dim 5 --max-block-depth 3 --max-block-size 2
        -:    2:#include "csmith.h"
        -:    3:
        -:    4:static long __undefined;
        -:    5:
        -:    6:static int32_t g_6 = 9L;
        -:    7:static uint32_t g_21 = 18446744073709551615UL;
        -:    8:static int32_t g_23 = 1L;
        -:    9:static uint16_t g_30 = 0xEC6FL;
        -:   10:static int32_t *volatile g_45[1] = {(void *)0};
        -:   11:static const volatile uint32_t g_60 = 1UL;
        -:   12:static const volatile uint32_t *g_59[4] = {&g_60, &g_60, &g_60, &g_60};
        -:   13:static const volatile uint32_t **volatile g_58[3] = {&g_59[0], &g_59[0], &g_59[0]};
        -:   14:static int16_t g_78[2][3] = {{0xCE74L, 0xCE74L, 0xCE74L}, {0xCE74L, 0xCE74L, 0xCE74L}};
        -:   15:static int16_t g_80[5][4] = {{(-4L), (-4L), 0x0D08L, 0x0D08L}, {(-4L), (-4L), 0x0D08L, 0x0D08L}, {(-4L), (-4L), 0x0D08L, 0x0D08L}, {(-4L), (-4L), 0x0D08L, 0x0D08L}, {(-4L), (-4L), 0x0D08L, 0x0D08L}};
        -:   16:static const volatile int32_t g_85 = (-4L);
        -:   17:static const volatile int32_t *g_84 = &g_85;
        -:   18:static const volatile int32_t **volatile g_83[3] = {&g_84, &g_84, &g_84};
        -:   19:static const volatile int32_t g_88 = 0L;
        -:   20:static int32_t *g_107 = &g_6;
        -:   21:static int32_t **volatile g_106 = &g_107;
        -:   22:
        -:   23:static uint8_t func_1(void);
        -:   24:static int32_t *func_2(int32_t *p_3);
        -:   25:
        1:   26:static uint8_t func_1(void) {
        1:   27:  int32_t *l_4 = (void *)0;
        -:   28:  int32_t l_108[3][2][4];
        1:   29:  uint16_t l_109 = 8UL;
        -:   30:  int i, j, k;
        4:   31:  for (i = 0; i < 3; i++) {
        9:   32:    for (j = 0; j < 2; j++) {
       30:   33:      for (k = 0; k < 4; k++)
       24:   34:        l_108[i][j][k] = 0xFF9E38BDL;
        -:   35:    }
        -:   36:  }
        1:   37:  (*g_106) = func_2(l_4);
        1:   38:  (*g_107) &= l_108[1][1][1];
        1:   39:  return l_109;
        -:   40:}
        -:   41:
        1:   42:static int32_t *func_2(int32_t *p_3) {
        -:   43:  int16_t l_5[3][5];
        1:   44:  int32_t l_51 = (-5L);
        1:   45:  uint32_t *const l_57 = &g_21;
        1:   46:  uint32_t *const *l_56 = &l_57;
        1:   47:  uint16_t *l_75 = (void *)0;
        1:   48:  uint16_t **l_76 = &l_75;
        1:   49:  int16_t *l_77 = &g_78[0][0];
        1:   50:  int16_t *l_79 = &g_80[3][2];
        1:   51:  int32_t l_81 = 5L;
        -:   52:  int i, j;
        4:   53:  for (i = 0; i < 3; i++) {
       18:   54:    for (j = 0; j < 5; j++)
       15:   55:      l_5[i][j] = 0xB7BEL;
        -:   56:  }
        1:   57:lbl_103:
       1*:   58:  for (g_6 = 0; (g_6 <= 2); g_6 += 1) {
        1:   59:    int64_t l_7 = 1L;
        1:   60:    int64_t l_13 = 4L;
        1:   61:    uint32_t l_44 = 4294967287UL;
        1:   62:    int16_t l_46 = 6L;
        1:   63:    if (l_7)
        1:   64:      break;
    #####:   65:    for (l_7 = 0; (l_7 <= 2); l_7 += 1) {
    #####:   66:      int32_t *l_16 = &g_6;
        -:   67:      int i, j;
    #####:   68:      if ((l_5[l_7][(l_7 + 1)] <= (safe_sub_func_int8_t_s_s(l_7, l_5[0][4])))) {
    #####:   69:        int32_t **l_17 = &l_16;
    #####:   70:        int32_t *l_19 = &g_6;
    #####:   71:        int32_t **l_18 = &l_19;
    #####:   72:        uint32_t *l_20 = &g_21;
    #####:   73:        int32_t *l_22 = &g_23;
    #####:   74:        (*l_22) ^= (!(((0x51L == (safe_rshift_func_int32_t_s_s((l_13 && (0x5DE1FC657863718BLL != (safe_add_func_int8_t_s_s(0L, ((((*l_18) = ((*l_17) = l_16)) == &g_6) < ((((*l_20) = ((((void *)0 == &p_3) | 0xABF7C2F5A260DF39LL), 0x9EA5D840L)), g_21) & g_6)))))), 27))) || l_13) >= l_5[1][1]));
        -:   75:      } else {
    #####:   76:        uint16_t *l_28 = (void *)0;
    #####:   77:        uint16_t *l_29 = &g_30;
    #####:   78:        uint32_t *l_40 = &g_21;
    #####:   79:        uint32_t **l_39 = &l_40;
    #####:   80:        uint32_t *l_42 = &g_21;
    #####:   81:        uint32_t **l_41 = &l_42;
    #####:   82:        int32_t l_43 = 0xC2DB6027L;
    #####:   83:        l_46 = ((g_23 < ((safe_sub_func_uint16_t_u_u(((*l_29) = 0UL), (safe_mul_func_int64_t_s_s((l_5[2][4] < ((((&p_3 != (void *)0) > (safe_sub_func_int64_t_s_s((safe_div_func_uint8_t_u_u((g_21 != (((safe_mul_func_uint32_t_u_u(((*l_16), ((((((*l_41) = ((*l_39) = (void *)0)) == &g_21) == 0x7756L) != l_7) <= g_23)), l_43)) != l_5[1][4]) | 0xF635L)), l_7)), (*l_16)))) ^ l_43), l_44)), 4UL)))) & l_5[1][3])) | 0L);
        -:   84:      }
        -:   85:    }
        -:   86:  }
        1:   87:  if (((safe_add_func_uint32_t_u_u(((l_51 ^= (safe_rshift_func_int8_t_s_u(l_5[2][1], 3))) < (((l_5[1][0] & (safe_rshift_func_int64_t_s_s(((safe_rshift_func_int8_t_s_u(g_21, (l_5[2][3], ((l_56 != g_58[2]) ^ (((*l_79) ^= (l_5[0][4], ((*l_77) |= (safe_mod_func_int8_t_s_s((((safe_add_func_uint8_t_u_u((safe_lshift_func_int64_t_s_u(((safe_sub_func_uint8_t_u_u(((((safe_mul_func_uint32_t_u_u((l_5[0][0] != (safe_lshift_func_uint16_t_u_u((((*l_76) = l_75) != &g_30), l_5[1][3]))), l_5[2][4])), g_30) < 0L) | g_30), l_5[0][0])) == g_30), 26)), l_5[1][3])) == g_23) == 0x433F2F19166C0C08LL), 1UL))))) <= l_5[2][4]))))) & l_5[1][0]), 47))) & g_21) > g_6)), l_81)) <= 0x3DL)) {
        1:   88:    const volatile int32_t *l_87[5][3][1] = {{{&g_85}, {&g_88}, {&g_85}}, {{&g_88}, {&g_85}, {&g_88}}, {{&g_85}, {&g_88}, {&g_85}}, {{&g_88}, {&g_85}, {&g_88}}, {{&g_85}, {&g_88}, {&g_85}}};
        -:   89:    int i, j, k;
        5:   90:    for (g_6 = 3; (g_6 >= 0); g_6 -= 1) {
        4:   91:      int32_t *l_82 = &l_51;
        4:   92:      if (((*l_82) = 0L)) {
        -:   93:        const volatile int32_t **l_86[5] = {(void *)0, (void *)0, (void *)0, (void *)0, (void *)0};
        -:   94:        int i;
        -:   95:        l_87[2][0][0] = g_59[g_6];
        -:   96:      } else {
        -:   97:        int i;
        4:   98:        (*l_82) &= ((&g_59[g_6] == (void *)0) && g_80[0][0]);
        -:   99:      }
       16:  100:      for (g_23 = 2; (g_23 >= 0); g_23 -= 1) {
       12:  101:        int32_t l_99 = 1L;
       12:  102:        int32_t *l_100 = &l_81;
        -:  103:        int i;
       12:  104:        (*l_100) |= ((safe_mod_func_int64_t_s_s((safe_lshift_func_int16_t_s_u(((-3L) >= (((*l_56) == (void *)0) != (l_51 ^ (*l_82)))), 8)), (safe_rshift_func_uint16_t_u_u((safe_rshift_func_uint16_t_u_u((((-1L) == (safe_unary_minus_func_uint16_t_u(((+g_21) & (-1L))))) | g_21), l_99)), 8)))) == l_99);
        -:  105:      }
        -:  106:    }
        -:  107:  } else {
    #####:  108:    for (g_30 = 0; (g_30 <= 0); g_30 += 1) {
    #####:  109:      int32_t *l_104 = &g_23;
    #####:  110:      if ((!(safe_unary_minus_func_uint64_t_u(0xB5E53D9B4DC16D46LL)))) {
    #####:  111:        if (l_81)
    #####:  112:          goto lbl_103;
    #####:  113:        return l_104;
        -:  114:      } else {
    #####:  115:        int32_t *volatile *l_105 = (void *)0;
        -:  116:        int i;
    #####:  117:        g_45[g_30] = g_45[g_30];
        -:  118:      }
        -:  119:    }
        -:  120:  }
        1:  121:  return &g_23;
        -:  122:}
        -:  123:
        1:  124:int main(int argc, char *argv[]) {
        -:  125:  int i, j;
        1:  126:  int print_hash_value = 0;
       1*:  127:  if (argc == 2 && strcmp(argv[1], "1") == 0)
    #####:  128:    print_hash_value = 1;
        1:  129:  platform_main_begin();
        1:  130:  crc32_gentab();
        1:  131:  func_1();
        1:  132:  transparent_crc(g_6, "g_6", print_hash_value);
        1:  133:  transparent_crc(g_21, "g_21", print_hash_value);
        1:  134:  transparent_crc(g_23, "g_23", print_hash_value);
        1:  135:  transparent_crc(g_30, "g_30", print_hash_value);
        1:  136:  transparent_crc(g_60, "g_60", print_hash_value);
        3:  137:  for (i = 0; i < 2; i++) {
        8:  138:    for (j = 0; j < 3; j++) {
        6:  139:      transparent_crc(g_78[i][j], "g_78[i][j]", print_hash_value);
        6:  140:      if (print_hash_value)
    #####:  141:        printf("index = [%d][%d]\n", i, j);
        -:  142:    }
        -:  143:  }
        6:  144:  for (i = 0; i < 5; i++) {
       25:  145:    for (j = 0; j < 4; j++) {
       20:  146:      transparent_crc(g_80[i][j], "g_80[i][j]", print_hash_value);
       20:  147:      if (print_hash_value)
    #####:  148:        printf("index = [%d][%d]\n", i, j);
        -:  149:    }
        -:  150:  }
        1:  151:  transparent_crc(g_85, "g_85", print_hash_value);
        1:  152:  transparent_crc(g_88, "g_88", print_hash_value);
        1:  153:  platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
        1:  154:  return 0;
        -:  155:}
