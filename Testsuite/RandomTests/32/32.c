// Options:   --concise --max-struct-fields 5 --max-funcs 2 --max-array-len-per-dim 5 --max-block-depth 3 --max-block-size 2
#include "csmith.h"

static long __undefined;

static int32_t g_6 = 9L;
static uint32_t g_21 = 18446744073709551615UL;
static int32_t g_23 = 1L;
static uint16_t g_30 = 0xEC6FL;
static int32_t *volatile g_45[1] = {(void *)0};
static const volatile uint32_t g_60 = 1UL;
static const volatile uint32_t *g_59[4] = {&g_60, &g_60, &g_60, &g_60};
static const volatile uint32_t **volatile g_58[3] = {&g_59[0], &g_59[0], &g_59[0]};
static int16_t g_78[2][3] = {{0xCE74L, 0xCE74L, 0xCE74L}, {0xCE74L, 0xCE74L, 0xCE74L}};
static int16_t g_80[5][4] = {{(-4L), (-4L), 0x0D08L, 0x0D08L}, {(-4L), (-4L), 0x0D08L, 0x0D08L}, {(-4L), (-4L), 0x0D08L, 0x0D08L}, {(-4L), (-4L), 0x0D08L, 0x0D08L}, {(-4L), (-4L), 0x0D08L, 0x0D08L}};
static const volatile int32_t g_85 = (-4L);
static const volatile int32_t *g_84 = &g_85;
static const volatile int32_t **volatile g_83[3] = {&g_84, &g_84, &g_84};
static const volatile int32_t g_88 = 0L;
static int32_t *g_107 = &g_6;
static int32_t **volatile g_106 = &g_107;

static uint8_t func_1(void);
static int32_t *func_2(int32_t *p_3);

static uint8_t func_1(void) {
  int32_t *l_4 = (void *)0;
  int32_t l_108[3][2][4];
  uint16_t l_109 = 8UL;
  int i, j, k;
  for (i = 0; i < 3; i++) {
    for (j = 0; j < 2; j++) {
      for (k = 0; k < 4; k++)
        l_108[i][j][k] = 0xFF9E38BDL;
    }
  }
  (*g_106) = func_2(l_4);
  (*g_107) &= l_108[1][1][1];
  return l_109;
}

static int32_t *func_2(int32_t *p_3) {
  int16_t l_5[3][5];
  int32_t l_51 = (-5L);
  uint32_t *const l_57 = &g_21;
  uint32_t *const *l_56 = &l_57;
  uint16_t *l_75 = (void *)0;
  uint16_t **l_76 = &l_75;
  int16_t *l_77 = &g_78[0][0];
  int16_t *l_79 = &g_80[3][2];
  int32_t l_81 = 5L;
  int i, j;
  for (i = 0; i < 3; i++) {
    for (j = 0; j < 5; j++)
      l_5[i][j] = 0xB7BEL;
  }
lbl_103:
  for (g_6 = 0; (g_6 <= 2); g_6 += 1) {
    int64_t l_7 = 1L;
    int64_t l_13 = 4L;
    uint32_t l_44 = 4294967287UL;
    int16_t l_46 = 6L;
    if (l_7)
      break;
    for (l_7 = 0; (l_7 <= 2); l_7 += 1) {
      int32_t *l_16 = &g_6;
      int i, j;
      if ((l_5[l_7][(l_7 + 1)] <= (safe_sub_func_int8_t_s_s(l_7, l_5[0][4])))) {
        int32_t **l_17 = &l_16;
        int32_t *l_19 = &g_6;
        int32_t **l_18 = &l_19;
        uint32_t *l_20 = &g_21;
        int32_t *l_22 = &g_23;
        (*l_22) ^= (!(((0x51L == (safe_rshift_func_int32_t_s_s((l_13 && (0x5DE1FC657863718BLL != (safe_add_func_int8_t_s_s(0L, ((((*l_18) = ((*l_17) = l_16)) == &g_6) < ((((*l_20) = ((((void *)0 == &p_3) | 0xABF7C2F5A260DF39LL), 0x9EA5D840L)), g_21) & g_6)))))), 27))) || l_13) >= l_5[1][1]));
      } else {
        uint16_t *l_28 = (void *)0;
        uint16_t *l_29 = &g_30;
        uint32_t *l_40 = &g_21;
        uint32_t **l_39 = &l_40;
        uint32_t *l_42 = &g_21;
        uint32_t **l_41 = &l_42;
        int32_t l_43 = 0xC2DB6027L;
        l_46 = ((g_23 < ((safe_sub_func_uint16_t_u_u(((*l_29) = 0UL), (safe_mul_func_int64_t_s_s((l_5[2][4] < ((((&p_3 != (void *)0) > (safe_sub_func_int64_t_s_s((safe_div_func_uint8_t_u_u((g_21 != (((safe_mul_func_uint32_t_u_u(((*l_16), ((((((*l_41) = ((*l_39) = (void *)0)) == &g_21) == 0x7756L) != l_7) <= g_23)), l_43)) != l_5[1][4]) | 0xF635L)), l_7)), (*l_16)))) ^ l_43), l_44)), 4UL)))) & l_5[1][3])) | 0L);
      }
    }
  }
  if (((safe_add_func_uint32_t_u_u(((l_51 ^= (safe_rshift_func_int8_t_s_u(l_5[2][1], 3))) < (((l_5[1][0] & (safe_rshift_func_int64_t_s_s(((safe_rshift_func_int8_t_s_u(g_21, (l_5[2][3], ((l_56 != g_58[2]) ^ (((*l_79) ^= (l_5[0][4], ((*l_77) |= (safe_mod_func_int8_t_s_s((((safe_add_func_uint8_t_u_u((safe_lshift_func_int64_t_s_u(((safe_sub_func_uint8_t_u_u(((((safe_mul_func_uint32_t_u_u((l_5[0][0] != (safe_lshift_func_uint16_t_u_u((((*l_76) = l_75) != &g_30), l_5[1][3]))), l_5[2][4])), g_30) < 0L) | g_30), l_5[0][0])) == g_30), 26)), l_5[1][3])) == g_23) == 0x433F2F19166C0C08LL), 1UL))))) <= l_5[2][4]))))) & l_5[1][0]), 47))) & g_21) > g_6)), l_81)) <= 0x3DL)) {
    const volatile int32_t *l_87[5][3][1] = {{{&g_85}, {&g_88}, {&g_85}}, {{&g_88}, {&g_85}, {&g_88}}, {{&g_85}, {&g_88}, {&g_85}}, {{&g_88}, {&g_85}, {&g_88}}, {{&g_85}, {&g_88}, {&g_85}}};
    int i, j, k;
    for (g_6 = 3; (g_6 >= 0); g_6 -= 1) {
      int32_t *l_82 = &l_51;
      if (((*l_82) = 0L)) {
        const volatile int32_t **l_86[5] = {(void *)0, (void *)0, (void *)0, (void *)0, (void *)0};
        int i;
        l_87[2][0][0] = g_59[g_6];
      } else {
        int i;
        (*l_82) &= ((&g_59[g_6] == (void *)0) && g_80[0][0]);
      }
      for (g_23 = 2; (g_23 >= 0); g_23 -= 1) {
        int32_t l_99 = 1L;
        int32_t *l_100 = &l_81;
        int i;
        (*l_100) |= ((safe_mod_func_int64_t_s_s((safe_lshift_func_int16_t_s_u(((-3L) >= (((*l_56) == (void *)0) != (l_51 ^ (*l_82)))), 8)), (safe_rshift_func_uint16_t_u_u((safe_rshift_func_uint16_t_u_u((((-1L) == (safe_unary_minus_func_uint16_t_u(((+g_21) & (-1L))))) | g_21), l_99)), 8)))) == l_99);
      }
    }
  } else {
    for (g_30 = 0; (g_30 <= 0); g_30 += 1) {
      int32_t *l_104 = &g_23;
      if ((!(safe_unary_minus_func_uint64_t_u(0xB5E53D9B4DC16D46LL)))) {
        if (l_81)
          goto lbl_103;
        return l_104;
      } else {
        int32_t *volatile *l_105 = (void *)0;
        int i;
        g_45[g_30] = g_45[g_30];
      }
    }
  }
  return &g_23;
}

int main(int argc, char *argv[]) {
  int i, j;
  int print_hash_value = 0;
  if (argc == 2 && strcmp(argv[1], "1") == 0)
    print_hash_value = 1;
  platform_main_begin();
  crc32_gentab();
  func_1();
  transparent_crc(g_6, "g_6", print_hash_value);
  transparent_crc(g_21, "g_21", print_hash_value);
  transparent_crc(g_23, "g_23", print_hash_value);
  transparent_crc(g_30, "g_30", print_hash_value);
  transparent_crc(g_60, "g_60", print_hash_value);
  for (i = 0; i < 2; i++) {
    for (j = 0; j < 3; j++) {
      transparent_crc(g_78[i][j], "g_78[i][j]", print_hash_value);
      if (print_hash_value)
        printf("index = [%d][%d]\n", i, j);
    }
  }
  for (i = 0; i < 5; i++) {
    for (j = 0; j < 4; j++) {
      transparent_crc(g_80[i][j], "g_80[i][j]", print_hash_value);
      if (print_hash_value)
        printf("index = [%d][%d]\n", i, j);
    }
  }
  transparent_crc(g_85, "g_85", print_hash_value);
  transparent_crc(g_88, "g_88", print_hash_value);
  platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
  return 0;
}
