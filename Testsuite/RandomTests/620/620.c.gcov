        -:    0:Source:620.c
        -:    0:Graph:620.gcno
        -:    0:Data:620.gcda
        -:    0:Runs:1
        -:    1:// Options:   --concise --max-struct-fields 5 --max-funcs 2 --max-array-len-per-dim 5 --max-block-depth 3 --max-block-size 2
        -:    2:#include "csmith.h"
        -:    3:
        -:    4:static long __undefined;
        -:    5:
        -:    6:#pragma pack(push)
        -:    7:#pragma pack(1)
        -:    8:struct S0 {
        -:    9:  uint64_t f0;
        -:   10:  int16_t f1;
        -:   11:};
        -:   12:#pragma pack(pop)
        -:   13:
        -:   14:#pragma pack(push)
        -:   15:#pragma pack(1)
        -:   16:struct S2 {
        -:   17:  uint64_t f0;
        -:   18:};
        -:   19:#pragma pack(pop)
        -:   20:
        -:   21:static int32_t g_10 = 1L;
        -:   22:static uint8_t g_35 = 0xC0L;
        -:   23:static volatile uint32_t g_41 = 0xDB1A73B0L;
        -:   24:static uint32_t g_52 = 0x3D7FBA34L;
        -:   25:static uint16_t g_77 = 65535UL;
        -:   26:static uint16_t g_79 = 65528UL;
        -:   27:static int16_t g_80 = 0x12ABL;
        -:   28:static uint16_t **g_83 = (void *)0;
        -:   29:static volatile int16_t g_92 = 1L;
        -:   30:static volatile uint64_t g_93 = 0x51EA71B313CF365ALL;
        -:   31:static uint16_t g_113 = 65535UL;
        -:   32:static uint8_t g_126 = 8UL;
        -:   33:static int8_t g_129 = 1L;
        -:   34:static struct S2 g_132[2] = {{18446744073709551612UL}, {18446744073709551612UL}};
        -:   35:static struct S2 *g_136[5] = {(void *)0, (void *)0, (void *)0, (void *)0, (void *)0};
        -:   36:static struct S2 **volatile g_135 = &g_136[2];
        -:   37:static int32_t *g_139 = &g_10;
        -:   38:static int32_t **volatile g_138[5][2][3] = {{{&g_139, (void *)0, (void *)0}, {&g_139, &g_139, &g_139}}, {{&g_139, &g_139, &g_139}, {&g_139, &g_139, &g_139}}, {{&g_139, &g_139, (void *)0}, {(void *)0, &g_139, &g_139}}, {{(void *)0, &g_139, (void *)0}, {(void *)0, &g_139, (void *)0}}, {{&g_139, (void *)0, (void *)0}, {&g_139, &g_139, &g_139}}};
        -:   39:static struct S0 g_142 = {0x11AEEC80A0586BC1LL, 0x71C7L};
        -:   40:
        -:   41:static struct S0 func_1(void);
        -:   42:static uint16_t func_4(uint16_t p_5);
        -:   43:
        1:   44:static struct S0 func_1(void) {
        1:   45:  uint16_t l_6 = 9UL;
        1:   46:  uint8_t *l_34 = &g_35;
        1:   47:  int32_t l_40 = 0L;
        1:   48:  int32_t l_53 = 1L;
        1:   49:  int16_t l_123 = 1L;
        -:   50:  int32_t *l_141[1][4][5];
        -:   51:  int i, j, k;
        2:   52:  for (i = 0; i < 1; i++) {
        5:   53:    for (j = 0; j < 4; j++) {
       24:   54:      for (k = 0; k < 5; k++)
       20:   55:        l_141[i][j][k] = &l_40;
        -:   56:    }
        -:   57:  }
       1*:   58:  if (((safe_lshift_func_uint16_t_u_s(func_4(l_6), (g_10 | ((((g_10 <= (safe_mod_func_int32_t_s_s((safe_mul_func_int8_t_s_s(((safe_mul_func_int32_t_s_s((safe_lshift_func_uint32_t_u_s(((safe_div_func_uint8_t_u_u((((safe_div_func_int8_t_s_s(((g_10 & (safe_lshift_func_int32_t_s_u((safe_unary_minus_func_int8_t_s(l_6)), 4))) ^ ((safe_sub_func_int64_t_s_s((safe_add_func_uint8_t_u_u((safe_rshift_func_int16_t_s_u(((0x7D17017A68FAB8D2LL && (safe_mod_func_int8_t_s_s(0xDFL, ((*l_34) = g_10)))) >= g_10), g_10)), l_6)), l_6)) <= g_10)), 0x06L)) < g_10) && g_35), l_6)) > l_6), l_6)), l_6)) ^ 0x2E84L), l_6)), l_6))) <= 3UL) <= g_10) & 0x52L)))) || 0x66E66B6CL)) {
        1:   59:    int32_t *l_36 = &g_10;
        1:   60:    int32_t *l_37 = &g_10;
        1:   61:    int32_t *l_38 = &g_10;
        -:   62:    int32_t *l_39[3];
        -:   63:    int i;
        4:   64:    for (i = 0; i < 3; i++)
        3:   65:      l_39[i] = &g_10;
        1:   66:    ++g_41;
       20:   67:    for (l_6 = 0; (l_6 < 19); ++l_6) {
        -:   68:      uint32_t *l_51[1];
       19:   69:      int32_t l_75 = 1L;
       19:   70:      uint16_t *l_76 = &g_77;
       19:   71:      uint16_t *l_78 = &g_79;
       19:   72:      int32_t l_84 = (-1L);
       19:   73:      int32_t **l_85 = &l_39[2];
        -:   74:      int i;
       38:   75:      for (i = 0; i < 1; i++)
       19:   76:        l_51[i] = &g_52;
      19*:   77:      if ((l_40 && ((safe_unary_minus_func_int32_t_s((&g_10 != &g_10))) <= (g_80 = ((safe_mul_func_uint32_t_u_u((g_52--), ((safe_mul_func_uint8_t_u_u((((safe_lshift_func_int32_t_s_s(((safe_mul_func_int8_t_s_s(((safe_sub_func_uint64_t_u_u(0UL, ((safe_lshift_func_int16_t_s_u((((*l_78) = ((*l_76) = (safe_sub_func_int64_t_s_s((g_10 || 0x4202D95C78859B34LL), ((l_53 = ((safe_lshift_func_int32_t_s_u(((safe_rshift_func_uint8_t_u_u((safe_mod_func_uint64_t_u_u((*l_37), (-9L))), 0)), (safe_unary_minus_func_uint8_t_u((((g_41 != g_10) == l_75), 0x08L)))), 15)) == g_10)) || g_35))))) && g_41), 14)) <= 8L))) | g_35), g_10)) & l_75), 11)), 8L) <= 0x3878D320CD53B18ALL), g_10)) > g_10))) && g_52))))) {
    #####:   78:        int32_t l_81 = 0L;
    #####:   79:        (*l_37) = g_35;
    #####:   80:        if (l_81)
    #####:   81:          break;
        -:   82:      } else {
       19:   83:        uint16_t **l_82 = &l_78;
       19:   84:        g_83 = l_82;
       19:   85:        if (l_84)
       19:   86:          continue;
        -:   87:      }
    #####:   88:      (*l_85) = l_37;
        -:   89:    }
        -:   90:  } else {
        -:   91:    int32_t *l_86 = &l_53;
        -:   92:    int32_t *l_87 = &g_10;
        -:   93:    int32_t *l_88 = (void *)0;
        -:   94:    int32_t *l_89 = &g_10;
        -:   95:    int32_t *l_90[1];
        -:   96:    int32_t l_91 = 0L;
        -:   97:    struct S0 l_96 = {0x27B92311C7DC5EB7LL, -4L};
        -:   98:    int i;
        -:   99:    for (i = 0; i < 1; i++)
        -:  100:      l_90[i] = &l_53;
        -:  101:    g_93++;
        -:  102:    return l_96;
        -:  103:  }
        1:  104:  if ((!g_80)) {
    #####:  105:    uint32_t *l_100[4] = {&g_52, &g_52, &g_52, &g_52};
    #####:  106:    int64_t l_109 = (-8L);
    #####:  107:    int16_t *l_118 = &g_80;
    #####:  108:    int64_t *l_124 = (void *)0;
        -:  109:    int64_t *l_125[3];
    #####:  110:    int8_t *l_127 = (void *)0;
    #####:  111:    int8_t *l_128 = &g_129;
    #####:  112:    int32_t *l_130 = &l_40;
        -:  113:    int i;
    #####:  114:    for (i = 0; i < 3; i++)
    #####:  115:      l_125[i] = (void *)0;
    #####:  116:    (*l_130) = ((safe_mod_func_uint8_t_u_u(((g_52 = l_53) || (safe_add_func_int16_t_s_s(2L, (safe_sub_func_int16_t_s_s((((*l_128) = ((safe_div_func_int16_t_s_s((18446744073709551611UL != (safe_mod_func_uint64_t_u_u(l_109, (g_126 = (safe_mul_func_int32_t_s_s((+(g_113 = g_41)), (safe_add_func_uint8_t_u_u(0x3CL, ((safe_lshift_func_int16_t_s_u((((*l_118) = g_35) && (safe_mul_func_int64_t_s_s(((((0xECF82584L == (safe_rshift_func_int32_t_s_u(l_123, g_77))) || g_77), &g_80) != &g_80), 0x06F5C0CD63D7C5F0LL))), 11)) != g_10))))))))), g_79)) & 65534UL)) || 250UL), 0x6C28L))))), l_123)) > 0x7CC2L);
        -:  117:  } else {
        1:  118:    struct S2 *const l_131 = &g_132[1];
        1:  119:    struct S2 *l_134 = &g_132[1];
        -:  120:    struct S2 **l_133[1];
        1:  121:    int32_t *l_137 = &l_40;
        -:  122:    int32_t **l_140[2][1];
        -:  123:    int i, j;
        2:  124:    for (i = 0; i < 1; i++)
        1:  125:      l_133[i] = &l_134;
        3:  126:    for (i = 0; i < 2; i++) {
        4:  127:      for (j = 0; j < 1; j++)
        2:  128:        l_140[i][j] = (void *)0;
        -:  129:    }
        1:  130:    (*g_135) = l_131;
        1:  131:    l_141[0][1][3] = l_137;
        -:  132:  }
        1:  133:  return g_142;
        -:  134:}
        -:  135:
        1:  136:static uint16_t func_4(uint16_t p_5) {
        1:  137:  uint32_t l_7[5][2] = {{0x1E19E95DL, 18446744073709551615UL}, {0x1E19E95DL, 18446744073709551615UL}, {0x1E19E95DL, 18446744073709551615UL}, {0x1E19E95DL, 18446744073709551615UL}, {0x1E19E95DL, 18446744073709551615UL}};
        1:  138:  int32_t *l_8 = (void *)0;
        1:  139:  int32_t **l_9 = &l_8;
        -:  140:  int i, j;
        1:  141:  l_7[1][0] = (p_5 < 0x97E780CAL);
        1:  142:  (*l_9) = l_8;
        1:  143:  return g_10;
        -:  144:}
        -:  145:
        1:  146:int main(int argc, char *argv[]) {
        -:  147:  int i, j, k;
        1:  148:  int print_hash_value = 0;
       1*:  149:  if (argc == 2 && strcmp(argv[1], "1") == 0)
    #####:  150:    print_hash_value = 1;
        1:  151:  platform_main_begin();
        1:  152:  crc32_gentab();
        1:  153:  func_1();
        1:  154:  transparent_crc(g_10, "g_10", print_hash_value);
        1:  155:  transparent_crc(g_35, "g_35", print_hash_value);
        1:  156:  transparent_crc(g_41, "g_41", print_hash_value);
        1:  157:  transparent_crc(g_52, "g_52", print_hash_value);
        1:  158:  transparent_crc(g_77, "g_77", print_hash_value);
        1:  159:  transparent_crc(g_79, "g_79", print_hash_value);
        1:  160:  transparent_crc(g_80, "g_80", print_hash_value);
        1:  161:  transparent_crc(g_92, "g_92", print_hash_value);
        1:  162:  transparent_crc(g_93, "g_93", print_hash_value);
        1:  163:  transparent_crc(g_113, "g_113", print_hash_value);
        1:  164:  transparent_crc(g_126, "g_126", print_hash_value);
        1:  165:  transparent_crc(g_129, "g_129", print_hash_value);
        3:  166:  for (i = 0; i < 2; i++) {
        2:  167:    transparent_crc(g_132[i].f0, "g_132[i].f0", print_hash_value);
        2:  168:    if (print_hash_value)
    #####:  169:      printf("index = [%d]\n", i);
        -:  170:  }
        1:  171:  transparent_crc(g_142.f0, "g_142.f0", print_hash_value);
        1:  172:  transparent_crc(g_142.f1, "g_142.f1", print_hash_value);
        1:  173:  platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
        1:  174:  return 0;
        -:  175:}
