        -:    0:Source:718.c
        -:    0:Graph:718.gcno
        -:    0:Data:718.gcda
        -:    0:Runs:1
        -:    1:// Options:   --concise --max-struct-fields 5 --max-funcs 2 --max-array-len-per-dim 5 --max-block-depth 3 --max-block-size 2
        -:    2:#include "csmith.h"
        -:    3:
        -:    4:static long __undefined;
        -:    5:
        -:    6:#pragma pack(push)
        -:    7:#pragma pack(1)
        -:    8:struct S0 {
        -:    9:  const uint32_t f0;
        -:   10:};
        -:   11:#pragma pack(pop)
        -:   12:
        -:   13:union U1 {
        -:   14:  int64_t f0;
        -:   15:  const volatile uint16_t f1;
        -:   16:};
        -:   17:
        -:   18:union U2 {
        -:   19:  unsigned f0 : 17;
        -:   20:  struct S0 f1;
        -:   21:  volatile uint16_t f2;
        -:   22:  struct S0 f3;
        -:   23:};
        -:   24:
        -:   25:static volatile int32_t g_2 = 0x6EB6B9DDL;
        -:   26:static volatile int32_t g_3 = 0xEAA29C14L;
        -:   27:static volatile int32_t g_4[3] = {0L, 0L, 0L};
        -:   28:static volatile int32_t g_5 = 0x837182ABL;
        -:   29:static int32_t g_6 = (-10L);
        -:   30:static int32_t g_27[1][3] = {{0xE889EC00L, 0xE889EC00L, 0xE889EC00L}};
        -:   31:static uint16_t g_31 = 0x26FBL;
        -:   32:static struct S0 g_38 = {0UL};
        -:   33:static int32_t g_40 = (-7L);
        -:   34:static uint8_t g_42 = 255UL;
        -:   35:static union U1 g_48 = {-10L};
        -:   36:static int8_t g_51 = (-7L);
        -:   37:static int32_t g_80 = 0xBAA7D4B2L;
        -:   38:static volatile uint8_t *g_85 = (void *)0;
        -:   39:static volatile uint8_t **volatile g_84 = &g_85;
        -:   40:static volatile uint8_t **volatile *const volatile g_86 = &g_84;
        -:   41:static volatile union U2 g_110[1] = {{9UL}};
        -:   42:
        -:   43:static struct S0 func_1(void);
        -:   44:static int32_t func_14(uint64_t p_15, uint32_t p_16, uint32_t p_17, uint32_t p_18, uint32_t p_19);
        -:   45:
        1:   46:static struct S0 func_1(void) {
        1:   47:  int64_t l_20 = 0x52065C829ED890FCLL;
        1:   48:  int32_t l_21 = 0x6758E356L;
        1:   49:  uint16_t *l_103 = &g_31;
       1*:   50:  for (g_6 = (-16); (g_6 >= 19); ++g_6) {
    #####:   51:    int16_t l_11 = (-3L);
    #####:   52:    int32_t *l_26 = &g_27[0][0];
    #####:   53:    uint16_t *l_30 = &g_31;
    #####:   54:    int32_t l_39 = 1L;
        -:   55:    uint8_t *l_41[1][1];
    #####:   56:    int32_t *l_78 = &l_21;
    #####:   57:    int32_t *l_79 = &g_80;
        -:   58:    int i, j;
    #####:   59:    for (i = 0; i < 1; i++) {
    #####:   60:      for (j = 0; j < 1; j++)
    #####:   61:        l_41[i][j] = &g_42;
        -:   62:    }
    #####:   63:    if (((*l_79) ^= ((*l_78) = (safe_add_func_int64_t_s_s(l_11, ((*l_26) = (safe_lshift_func_uint16_t_u_s((func_14(l_20, l_21, (safe_rshift_func_uint8_t_u_u((safe_sub_func_uint16_t_u_u((g_6 & (l_21 < ((*l_26) ^= g_4[0]))), ((safe_unary_minus_func_int8_t_s(l_20)), (!(--(*l_30)))))), (g_42 = (safe_mod_func_int16_t_s_s(((g_40 = (l_20 == (((safe_sub_func_int64_t_s_s((g_38, g_38.f0), l_39)) != l_21) == l_20))), (-2L)), l_21))))), g_38.f0, l_20) != g_38.f0), 15)))))))) {
    #####:   64:      struct S0 l_81 = {1UL};
    #####:   65:      for (l_21 = 0; (l_21 >= 0); l_21 -= 1) {
    #####:   66:        return l_81;
        -:   67:      }
        -:   68:    } else {
    #####:   69:      uint8_t **l_87 = &l_41[0][0];
    #####:   70:      uint8_t **l_93 = (void *)0;
    #####:   71:      uint8_t ***l_92 = &l_93;
    #####:   72:      uint16_t *l_102 = &g_31;
    #####:   73:      int8_t *l_104 = &g_51;
    #####:   74:      for (l_11 = 2; (l_11 >= (-10)); l_11 = safe_sub_func_int32_t_s_s(l_11, 5)) {
    #####:   75:        (*g_86) = g_84;
    #####:   76:        if (l_20)
    #####:   77:          break;
        -:   78:      }
    #####:   79:      l_21 = (l_26 == (((l_87 != (((safe_lshift_func_uint16_t_u_s((safe_add_func_int8_t_s_s((&l_41[0][0] == ((*l_92) = (void *)0)), ((((((safe_sub_func_uint16_t_u_u((safe_lshift_func_uint16_t_u_s(((safe_mod_func_int32_t_s_s(((*l_26) = (((*l_79) &= (((*l_104) = (safe_sub_func_uint8_t_u_u(((l_103 = l_102) != (void *)0), (*l_26)))) && g_40)) && (safe_lshift_func_uint16_t_u_s(((*l_103) = (safe_mod_func_int16_t_s_s((((+((void *)0 != &g_27[0][1])), (*g_86)) != (void *)0), 0xCF72L))), g_27[0][0])))), g_38.f0)) | g_40), g_42)), 65535UL)), 18446744073709551612UL), l_20) ^ 0xB206E1C7L) > 18446744073709551611UL) ^ (-6L)))), 10)) || l_20), (*g_86))), g_110[0]), (void *)0));
        -:   80:    }
        -:   81:  }
        1:   82:  return g_38;
        -:   83:}
        -:   84:
    #####:   85:static int32_t func_14(uint64_t p_15, uint32_t p_16, uint32_t p_17, uint32_t p_18, uint32_t p_19) {
    #####:   86:  uint8_t **l_45 = (void *)0;
    #####:   87:  uint8_t *l_47 = &g_42;
    #####:   88:  uint8_t **l_46 = &l_47;
    #####:   89:  int32_t *l_49[3][5][1] = {{{&g_40}, {&g_27[0][0]}, {&g_27[0][1]}, {&g_27[0][1]}, {&g_27[0][0]}}, {{&g_40}, {&g_40}, {&g_40}, {&g_27[0][0]}, {&g_27[0][1]}}, {{&g_27[0][1]}, {&g_27[0][0]}, {&g_40}, {&g_40}, {&g_40}}};
    #####:   90:  int8_t *l_50 = &g_51;
    #####:   91:  int64_t l_73 = (-1L);
        -:   92:  int i, j, k;
    #####:   93:  if ((safe_div_func_int32_t_s_s(((0x47B6C411E69D0863LL <= (((*l_46) = &g_42) == ((((((*l_50) = (((g_48, p_17), l_49[0][0][0]) != l_49[0][2][0])) <= (((safe_sub_func_uint8_t_u_u((+0x52F52174L), (g_6 == (((~p_16) | g_31) & p_16)))) > 3UL) != p_17)) >= g_40) | g_6), (void *)0))) | 0xDCB3L), 0x1C911B6BL))) {
    #####:   94:    int32_t l_64 = 2L;
    #####:   95:    int32_t l_65[2][2][2] = {{{0xE9C127C8L, 0xE9C127C8L}, {0xEEAEFF69L, 0xE9C127C8L}}, {{0xE9C127C8L, 0xEEAEFF69L}, {0xE9C127C8L, 0xE9C127C8L}}};
    #####:   96:    int8_t l_69 = 0x33L;
    #####:   97:    int8_t l_71 = (-4L);
        -:   98:    int i, j, k;
    #####:   99:    for (p_15 = 0; (p_15 <= 0); p_15 += 1) {
    #####:  100:      int32_t l_62 = 0xC401265AL;
    #####:  101:      int32_t l_66 = 2L;
    #####:  102:      int32_t l_67 = 0x4C01D5BCL;
    #####:  103:      int32_t l_68[5][5] = {{(-6L), 0L, (-6L), (-6L), 0L}, {5L, (-5L), 1L, 9L, 1L}, {0L, 0L, (-1L), 0L, 0L}, {1L, (-5L), 0x5B924867L, 0x4641B434L, 1L}, {(-6L), (-1L), (-1L), (-6L), (-1L)}};
        -:  104:      int i, j;
    #####:  105:      g_3 = (safe_mod_func_int16_t_s_s((safe_div_func_int16_t_s_s(p_17, g_6)), ((safe_sub_func_int64_t_s_s((p_16 < l_62), g_40)) | 0x9A43L)));
    #####:  106:      for (g_51 = 0; (g_51 <= 0); g_51 += 1) {
    #####:  107:        int32_t l_63 = (-9L);
    #####:  108:        int32_t l_70 = 0x25EA9B86L;
        -:  109:        int32_t l_72[3];
    #####:  110:        int64_t l_74 = 1L;
    #####:  111:        uint32_t l_75[4] = {0x0F492790L, 0x0F492790L, 0x0F492790L, 0x0F492790L};
        -:  112:        int i;
    #####:  113:        for (i = 0; i < 3; i++)
    #####:  114:          l_72[i] = 0x618A8B4EL;
    #####:  115:        l_62 = (l_63 >= g_5);
    #####:  116:        --l_75[0];
        -:  117:      }
        -:  118:    }
        -:  119:  } else {
    #####:  120:    return g_3;
        -:  121:  }
    #####:  122:  return g_40;
        -:  123:}
        -:  124:
        1:  125:int main(int argc, char *argv[]) {
        -:  126:  int i, j;
        1:  127:  int print_hash_value = 0;
       1*:  128:  if (argc == 2 && strcmp(argv[1], "1") == 0)
    #####:  129:    print_hash_value = 1;
        1:  130:  platform_main_begin();
        1:  131:  crc32_gentab();
        1:  132:  func_1();
        1:  133:  transparent_crc(g_2, "g_2", print_hash_value);
        1:  134:  transparent_crc(g_3, "g_3", print_hash_value);
        4:  135:  for (i = 0; i < 3; i++) {
        3:  136:    transparent_crc(g_4[i], "g_4[i]", print_hash_value);
        3:  137:    if (print_hash_value)
    #####:  138:      printf("index = [%d]\n", i);
        -:  139:  }
        1:  140:  transparent_crc(g_5, "g_5", print_hash_value);
        1:  141:  transparent_crc(g_6, "g_6", print_hash_value);
        2:  142:  for (i = 0; i < 1; i++) {
        4:  143:    for (j = 0; j < 3; j++) {
        3:  144:      transparent_crc(g_27[i][j], "g_27[i][j]", print_hash_value);
        3:  145:      if (print_hash_value)
    #####:  146:        printf("index = [%d][%d]\n", i, j);
        -:  147:    }
        -:  148:  }
        1:  149:  transparent_crc(g_31, "g_31", print_hash_value);
        1:  150:  transparent_crc(g_38.f0, "g_38.f0", print_hash_value);
        1:  151:  transparent_crc(g_40, "g_40", print_hash_value);
        1:  152:  transparent_crc(g_42, "g_42", print_hash_value);
        1:  153:  transparent_crc(g_48.f0, "g_48.f0", print_hash_value);
        1:  154:  transparent_crc(g_51, "g_51", print_hash_value);
        1:  155:  transparent_crc(g_80, "g_80", print_hash_value);
        2:  156:  for (i = 0; i < 1; i++) {
        1:  157:    transparent_crc(g_110[i].f0, "g_110[i].f0", print_hash_value);
        1:  158:    if (print_hash_value)
    #####:  159:      printf("index = [%d]\n", i);
        -:  160:  }
        1:  161:  platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
        1:  162:  return 0;
        -:  163:}
