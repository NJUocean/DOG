        -:    0:Source:887.c
        -:    0:Graph:887.gcno
        -:    0:Data:887.gcda
        -:    0:Runs:1
        -:    1:// Options:   --concise --max-struct-fields 5 --max-funcs 2 --max-array-len-per-dim 5 --max-block-depth 3 --max-block-size 2
        -:    2:#include "csmith.h"
        -:    3:
        -:    4:static long __undefined;
        -:    5:
        -:    6:struct S0 {
        -:    7:  int32_t f0;
        -:    8:  int32_t f1;
        -:    9:};
        -:   10:
        -:   11:struct S1 {
        -:   12:  volatile uint32_t f0;
        -:   13:};
        -:   14:
        -:   15:static uint8_t g_7 = 250UL;
        -:   16:static int8_t g_9[4] = {1L, 1L, 1L, 1L};
        -:   17:static int16_t g_13[5] = {0x2E41L, 0x2E41L, 0x2E41L, 0x2E41L, 0x2E41L};
        -:   18:static uint32_t g_16[2] = {4294967290UL, 4294967290UL};
        -:   19:static volatile uint32_t g_22 = 9UL;
        -:   20:static volatile uint32_t *volatile g_21 = &g_22;
        -:   21:static uint32_t g_24[3][1][1] = {{{0x1649BC00L}}, {{0x1649BC00L}}, {{0x1649BC00L}}};
        -:   22:static uint16_t g_36 = 0xFEDEL;
        -:   23:static uint8_t g_41[5][5][1] = {{{248UL}, {0x6CL}, {248UL}, {0x6CL}, {248UL}}, {{0x6CL}, {248UL}, {0x6CL}, {248UL}, {0x6CL}}, {{248UL}, {0x6CL}, {248UL}, {0x6CL}, {248UL}}, {{0x6CL}, {248UL}, {0x6CL}, {248UL}, {0x6CL}}, {{248UL}, {0x6CL}, {248UL}, {0x6CL}, {248UL}}};
        -:   24:static uint64_t g_49 = 18446744073709551615UL;
        -:   25:static struct S0 g_63 = {-1L, 0x98E57B79L};
        -:   26:static int8_t g_65 = 0x65L;
        -:   27:static int32_t *volatile g_73[3] = {&g_63.f0, &g_63.f0, &g_63.f0};
        -:   28:static int8_t g_74 = (-6L);
        -:   29:static int32_t g_77[3] = {0x4FD71AF1L, 0x4FD71AF1L, 0x4FD71AF1L};
        -:   30:static int16_t *g_80 = &g_13[2];
        -:   31:static uint16_t g_91 = 0xB4E1L;
        -:   32:static volatile int32_t g_94 = 0x5884173BL;
        -:   33:static int64_t g_113 = 0L;
        -:   34:static int64_t g_114[2] = {0x0CD882E3DE941380LL, 0x0CD882E3DE941380LL};
        -:   35:static volatile struct S1 g_129[3] = {{0UL}, {0UL}, {0UL}};
        -:   36:static struct S0 *volatile g_161 = &g_63;
        -:   37:static uint16_t **g_190 = (void *)0;
        -:   38:static int32_t **volatile g_212 = (void *)0;
        -:   39:
        -:   40:static int16_t func_1(void);
        -:   41:static int32_t func_25(int64_t p_26);
        -:   42:
        1:   43:static int16_t func_1(void) {
        1:   44:  uint64_t l_2 = 2UL;
        -:   45:  int8_t l_20[2];
        1:   46:  int16_t **l_81 = &g_80;
        1:   47:  uint16_t *l_116 = &g_36;
        1:   48:  uint16_t **l_115 = &l_116;
        1:   49:  int32_t l_122 = 1L;
        1:   50:  const uint16_t l_168 = 0x00EFL;
        1:   51:  uint64_t *l_200 = &l_2;
        1:   52:  uint16_t **l_203 = &l_116;
        1:   53:  uint16_t *l_205 = &g_36;
        1:   54:  uint16_t **l_204 = &l_205;
        1:   55:  uint16_t *const l_210 = &g_36;
        1:   56:  uint16_t *const *l_209 = &l_210;
        1:   57:  uint16_t *const **l_208 = &l_209;
        1:   58:  uint16_t *const ***l_207 = &l_208;
        -:   59:  uint16_t *l_211[5];
        1:   60:  int32_t *l_214 = &g_77[1];
        -:   61:  int32_t **l_213[1][4];
        -:   62:  int i, j;
        3:   63:  for (i = 0; i < 2; i++)
        2:   64:    l_20[i] = 0L;
        6:   65:  for (i = 0; i < 5; i++)
        5:   66:    l_211[i] = (void *)0;
        2:   67:  for (i = 0; i < 1; i++) {
        5:   68:    for (j = 0; j < 4; j++)
        4:   69:      l_213[i][j] = &l_214;
        -:   70:  }
        1:   71:  if (l_2) {
        -:   72:    int8_t *l_8[1];
        1:   73:    int16_t *l_12[2][2] = {{&g_13[1], &g_13[1]}, {&g_13[1], &g_13[1]}};
        1:   74:    int32_t l_14 = 3L;
        1:   75:    uint32_t *l_15 = &g_16[0];
        1:   76:    int32_t l_19 = (-5L);
        -:   77:    uint32_t *l_23[2];
        1:   78:    int32_t l_75 = 0x2BBEBC4FL;
        1:   79:    int32_t *l_76 = &g_77[1];
        1:   80:    int16_t *l_78 = &g_13[1];
        -:   81:    int16_t **l_79[1][1];
        -:   82:    int i, j;
        2:   83:    for (i = 0; i < 1; i++)
        1:   84:      l_8[i] = &g_9[3];
        3:   85:    for (i = 0; i < 2; i++)
        2:   86:      l_23[i] = &g_24[0][0][0];
        2:   87:    for (i = 0; i < 1; i++) {
        2:   88:      for (j = 0; j < 1; j++)
        1:   89:        l_79[i][j] = (void *)0;
        -:   90:    }
       1*:   91:    (*l_76) &= (safe_mod_func_uint32_t_u_u((safe_sub_func_int8_t_s_s((g_9[1] = g_7), (((((((safe_sub_func_uint32_t_u_u((g_74 = (((*l_15) = ((l_14 = 0L) == 0UL)) >= ((safe_mul_func_int8_t_s_s((l_19 <= (l_20[1] ^ (g_24[0][0][0] &= (g_21 == (void *)0)))), g_13[1])) && func_25(g_22)))), l_2)) || l_75) | g_7) ^ 0xABD3396AL) & l_19), (void *)0) == (void *)0))), l_20[1]));
        1:   92:    if (((g_80 = l_78) != ((*l_76), &g_13[0]))) {
        1:   93:      uint16_t *l_82 = &g_36;
        1:   94:      int32_t l_88 = (-1L);
        1:   95:      uint64_t *l_89 = &l_2;
        1:   96:      uint16_t *l_90 = &g_91;
        1:   97:      if ((((((*l_90) = ((0x2E4B4840L != ((((*l_82) = ((((void *)0 != l_81) < 0UL) ^ g_7)), ((*l_89) = (safe_div_func_int8_t_s_s(((((((safe_mod_func_uint64_t_u_u(l_2, (~l_88))) > 3UL) == (g_77[0] < 0x83L)) != (*g_80)) > g_9[3]) == (*g_21)), g_24[0][0][0])))) <= g_7)), g_22)) & l_88) >= l_20[0]) > (-1L))) {
        1:   98:        uint8_t *l_111[5][4] = {{&g_41[2][1][0], &g_41[2][1][0], &g_41[0][3][0], &g_41[0][3][0]}, {&g_41[2][1][0], &g_41[2][1][0], &g_41[0][3][0], &g_41[0][3][0]}, {&g_41[2][1][0], &g_41[2][1][0], &g_41[0][3][0], &g_41[0][3][0]}, {&g_41[2][1][0], &g_41[2][1][0], &g_41[0][3][0], &g_41[0][3][0]}, {&g_41[2][1][0], &g_41[2][1][0], &g_41[0][3][0], &g_41[0][3][0]}};
        1:   99:        int64_t *l_112 = &g_113;
        -:  100:        int i, j;
       1*:  101:        g_114[0] |= ((-9L) < (((safe_mul_func_int16_t_s_s(((g_94 < (safe_mod_func_int16_t_s_s((((++(*l_89)) <= 0xA0D8654C91E54705LL) < ((safe_mod_func_uint8_t_u_u((safe_add_func_uint32_t_u_u((safe_add_func_int16_t_s_s((*g_80), ((safe_lshift_func_int16_t_s_u(((l_12[1][0] != (l_90 = &g_36)) && (safe_mod_func_int32_t_s_s((((*l_112) = (g_24[1][0][0] != (g_41[2][1][0] = ((safe_div_func_uint16_t_u_u((((*l_76) = 0xA632L) ^ ((((-1L) ^ l_20[1]) ^ g_74) >= g_63.f1)), g_36)) < l_20[1])))) | 0xDB3D834670EA8E11LL), g_74))), 3)), 8L))), g_63.f0)), g_13[1])) ^ 8UL)), (*g_80)))) > g_65), 0L)) != g_36) < l_20[1]));
        -:  102:      } else {
        -:  103:        return (*g_80);
        -:  104:      }
        -:  105:    } else {
    #####:  106:      uint16_t ***l_117 = &l_115;
    #####:  107:      (*l_117) = l_115;
    #####:  108:      for (g_91 = 14; (g_91 >= 42); g_91++) {
    #####:  109:        int8_t l_120 = 1L;
    #####:  110:        int32_t *l_121[4] = {&l_19, &l_19, &l_19, &l_19};
        -:  111:        int i;
    #####:  112:        l_122 |= ((*l_76) = l_120);
    #####:  113:        (*l_76) = 0x72AE737DL;
        -:  114:      }
        -:  115:    }
        -:  116:  } else {
    #####:  117:    int32_t l_134 = 0x8734F539L;
    #####:  118:    uint32_t l_146 = 4294967295UL;
    #####:  119:    uint64_t *l_147 = &l_2;
    #####:  120:    uint16_t ***l_157 = &l_115;
        -:  121:    uint16_t ***l_159[3][1];
    #####:  122:    int32_t l_187 = 0xF4877155L;
        -:  123:    int i, j;
    #####:  124:    for (i = 0; i < 3; i++) {
    #####:  125:      for (j = 0; j < 1; j++)
    #####:  126:        l_159[i][j] = &l_115;
        -:  127:    }
    #####:  128:    if ((safe_mod_func_uint64_t_u_u(((safe_div_func_uint32_t_u_u(((*g_80) ^ (((*l_147) |= (safe_add_func_int32_t_s_s((g_129[1], (safe_mul_func_uint8_t_u_u((((*g_80), (safe_div_func_int16_t_s_s((l_134 || (safe_add_func_int16_t_s_s((g_13[1], ((safe_lshift_func_int32_t_s_u((safe_mul_func_uint32_t_u_u(((safe_rshift_func_int32_t_s_s(l_134, 22)) && (safe_div_func_int8_t_s_s((&l_20[1] != &g_9[1]), ((!l_134), 255UL)))), l_146)), 8)) ^ 0UL)), 9UL))), 0xED2AL))), l_20[0]), g_24[0][0][0]))), g_41[0][2][0]))) ^ g_77[1])), l_134)) != l_146), l_20[1]))) {
    #####:  129:      uint64_t *l_152 = &g_49;
    #####:  130:      int16_t *const *l_153 = &g_80;
    #####:  131:      int32_t l_154 = 0x1AAA12BEL;
    #####:  132:      int32_t *l_155 = &g_63.f1;
    #####:  133:      int64_t *l_156 = &g_114[0];
        -:  134:      uint16_t ****l_158[1];
        -:  135:      int i;
    #####:  136:      for (i = 0; i < 1; i++)
    #####:  137:        l_158[i] = &l_157;
    #####:  138:      if (((safe_mod_func_int32_t_s_s(((l_157 = (((*l_156) = ((((*l_152) = (--(*l_147))), (void *)0) == ((((l_153 != (l_81 = &g_80)) != (g_91 &= g_36)) & l_154), l_155))), ((*l_155), l_157))) != (l_159[1][0] = l_159[1][0])), (*g_21))) > (*l_155))) {
    #####:  139:        return (*g_80);
        -:  140:      } else {
    #####:  141:        struct S0 l_160 = {0xEF8999B4L, -5L};
    #####:  142:        (*g_161) = l_160;
        -:  143:      }
    #####:  144:      return l_134;
        -:  145:    } else {
        -:  146:      int64_t l_169[2];
    #####:  147:      uint32_t l_174 = 0x682B91D3L;
        -:  148:      int32_t l_175[2][1];
    #####:  149:      uint16_t ****l_186 = &l_159[1][0];
    #####:  150:      int32_t l_191 = 0L;
    #####:  151:      uint32_t *l_192 = &g_16[0];
    #####:  152:      uint32_t *l_193 = &g_24[0][0][0];
    #####:  153:      int32_t *l_194 = (void *)0;
    #####:  154:      int32_t *l_195 = &g_63.f1;
        -:  155:      int i, j;
    #####:  156:      for (i = 0; i < 2; i++)
    #####:  157:        l_169[i] = (-1L);
    #####:  158:      for (i = 0; i < 2; i++) {
    #####:  159:        for (j = 0; j < 1; j++)
    #####:  160:          l_175[i][j] = (-7L);
        -:  161:      }
    #####:  162:    lbl_170:
    #####:  163:      for (l_134 = 0; (l_134 >= (-6)); --l_134) {
    #####:  164:        return (*g_80);
        -:  165:      }
    #####:  166:      if (g_65)
    #####:  167:        goto lbl_171;
    #####:  168:      if ((safe_mod_func_uint16_t_u_u(65535UL, (safe_add_func_int32_t_s_s((l_168 == l_169[0]), 4294967288UL))))) {
    #####:  169:        g_161 = &g_63;
        -:  170:      } else {
    #####:  171:      lbl_171:
    #####:  172:        if (g_63.f0)
    #####:  173:          goto lbl_170;
    #####:  174:        (*l_195) ^= (0L || ((*l_193) = ((*l_192) |= ((((((l_175[0][0] = (safe_lshift_func_uint64_t_u_s((8UL | l_174), 6))) & (safe_div_func_int64_t_s_s((safe_mul_func_uint32_t_u_u((((*l_147) |= ((*g_21) && ((safe_rshift_func_int32_t_s_u(((safe_mul_func_uint8_t_u_u((safe_sub_func_uint16_t_u_u((((void *)0 == l_186) >= (l_187 = ((void *)0 == &l_20[1]))), (safe_lshift_func_uint64_t_u_s(((((**l_186) = g_190) != &l_116), l_191), 16)))), g_41[4][0][0])) == l_169[0]), (*g_21))) ^ 0L))) ^ 0x7D4B22FE7AF752ECLL), l_169[0])), g_113))) & l_134) && 4294967295UL), l_175[0][0]) && g_41[0][1][0]))));
        -:  175:      }
        -:  176:    }
        -:  177:  }
       1*:  178:  g_73[2] = (((safe_mod_func_int64_t_s_s((safe_add_func_uint64_t_u_u(((*l_200) ^= (65529UL == ((*g_80) = ((void *)0 == (*l_81))))), (safe_mod_func_uint32_t_u_u((((((((((*g_161), ((*l_204) = ((*l_203) = &g_36))) != ((safe_unary_minus_func_int16_t_s(((void *)0 != l_207))), l_211[4])) > (g_9[1] > 0xA028DDFEL)) & 65535UL) ^ l_20[0]) <= g_24[0][0][0]) ^ 0xB994L), l_20[1]), 0xD2540276L)))), g_9[3])) < 253UL), &g_77[1]);
        1:  179:  return (*g_80);
        -:  180:}
        -:  181:
    #####:  182:static int32_t func_25(int64_t p_26) {
    #####:  183:  int16_t l_46 = 1L;
    #####:  184:  int32_t l_50 = 0xAE3C77D9L;
    #####:  185:  int8_t *l_64 = &g_65;
    #####:  186:  struct S0 l_70[4] = {{9L, 6L}, {9L, 6L}, {9L, 6L}, {9L, 6L}};
    #####:  187:  int32_t l_71 = 0x823142ACL;
    #####:  188:  uint8_t *l_72[5] = {&g_41[4][3][0], &g_41[4][3][0], &g_41[4][3][0], &g_41[4][3][0], &g_41[4][3][0]};
        -:  189:  int i;
    #####:  190:  for (p_26 = 0; (p_26 >= 27); p_26++) {
    #####:  191:    uint16_t *l_35 = &g_36;
    #####:  192:    int32_t l_45 = 0x280563ADL;
    #####:  193:    uint8_t l_47 = 246UL;
    #####:  194:    uint64_t *l_48 = &g_49;
    #####:  195:    int32_t l_51 = 0L;
    #####:  196:    l_51 |= ((safe_lshift_func_uint64_t_u_s((safe_div_func_uint16_t_u_u(((*l_35) &= 0x624BL), ((safe_lshift_func_uint16_t_u_s(((safe_lshift_func_int32_t_s_s((g_41[2][1][0] &= p_26), (l_50 = (((1UL > (((safe_mod_func_uint64_t_u_u(((+l_45), (0x2E8B5A47B6C411E6LL || l_46)), ((*l_48) = l_47))) < g_22) > (((0x3C5EBB4EL != l_47), p_26) & l_46))) == 0xC2D16CF0L), 0x46AC1DEAL)))) <= 0x275F98A9L), 13)), g_24[1][0][0]))), p_26)) > 0UL);
        -:  197:  }
    #####:  198:  l_70[2].f1 = (l_50, ((safe_lshift_func_int32_t_s_s((safe_mul_func_uint32_t_u_u(4294967291UL, (0xA615B38D6AEAB669LL | (((((safe_sub_func_uint64_t_u_u(((((g_49, (safe_rshift_func_int16_t_s_s((+(((l_70[2].f0 = (((g_63, ((*l_64) ^= 5L)), ((p_26, ((((safe_lshift_func_int32_t_s_u((l_71 = ((safe_mod_func_uint32_t_u_u((p_26, (l_70[2], 6UL)), 0x900A0D1FL)) <= g_22)), 16)), (-6L)) && l_70[2].f0) | 0x3D5EL)) & l_50)) | 1L)) <= p_26), l_71)), 13))) <= l_50) | p_26) >= l_50), p_26)) == 0xB3L) <= 0x368DL), g_24[2][0][0]) == l_50)))), 27)) ^ 0xA0L));
    #####:  199:  return l_46;
        -:  200:}
        -:  201:
        1:  202:int main(int argc, char *argv[]) {
        -:  203:  int i, j, k;
        1:  204:  int print_hash_value = 0;
       1*:  205:  if (argc == 2 && strcmp(argv[1], "1") == 0)
    #####:  206:    print_hash_value = 1;
        1:  207:  platform_main_begin();
        1:  208:  crc32_gentab();
        1:  209:  func_1();
        1:  210:  transparent_crc(g_7, "g_7", print_hash_value);
        5:  211:  for (i = 0; i < 4; i++) {
        4:  212:    transparent_crc(g_9[i], "g_9[i]", print_hash_value);
        4:  213:    if (print_hash_value)
    #####:  214:      printf("index = [%d]\n", i);
        -:  215:  }
        6:  216:  for (i = 0; i < 5; i++) {
        5:  217:    transparent_crc(g_13[i], "g_13[i]", print_hash_value);
        5:  218:    if (print_hash_value)
    #####:  219:      printf("index = [%d]\n", i);
        -:  220:  }
        3:  221:  for (i = 0; i < 2; i++) {
        2:  222:    transparent_crc(g_16[i], "g_16[i]", print_hash_value);
        2:  223:    if (print_hash_value)
    #####:  224:      printf("index = [%d]\n", i);
        -:  225:  }
        1:  226:  transparent_crc(g_22, "g_22", print_hash_value);
        4:  227:  for (i = 0; i < 3; i++) {
        6:  228:    for (j = 0; j < 1; j++) {
        6:  229:      for (k = 0; k < 1; k++) {
        3:  230:        transparent_crc(g_24[i][j][k], "g_24[i][j][k]", print_hash_value);
        3:  231:        if (print_hash_value)
    #####:  232:          printf("index = [%d][%d][%d]\n", i, j, k);
        -:  233:      }
        -:  234:    }
        -:  235:  }
        1:  236:  transparent_crc(g_36, "g_36", print_hash_value);
        6:  237:  for (i = 0; i < 5; i++) {
       30:  238:    for (j = 0; j < 5; j++) {
       50:  239:      for (k = 0; k < 1; k++) {
       25:  240:        transparent_crc(g_41[i][j][k], "g_41[i][j][k]", print_hash_value);
       25:  241:        if (print_hash_value)
    #####:  242:          printf("index = [%d][%d][%d]\n", i, j, k);
        -:  243:      }
        -:  244:    }
        -:  245:  }
        1:  246:  transparent_crc(g_49, "g_49", print_hash_value);
        1:  247:  transparent_crc(g_63.f0, "g_63.f0", print_hash_value);
        1:  248:  transparent_crc(g_63.f1, "g_63.f1", print_hash_value);
        1:  249:  transparent_crc(g_65, "g_65", print_hash_value);
        1:  250:  transparent_crc(g_74, "g_74", print_hash_value);
        4:  251:  for (i = 0; i < 3; i++) {
        3:  252:    transparent_crc(g_77[i], "g_77[i]", print_hash_value);
        3:  253:    if (print_hash_value)
    #####:  254:      printf("index = [%d]\n", i);
        -:  255:  }
        1:  256:  transparent_crc(g_91, "g_91", print_hash_value);
        1:  257:  transparent_crc(g_94, "g_94", print_hash_value);
        1:  258:  transparent_crc(g_113, "g_113", print_hash_value);
        3:  259:  for (i = 0; i < 2; i++) {
        2:  260:    transparent_crc(g_114[i], "g_114[i]", print_hash_value);
        2:  261:    if (print_hash_value)
    #####:  262:      printf("index = [%d]\n", i);
        -:  263:  }
        4:  264:  for (i = 0; i < 3; i++) {
        3:  265:    transparent_crc(g_129[i].f0, "g_129[i].f0", print_hash_value);
        3:  266:    if (print_hash_value)
    #####:  267:      printf("index = [%d]\n", i);
        -:  268:  }
        1:  269:  platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
        1:  270:  return 0;
        -:  271:}
