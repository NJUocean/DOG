// Options:   --concise --max-struct-fields 5 --max-funcs 2 --max-array-len-per-dim 5 --max-block-depth 3 --max-block-size 2
#include "csmith.h"

static long __undefined;

#pragma pack(push)
#pragma pack(1)
struct S0 {
  signed f0 : 16;
  volatile signed f1 : 5;
  const volatile signed f2 : 19;
};
#pragma pack(pop)

struct S1 {
  unsigned f0 : 4;
  signed : 0;
};

union U2 {
  volatile uint16_t f0;
  volatile int32_t f1;
  uint32_t f2;
};

static struct S0 g_2[1][3][2] = {{{{199, -3, -150}, {199, -3, -150}}, {{199, -3, -150}, {199, -3, -150}}, {{199, -3, -150}, {199, -3, -150}}}};
static uint16_t g_6 = 5UL;
static uint32_t g_25[1] = {0x2249687FL};
static int32_t g_27[4] = {5L, 5L, 5L, 5L};
static int32_t g_30 = 0x8F15EA37L;
static int32_t g_33 = 0xF18B0119L;
static int32_t g_38[3] = {0L, 0L, 0L};
static union U2 g_44 = {0x1DB3L};
static const union U2 *g_47 = (void *)0;
static union U2 *g_55 = (void *)0;
static union U2 **g_54[2] = {&g_55, &g_55};
static union U2 ***volatile g_53[5] = {&g_54[1], &g_54[1], &g_54[1], &g_54[1], &g_54[1]};
static const struct S0 g_60 = {158, 0, 237};
static const struct S0 *g_59 = &g_60;
static int32_t *volatile g_71 = &g_38[2];
static int16_t g_95 = 0x9EFCL;
static struct S1 g_98[3] = {{0}, {0}, {0}};
static uint64_t g_114 = 18446744073709551613UL;
static uint64_t *g_113[2] = {&g_114, &g_114};
static int64_t g_118 = (-5L);

static uint32_t func_1(void);
static const int64_t func_15(uint16_t *p_16);

static uint32_t func_1(void) {
  uint64_t l_3 = 0xAEE5A9864BA8B35ELL;
  int32_t l_4 = 2L;
  uint16_t *l_5 = &g_6;
  int32_t *l_9 = (void *)0;
  int32_t *l_10 = &l_4;
  int8_t l_12 = (-1L);
  uint8_t l_17[1];
  uint32_t *l_24 = &g_25[0];
  const struct S0 *l_57 = &g_2[0][2][1];
  int32_t l_73 = 0x4A889BFFL;
  int32_t l_74 = 0xDCB43529L;
  int32_t l_75 = 0x7F8B30C5L;
  int32_t l_76 = 0x6D4D43A6L;
  int32_t l_77 = 0x622CCD07L;
  int32_t l_119 = 1L;
  int i;
  for (i = 0; i < 1; i++)
    l_17[i] = 1UL;
  if ((((g_2[0][1][1], (((l_3, ((*l_10) = ((--(*l_5)) < l_4))) != (safe_unary_minus_func_uint16_t_u(l_12))) <= 0x2F3D47941CE3CB5ALL)) & l_12) ^ (safe_sub_func_int64_t_s_s(func_15(((l_17[0] | (safe_add_func_int16_t_s_s((((safe_mul_func_uint64_t_u_u((safe_mod_func_int32_t_s_s((((((*l_24) = g_2[0][1][1].f0) | (!(g_2[0][1][1].f0, g_2[0][1][1].f0))) >= 250UL), 0x2B2E5F58L), g_2[0][1][1].f0)), g_2[0][1][1].f0)) ^ 0xDB51FD9AB8A87EA8LL) ^ 8UL), g_2[0][1][1].f0))), l_5)), 0UL)))) {
    int32_t l_69 = 1L;
    int32_t l_78 = 0L;
    int16_t *l_91 = (void *)0;
    int16_t *l_92 = (void *)0;
    int32_t l_93 = 1L;
    int16_t *l_94 = &g_95;
    if (((*l_10) = (*l_10))) {
      union U2 **l_51 = (void *)0;
      union U2 ***l_52 = (void *)0;
      union U2 ***l_56 = &g_54[1];
      const struct S0 **l_58[4];
      int i;
      for (i = 0; i < 4; i++)
        l_58[i] = &l_57;
      (*l_56) = l_51;
      g_59 = l_57;
    } else {
      int32_t *l_72[3];
      uint32_t l_79 = 1UL;
      int i;
      for (i = 0; i < 3; i++)
        l_72[i] = &g_38[2];
      for (l_4 = 0; (l_4 == 1); l_4++) {
        int32_t l_63[2];
        uint64_t *l_64 = (void *)0;
        uint64_t *l_65[2][2];
        uint64_t l_66 = 0xE6AC9C4BD7DA5A1DLL;
        int32_t *l_70 = (void *)0;
        int i, j;
        for (i = 0; i < 2; i++)
          l_63[i] = 0x0BDE7D1EL;
        for (i = 0; i < 2; i++) {
          for (j = 0; j < 2; j++)
            l_65[i][j] = &l_3;
        }
        if (l_63[0])
          break;
        (*g_71) = (65535UL & ((++l_66) <= l_69));
      }
      --l_79;
    }
    if ((safe_div_func_uint16_t_u_u(((1L >= (-2L)) ^ (*g_71)), ((*l_94) = ((((safe_sub_func_uint32_t_u_u((~(~(((!((-3L) <= ((l_93 |= ((safe_div_func_uint8_t_u_u(((g_60.f0 <= ((0x9EDFL <= ((l_69 |= g_6) || 3L)) == 255UL)) >= l_78), 2UL)), 0x362DL)) | g_38[2]))) <= g_25[0]), 18446744073709551615UL))), g_25[0])) | g_27[0]) ^ (*l_10)), l_78))))) {
      g_2[0][1][1].f0 |= (*g_71);
    } else {
      struct S1 l_99[3][3][4] = {{{{1}, {1}, {1}, {1}}, {{1}, {1}, {1}, {1}}, {{1}, {1}, {1}, {1}}}, {{{1}, {1}, {1}, {1}}, {{1}, {1}, {1}, {1}}, {{1}, {1}, {1}, {1}}}, {{{1}, {1}, {1}, {1}}, {{1}, {1}, {1}, {1}}, {{1}, {1}, {1}, {1}}}};
      int i, j, k;
      for (l_3 = 28; (l_3 > 59); ++l_3) {
        l_99[1][1][3] = g_98[0];
      }
    }
  } else {
    struct S0 *l_103 = &g_2[0][1][1];
    int32_t l_106 = (-1L);
    for (l_12 = 2; (l_12 >= 0); l_12 -= 1) {
      (*l_10) = (safe_mod_func_uint16_t_u_u(g_98[0].f0, g_44.f0));
      for (l_4 = 0; (l_4 <= 0); l_4 += 1) {
        int i;
        g_38[(l_4 + 1)] ^= ((!(((g_25[l_4], l_103) != (g_60.f0, &g_2[0][0][1])) < (safe_lshift_func_uint16_t_u_u(65535UL, 4)))) != l_106);
      }
    }
    for (l_75 = 0; (l_75 >= 0); l_75 -= 1) {
      struct S1 l_109 = {3};
      int32_t l_110 = 0x465DC084L;
      int i;
      (*l_10) &= (safe_add_func_uint64_t_u_u(((1L == ((*l_5) ^= g_25[l_75])) < ((l_109, 0UL) && 0x369BL)), (l_110 = (g_44, (-1L)))));
      for (l_77 = 0; (l_77 <= 0); l_77 += 1) {
        uint64_t *l_115 = &l_3;
        uint64_t **l_116 = &l_115;
        int64_t *l_117 = &g_118;
        int i;
        (*g_71) = (l_110 = ((safe_mul_func_int64_t_s_s((l_17[l_77], ((*l_117) |= (l_17[l_75] == (g_113[0] == ((*l_116) = l_115))))), g_25[l_75])) || 2L));
      }
    }
  }
  return l_119;
}

static const int64_t func_15(uint16_t *p_16) {
  int32_t *l_36[4][2][5] = {{{&g_30, &g_30, &g_27[2], (void *)0, &g_27[0]}, {&g_33, &g_27[2], (void *)0, &g_27[2], &g_33}}, {{&g_27[0], &g_30, &g_30, &g_33, &g_27[0]}, {&g_27[0], &g_27[0], &g_27[0], &g_30, &g_30}}, {{&g_33, (void *)0, &g_33, &g_30, &g_27[0]}, {&g_30, &g_30, &g_27[0], &g_30, &g_33}}, {{&g_27[0], &g_27[0], &g_30, &g_30, &g_27[0]}, {&g_27[0], (void *)0, &g_27[0], &g_33, &g_30}}};
  const union U2 *l_43 = &g_44;
  uint8_t l_48[3];
  int i, j, k;
  for (i = 0; i < 3; i++)
    l_48[i] = 250UL;
  for (g_27[0] = (-4); (g_27[0] != 17); g_27[0]++) {
    int32_t *l_37 = &g_38[2];
    int32_t l_39 = 0xCE3C4897L;
    for (g_30 = 0; (g_30 >= 4); g_30++) {
      const union U2 **l_45 = (void *)0;
      const union U2 **l_46 = (void *)0;
      for (g_33 = (-7); (g_33 < 0); g_33 = safe_add_func_uint32_t_u_u(g_33, 6)) {
        uint32_t l_40[1][2];
        int i, j;
        for (i = 0; i < 1; i++) {
          for (j = 0; j < 2; j++)
            l_40[i][j] = 0xCE724D25L;
        }
        l_37 = l_36[1][1][2];
        l_40[0][1]++;
      }
      g_47 = l_43;
    }
    if (g_27[0])
      continue;
  }
  --l_48[1];
  return g_38[1];
}

int main(int argc, char *argv[]) {
  int i, j, k;
  int print_hash_value = 0;
  if (argc == 2 && strcmp(argv[1], "1") == 0)
    print_hash_value = 1;
  platform_main_begin();
  crc32_gentab();
  func_1();
  for (i = 0; i < 1; i++) {
    for (j = 0; j < 3; j++) {
      for (k = 0; k < 2; k++) {
        transparent_crc(g_2[i][j][k].f0, "g_2[i][j][k].f0", print_hash_value);
        transparent_crc(g_2[i][j][k].f1, "g_2[i][j][k].f1", print_hash_value);
        transparent_crc(g_2[i][j][k].f2, "g_2[i][j][k].f2", print_hash_value);
        if (print_hash_value)
          printf("index = [%d][%d][%d]\n", i, j, k);
      }
    }
  }
  transparent_crc(g_6, "g_6", print_hash_value);
  for (i = 0; i < 1; i++) {
    transparent_crc(g_25[i], "g_25[i]", print_hash_value);
    if (print_hash_value)
      printf("index = [%d]\n", i);
  }
  for (i = 0; i < 4; i++) {
    transparent_crc(g_27[i], "g_27[i]", print_hash_value);
    if (print_hash_value)
      printf("index = [%d]\n", i);
  }
  transparent_crc(g_30, "g_30", print_hash_value);
  transparent_crc(g_33, "g_33", print_hash_value);
  for (i = 0; i < 3; i++) {
    transparent_crc(g_38[i], "g_38[i]", print_hash_value);
    if (print_hash_value)
      printf("index = [%d]\n", i);
  }
  transparent_crc(g_44.f0, "g_44.f0", print_hash_value);
  transparent_crc(g_60.f0, "g_60.f0", print_hash_value);
  transparent_crc(g_60.f1, "g_60.f1", print_hash_value);
  transparent_crc(g_60.f2, "g_60.f2", print_hash_value);
  transparent_crc(g_95, "g_95", print_hash_value);
  for (i = 0; i < 3; i++) {
    transparent_crc(g_98[i].f0, "g_98[i].f0", print_hash_value);
    if (print_hash_value)
      printf("index = [%d]\n", i);
  }
  transparent_crc(g_114, "g_114", print_hash_value);
  transparent_crc(g_118, "g_118", print_hash_value);
  platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
  return 0;
}
