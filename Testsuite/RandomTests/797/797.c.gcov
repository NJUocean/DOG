        -:    0:Source:797.c
        -:    0:Graph:797.gcno
        -:    0:Data:797.gcda
        -:    0:Runs:1
        -:    1:// Options:   --concise --max-struct-fields 5 --max-funcs 2 --max-array-len-per-dim 5 --max-block-depth 3 --max-block-size 2
        -:    2:#include "csmith.h"
        -:    3:
        -:    4:static long __undefined;
        -:    5:
        -:    6:#pragma pack(push)
        -:    7:#pragma pack(1)
        -:    8:struct S0 {
        -:    9:  signed f0 : 16;
        -:   10:  volatile signed f1 : 5;
        -:   11:  const volatile signed f2 : 19;
        -:   12:};
        -:   13:#pragma pack(pop)
        -:   14:
        -:   15:struct S1 {
        -:   16:  unsigned f0 : 4;
        -:   17:  signed : 0;
        -:   18:};
        -:   19:
        -:   20:union U2 {
        -:   21:  volatile uint16_t f0;
        -:   22:  volatile int32_t f1;
        -:   23:  uint32_t f2;
        -:   24:};
        -:   25:
        -:   26:static struct S0 g_2[1][3][2] = {{{{199, -3, -150}, {199, -3, -150}}, {{199, -3, -150}, {199, -3, -150}}, {{199, -3, -150}, {199, -3, -150}}}};
        -:   27:static uint16_t g_6 = 5UL;
        -:   28:static uint32_t g_25[1] = {0x2249687FL};
        -:   29:static int32_t g_27[4] = {5L, 5L, 5L, 5L};
        -:   30:static int32_t g_30 = 0x8F15EA37L;
        -:   31:static int32_t g_33 = 0xF18B0119L;
        -:   32:static int32_t g_38[3] = {0L, 0L, 0L};
        -:   33:static union U2 g_44 = {0x1DB3L};
        -:   34:static const union U2 *g_47 = (void *)0;
        -:   35:static union U2 *g_55 = (void *)0;
        -:   36:static union U2 **g_54[2] = {&g_55, &g_55};
        -:   37:static union U2 ***volatile g_53[5] = {&g_54[1], &g_54[1], &g_54[1], &g_54[1], &g_54[1]};
        -:   38:static const struct S0 g_60 = {158, 0, 237};
        -:   39:static const struct S0 *g_59 = &g_60;
        -:   40:static int32_t *volatile g_71 = &g_38[2];
        -:   41:static int16_t g_95 = 0x9EFCL;
        -:   42:static struct S1 g_98[3] = {{0}, {0}, {0}};
        -:   43:static uint64_t g_114 = 18446744073709551613UL;
        -:   44:static uint64_t *g_113[2] = {&g_114, &g_114};
        -:   45:static int64_t g_118 = (-5L);
        -:   46:
        -:   47:static uint32_t func_1(void);
        -:   48:static const int64_t func_15(uint16_t *p_16);
        -:   49:
        1:   50:static uint32_t func_1(void) {
        1:   51:  uint64_t l_3 = 0xAEE5A9864BA8B35ELL;
        1:   52:  int32_t l_4 = 2L;
        1:   53:  uint16_t *l_5 = &g_6;
        1:   54:  int32_t *l_9 = (void *)0;
        1:   55:  int32_t *l_10 = &l_4;
        1:   56:  int8_t l_12 = (-1L);
        -:   57:  uint8_t l_17[1];
        1:   58:  uint32_t *l_24 = &g_25[0];
        1:   59:  const struct S0 *l_57 = &g_2[0][2][1];
        1:   60:  int32_t l_73 = 0x4A889BFFL;
        1:   61:  int32_t l_74 = 0xDCB43529L;
        1:   62:  int32_t l_75 = 0x7F8B30C5L;
        1:   63:  int32_t l_76 = 0x6D4D43A6L;
        1:   64:  int32_t l_77 = 0x622CCD07L;
        1:   65:  int32_t l_119 = 1L;
        -:   66:  int i;
        2:   67:  for (i = 0; i < 1; i++)
        1:   68:    l_17[i] = 1UL;
        1:   69:  if ((((g_2[0][1][1], (((l_3, ((*l_10) = ((--(*l_5)) < l_4))) != (safe_unary_minus_func_uint16_t_u(l_12))) <= 0x2F3D47941CE3CB5ALL)) & l_12) ^ (safe_sub_func_int64_t_s_s(func_15(((l_17[0] | (safe_add_func_int16_t_s_s((((safe_mul_func_uint64_t_u_u((safe_mod_func_int32_t_s_s((((((*l_24) = g_2[0][1][1].f0) | (!(g_2[0][1][1].f0, g_2[0][1][1].f0))) >= 250UL), 0x2B2E5F58L), g_2[0][1][1].f0)), g_2[0][1][1].f0)) ^ 0xDB51FD9AB8A87EA8LL) ^ 8UL), g_2[0][1][1].f0))), l_5)), 0UL)))) {
        1:   70:    int32_t l_69 = 1L;
        1:   71:    int32_t l_78 = 0L;
        1:   72:    int16_t *l_91 = (void *)0;
        1:   73:    int16_t *l_92 = (void *)0;
        1:   74:    int32_t l_93 = 1L;
        1:   75:    int16_t *l_94 = &g_95;
        1:   76:    if (((*l_10) = (*l_10))) {
    #####:   77:      union U2 **l_51 = (void *)0;
    #####:   78:      union U2 ***l_52 = (void *)0;
    #####:   79:      union U2 ***l_56 = &g_54[1];
        -:   80:      const struct S0 **l_58[4];
        -:   81:      int i;
    #####:   82:      for (i = 0; i < 4; i++)
    #####:   83:        l_58[i] = &l_57;
    #####:   84:      (*l_56) = l_51;
    #####:   85:      g_59 = l_57;
        -:   86:    } else {
        -:   87:      int32_t *l_72[3];
        1:   88:      uint32_t l_79 = 1UL;
        -:   89:      int i;
        4:   90:      for (i = 0; i < 3; i++)
        3:   91:        l_72[i] = &g_38[2];
       1*:   92:      for (l_4 = 0; (l_4 == 1); l_4++) {
        -:   93:        int32_t l_63[2];
    #####:   94:        uint64_t *l_64 = (void *)0;
        -:   95:        uint64_t *l_65[2][2];
    #####:   96:        uint64_t l_66 = 0xE6AC9C4BD7DA5A1DLL;
    #####:   97:        int32_t *l_70 = (void *)0;
        -:   98:        int i, j;
    #####:   99:        for (i = 0; i < 2; i++)
    #####:  100:          l_63[i] = 0x0BDE7D1EL;
    #####:  101:        for (i = 0; i < 2; i++) {
    #####:  102:          for (j = 0; j < 2; j++)
    #####:  103:            l_65[i][j] = &l_3;
        -:  104:        }
    #####:  105:        if (l_63[0])
    #####:  106:          break;
    #####:  107:        (*g_71) = (65535UL & ((++l_66) <= l_69));
        -:  108:      }
        1:  109:      --l_79;
        -:  110:    }
        1:  111:    if ((safe_div_func_uint16_t_u_u(((1L >= (-2L)) ^ (*g_71)), ((*l_94) = ((((safe_sub_func_uint32_t_u_u((~(~(((!((-3L) <= ((l_93 |= ((safe_div_func_uint8_t_u_u(((g_60.f0 <= ((0x9EDFL <= ((l_69 |= g_6) || 3L)) == 255UL)) >= l_78), 2UL)), 0x362DL)) | g_38[2]))) <= g_25[0]), 18446744073709551615UL))), g_25[0])) | g_27[0]) ^ (*l_10)), l_78))))) {
        1:  112:      g_2[0][1][1].f0 |= (*g_71);
        -:  113:    } else {
    #####:  114:      struct S1 l_99[3][3][4] = {{{{1}, {1}, {1}, {1}}, {{1}, {1}, {1}, {1}}, {{1}, {1}, {1}, {1}}}, {{{1}, {1}, {1}, {1}}, {{1}, {1}, {1}, {1}}, {{1}, {1}, {1}, {1}}}, {{{1}, {1}, {1}, {1}}, {{1}, {1}, {1}, {1}}, {{1}, {1}, {1}, {1}}}};
        -:  115:      int i, j, k;
    #####:  116:      for (l_3 = 28; (l_3 > 59); ++l_3) {
    #####:  117:        l_99[1][1][3] = g_98[0];
        -:  118:      }
        -:  119:    }
        -:  120:  } else {
    #####:  121:    struct S0 *l_103 = &g_2[0][1][1];
    #####:  122:    int32_t l_106 = (-1L);
    #####:  123:    for (l_12 = 2; (l_12 >= 0); l_12 -= 1) {
    #####:  124:      (*l_10) = (safe_mod_func_uint16_t_u_u(g_98[0].f0, g_44.f0));
    #####:  125:      for (l_4 = 0; (l_4 <= 0); l_4 += 1) {
        -:  126:        int i;
    #####:  127:        g_38[(l_4 + 1)] ^= ((!(((g_25[l_4], l_103) != (g_60.f0, &g_2[0][0][1])) < (safe_lshift_func_uint16_t_u_u(65535UL, 4)))) != l_106);
        -:  128:      }
        -:  129:    }
    #####:  130:    for (l_75 = 0; (l_75 >= 0); l_75 -= 1) {
    #####:  131:      struct S1 l_109 = {3};
    #####:  132:      int32_t l_110 = 0x465DC084L;
        -:  133:      int i;
    #####:  134:      (*l_10) &= (safe_add_func_uint64_t_u_u(((1L == ((*l_5) ^= g_25[l_75])) < ((l_109, 0UL) && 0x369BL)), (l_110 = (g_44, (-1L)))));
    #####:  135:      for (l_77 = 0; (l_77 <= 0); l_77 += 1) {
    #####:  136:        uint64_t *l_115 = &l_3;
    #####:  137:        uint64_t **l_116 = &l_115;
    #####:  138:        int64_t *l_117 = &g_118;
        -:  139:        int i;
    #####:  140:        (*g_71) = (l_110 = ((safe_mul_func_int64_t_s_s((l_17[l_77], ((*l_117) |= (l_17[l_75] == (g_113[0] == ((*l_116) = l_115))))), g_25[l_75])) || 2L));
        -:  141:      }
        -:  142:    }
        -:  143:  }
        1:  144:  return l_119;
        -:  145:}
        -:  146:
        1:  147:static const int64_t func_15(uint16_t *p_16) {
        1:  148:  int32_t *l_36[4][2][5] = {{{&g_30, &g_30, &g_27[2], (void *)0, &g_27[0]}, {&g_33, &g_27[2], (void *)0, &g_27[2], &g_33}}, {{&g_27[0], &g_30, &g_30, &g_33, &g_27[0]}, {&g_27[0], &g_27[0], &g_27[0], &g_30, &g_30}}, {{&g_33, (void *)0, &g_33, &g_30, &g_27[0]}, {&g_30, &g_30, &g_27[0], &g_30, &g_33}}, {{&g_27[0], &g_27[0], &g_30, &g_30, &g_27[0]}, {&g_27[0], (void *)0, &g_27[0], &g_33, &g_30}}};
        1:  149:  const union U2 *l_43 = &g_44;
        -:  150:  uint8_t l_48[3];
        -:  151:  int i, j, k;
        4:  152:  for (i = 0; i < 3; i++)
        3:  153:    l_48[i] = 250UL;
       22:  154:  for (g_27[0] = (-4); (g_27[0] != 17); g_27[0]++) {
       21:  155:    int32_t *l_37 = &g_38[2];
       21:  156:    int32_t l_39 = 0xCE3C4897L;
      21*:  157:    for (g_30 = 0; (g_30 >= 4); g_30++) {
    #####:  158:      const union U2 **l_45 = (void *)0;
    #####:  159:      const union U2 **l_46 = (void *)0;
    #####:  160:      for (g_33 = (-7); (g_33 < 0); g_33 = safe_add_func_uint32_t_u_u(g_33, 6)) {
        -:  161:        uint32_t l_40[1][2];
        -:  162:        int i, j;
    #####:  163:        for (i = 0; i < 1; i++) {
    #####:  164:          for (j = 0; j < 2; j++)
    #####:  165:            l_40[i][j] = 0xCE724D25L;
        -:  166:        }
    #####:  167:        l_37 = l_36[1][1][2];
    #####:  168:        l_40[0][1]++;
        -:  169:      }
    #####:  170:      g_47 = l_43;
        -:  171:    }
       21:  172:    if (g_27[0])
       20:  173:      continue;
        -:  174:  }
        1:  175:  --l_48[1];
        1:  176:  return g_38[1];
        -:  177:}
        -:  178:
        1:  179:int main(int argc, char *argv[]) {
        -:  180:  int i, j, k;
        1:  181:  int print_hash_value = 0;
       1*:  182:  if (argc == 2 && strcmp(argv[1], "1") == 0)
    #####:  183:    print_hash_value = 1;
        1:  184:  platform_main_begin();
        1:  185:  crc32_gentab();
        1:  186:  func_1();
        2:  187:  for (i = 0; i < 1; i++) {
        4:  188:    for (j = 0; j < 3; j++) {
        9:  189:      for (k = 0; k < 2; k++) {
        6:  190:        transparent_crc(g_2[i][j][k].f0, "g_2[i][j][k].f0", print_hash_value);
        6:  191:        transparent_crc(g_2[i][j][k].f1, "g_2[i][j][k].f1", print_hash_value);
        6:  192:        transparent_crc(g_2[i][j][k].f2, "g_2[i][j][k].f2", print_hash_value);
        6:  193:        if (print_hash_value)
    #####:  194:          printf("index = [%d][%d][%d]\n", i, j, k);
        -:  195:      }
        -:  196:    }
        -:  197:  }
        1:  198:  transparent_crc(g_6, "g_6", print_hash_value);
        2:  199:  for (i = 0; i < 1; i++) {
        1:  200:    transparent_crc(g_25[i], "g_25[i]", print_hash_value);
        1:  201:    if (print_hash_value)
    #####:  202:      printf("index = [%d]\n", i);
        -:  203:  }
        5:  204:  for (i = 0; i < 4; i++) {
        4:  205:    transparent_crc(g_27[i], "g_27[i]", print_hash_value);
        4:  206:    if (print_hash_value)
    #####:  207:      printf("index = [%d]\n", i);
        -:  208:  }
        1:  209:  transparent_crc(g_30, "g_30", print_hash_value);
        1:  210:  transparent_crc(g_33, "g_33", print_hash_value);
        4:  211:  for (i = 0; i < 3; i++) {
        3:  212:    transparent_crc(g_38[i], "g_38[i]", print_hash_value);
        3:  213:    if (print_hash_value)
    #####:  214:      printf("index = [%d]\n", i);
        -:  215:  }
        1:  216:  transparent_crc(g_44.f0, "g_44.f0", print_hash_value);
        1:  217:  transparent_crc(g_60.f0, "g_60.f0", print_hash_value);
        1:  218:  transparent_crc(g_60.f1, "g_60.f1", print_hash_value);
        1:  219:  transparent_crc(g_60.f2, "g_60.f2", print_hash_value);
        1:  220:  transparent_crc(g_95, "g_95", print_hash_value);
        4:  221:  for (i = 0; i < 3; i++) {
        3:  222:    transparent_crc(g_98[i].f0, "g_98[i].f0", print_hash_value);
        3:  223:    if (print_hash_value)
    #####:  224:      printf("index = [%d]\n", i);
        -:  225:  }
        1:  226:  transparent_crc(g_114, "g_114", print_hash_value);
        1:  227:  transparent_crc(g_118, "g_118", print_hash_value);
        1:  228:  platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
        1:  229:  return 0;
        -:  230:}
