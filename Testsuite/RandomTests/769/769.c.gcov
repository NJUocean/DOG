        -:    0:Source:769.c
        -:    0:Graph:769.gcno
        -:    0:Data:769.gcda
        -:    0:Runs:1
        -:    1:// Options:   --concise --max-struct-fields 5 --max-funcs 2 --max-array-len-per-dim 5 --max-block-depth 3 --max-block-size 2
        -:    2:#include "csmith.h"
        -:    3:
        -:    4:static long __undefined;
        -:    5:
        -:    6:#pragma pack(push)
        -:    7:#pragma pack(1)
        -:    8:struct S1 {
        -:    9:  const unsigned f0 : 3;
        -:   10:  const unsigned f1 : 14;
        -:   11:  volatile signed f2 : 20;
        -:   12:};
        -:   13:#pragma pack(pop)
        -:   14:
        -:   15:#pragma pack(push)
        -:   16:#pragma pack(1)
        -:   17:struct S2 {
        -:   18:  volatile signed f0 : 16;
        -:   19:  signed f1 : 3;
        -:   20:  const struct S1 f2;
        -:   21:};
        -:   22:#pragma pack(pop)
        -:   23:
        -:   24:static int32_t g_3[5] = {1L, 1L, 1L, 1L, 1L};
        -:   25:static int32_t *g_5 = &g_3[3];
        -:   26:static int32_t **const volatile g_4 = &g_5;
        -:   27:static int32_t g_6 = 1L;
        -:   28:static volatile uint8_t g_30 = 0UL;
        -:   29:static uint64_t g_40 = 0x74D82229B2AB39D4LL;
        -:   30:static uint8_t g_51 = 255UL;
        -:   31:static uint8_t g_61[3][5] = {{0x1CL, 0xEDL, 1UL, 1UL, 0xEDL}, {0x1CL, 0xEDL, 1UL, 1UL, 0xEDL}, {0x1CL, 0xEDL, 1UL, 1UL, 0xEDL}};
        -:   32:static int32_t g_63 = 0x520E2919L;
        -:   33:static int64_t g_81 = 0xCE275991FC229ECFLL;
        -:   34:static int16_t g_82 = 0L;
        -:   35:static struct S2 g_85 = {-195, -1, {1, 17, -663}};
        -:   36:
        -:   37:static uint32_t func_1(void);
        -:   38:static uint64_t func_21(int32_t p_22);
        -:   39:
        1:   40:static uint32_t func_1(void) {
        -:   41:  int32_t *l_2[4][1];
        1:   42:  int32_t l_13[4][5][3] = {{{0x560131B3L, 0x560131B3L, 0x560131B3L}, {0xB9622CFBL, 0xB9622CFBL, 0xB9622CFBL}, {0x560131B3L, 0x560131B3L, 0x560131B3L}, {0xB9622CFBL, 0xB9622CFBL, 0xB9622CFBL}, {0x560131B3L, 0x560131B3L, 0x560131B3L}},
        -:   43:                           {{0xB9622CFBL, 0xB9622CFBL, 0xB9622CFBL}, {0x560131B3L, 0x560131B3L, 0x560131B3L}, {0xB9622CFBL, 0xB9622CFBL, 0xB9622CFBL}, {0x560131B3L, 0x560131B3L, 0x560131B3L}, {0xB9622CFBL, 0xB9622CFBL, 0xB9622CFBL}},
        -:   44:                           {{0x560131B3L, 0x560131B3L, 0x560131B3L}, {0xB9622CFBL, 0xB9622CFBL, 0xB9622CFBL}, {0x560131B3L, 0x560131B3L, 0x560131B3L}, {0xB9622CFBL, 0xB9622CFBL, 0xB9622CFBL}, {0x560131B3L, 0x560131B3L, 0x560131B3L}},
        -:   45:                           {{0xB9622CFBL, 0xB9622CFBL, 0xB9622CFBL}, {0x560131B3L, 0x560131B3L, 0x560131B3L}, {0xB9622CFBL, 0xB9622CFBL, 0xB9622CFBL}, {0x560131B3L, 0x560131B3L, 0x560131B3L}, {0xB9622CFBL, 0xB9622CFBL, 0xB9622CFBL}}};
        1:   46:  uint16_t l_14 = 8UL;
        1:   47:  int32_t *l_23 = &l_13[2][2][1];
        1:   48:  uint8_t l_103[4][1][4] = {{{252UL, 0x70L, 0x70L, 252UL}}, {{252UL, 0x70L, 0x70L, 252UL}}, {{252UL, 0x70L, 0x70L, 252UL}}, {{252UL, 0x70L, 0x70L, 252UL}}};
        -:   49:  int i, j, k;
        5:   50:  for (i = 0; i < 4; i++) {
        8:   51:    for (j = 0; j < 1; j++)
        4:   52:      l_2[i][j] = &g_3[4];
        -:   53:  }
        1:   54:  (*g_4) = l_2[0][0];
        2:   55:  for (g_6 = 0; (g_6 >= 0); g_6 -= 1) {
        1:   56:    int16_t l_7 = 3L;
        1:   57:    int32_t l_8 = 1L;
        1:   58:    int32_t l_9 = 5L;
        1:   59:    int32_t l_10 = 1L;
        1:   60:    int32_t l_11 = 2L;
        1:   61:    int32_t l_12[1][5] = {{1L, 1L, 1L, 1L, 1L}};
        -:   62:    int i, j;
        1:   63:    --l_14;
        2:   64:    for (l_10 = 0; (l_10 >= 0); l_10 -= 1) {
        1:   65:      int64_t *l_80 = &g_81;
        1:   66:      g_82 &= ((safe_rshift_func_int32_t_s_s((safe_mod_func_uint64_t_u_u(func_21(((g_3[4], (*g_4)) == l_23)), ((*l_80) = g_6))), 15)) & (-1L));
        -:   67:    }
        2:   68:    for (l_14 = 0; (l_14 <= 0); l_14 += 1) {
        1:   69:      int16_t l_88 = 0x5346L;
        1:   70:      uint8_t l_95 = 0x84L;
        1:   71:      int32_t l_106 = (-7L);
        2:   72:      for (l_9 = 0; (l_9 <= 0); l_9 += 1) {
        1:   73:        uint32_t l_98[4][1] = {{0xDCB58CEAL}, {0xFBDA8061L}, {0xDCB58CEAL}, {0xFBDA8061L}};
        -:   74:        int8_t *l_102[4][1];
        1:   75:        int32_t l_104 = 0L;
        1:   76:        const uint16_t l_105 = 65533UL;
        -:   77:        int i, j;
        5:   78:        for (i = 0; i < 4; i++) {
        8:   79:          for (j = 0; j < 1; j++)
        4:   80:            l_102[i][j] = (void *)0;
        -:   81:        }
       1*:   82:        l_106 |= (safe_add_func_int32_t_s_s((g_85, ((safe_rshift_func_uint16_t_u_u(l_88, 7)) == (safe_mul_func_int32_t_s_s(((*l_23) ^= (*g_5)), ((safe_lshift_func_uint64_t_u_u((safe_mul_func_uint8_t_u_u((((((8UL <= l_95) || 0x5176L) <= ((((safe_mul_func_int32_t_s_s((l_98[3][0] == (l_104 = (l_103[1][0][3] = (safe_lshift_func_uint8_t_u_s((+g_85.f0), 3))))), g_63)) < 1UL), g_85.f2.f1) > g_40)) < g_85.f1) | 4294967292UL), l_11)), l_105)) && 0xC283L))))), l_8));
        1:   83:        (*g_5) |= 0x674BCF40L;
        -:   84:      }
        -:   85:    }
        -:   86:  }
        1:   87:  return g_82;
        -:   88:}
        -:   89:
        1:   90:static uint64_t func_21(int32_t p_22) {
        1:   91:  uint8_t l_26 = 0x8EL;
        1:   92:  int32_t *l_33 = &g_6;
        1:   93:  uint16_t l_48 = 0xDEF2L;
        1:   94:  int32_t l_64 = (-2L);
        1:   95:  int32_t l_76[3][5] = {{0x6A653BE2L, 1L, 0x6A653BE2L, 1L, 0x6A653BE2L}, {0x5892074BL, 0x5892074BL, 0x5892074BL, 0x5892074BL, 0x5892074BL}, {0x6A653BE2L, 1L, 0x6A653BE2L, 1L, 0x6A653BE2L}};
        -:   96:  int i, j;
        1:   97:  if ((safe_mod_func_int16_t_s_s(l_26, p_22))) {
        1:   98:    uint16_t l_36 = 65533UL;
        1:   99:    uint32_t l_37[3][2] = {{0x2714BD48L, 0x5626A28EL}, {0x5626A28EL, 0x2714BD48L}, {0x5626A28EL, 0x5626A28EL}};
        1:  100:    uint64_t *l_38 = (void *)0;
        1:  101:    uint64_t *l_39 = &g_40;
        -:  102:    uint64_t l_66[1];
        -:  103:    int i, j;
        2:  104:    for (i = 0; i < 1; i++)
        1:  105:      l_66[i] = 0xD452736F9D8AEAC5LL;
       1*:  106:    (*g_5) = (((l_26, ((safe_mod_func_int16_t_s_s(p_22, ((!g_30) || ((safe_sub_func_uint64_t_u_u(l_26, ((*l_39) = (((void *)0 == l_33), (safe_add_func_uint64_t_u_u(((l_36 || (((*l_33) | 65526UL), l_37[1][0])) && 1UL), 0x432499CBC132C98CLL)))))), (*l_33))))) && p_22)) || g_3[1]) ^ (*l_33));
       1*:  107:    for (p_22 = (-5); (p_22 <= (-11)); --p_22) {
    #####:  108:      for (l_26 = (-13); (l_26 <= 19); ++l_26) {
    #####:  109:        uint8_t *l_49 = (void *)0;
    #####:  110:        uint8_t *l_50 = &g_51;
    #####:  111:        uint8_t *l_59 = (void *)0;
    #####:  112:        uint8_t *l_60 = &g_61[0][4];
    #####:  113:        int32_t *l_62 = &g_63;
    #####:  114:        int32_t *l_65 = &g_3[4];
    #####:  115:        (*l_62) ^= (((p_22 != (safe_mod_func_uint8_t_u_u((0x67D4ADD7L >= (~((*l_50) = (p_22 < l_48)))), ((*l_60) &= (((((safe_div_func_uint32_t_u_u((g_3[3] ^ (*l_33)), (safe_rshift_func_uint8_t_u_u(((!(((-1L) | g_3[4]) > (((safe_lshift_func_int32_t_s_s((((g_6, (void *)0) == &l_26) | 0xF6L), (**g_4))), 0UL) ^ p_22))) | 0UL), 4)))) != 6UL) <= g_3[3]) != (*g_5)) != (*g_5)))))), (void *)0) == &g_40);
    #####:  116:        l_66[0]++;
        -:  117:      }
    #####:  118:      (*g_5) |= 1L;
        -:  119:    }
        -:  120:  } else {
    #####:  121:    int32_t **l_69 = &g_5;
    #####:  122:    (*l_69) = (*g_4);
        -:  123:  }
        6:  124:  for (g_63 = (-22); (g_63 <= 21); g_63 = safe_add_func_int16_t_s_s(g_63, 9)) {
        5:  125:    int32_t *l_72 = &g_3[4];
        5:  126:    int32_t *l_73 = &g_3[4];
        5:  127:    int32_t *l_74 = &l_64;
        5:  128:    int32_t *l_75[5] = {&g_3[1], &g_3[1], &g_3[1], &g_3[1], &g_3[1]};
        5:  129:    uint16_t l_77 = 65531UL;
        -:  130:    int i;
        5:  131:    l_77++;
        -:  132:  }
        1:  133:  return p_22;
        -:  134:}
        -:  135:
        1:  136:int main(int argc, char *argv[]) {
        -:  137:  int i, j;
        1:  138:  int print_hash_value = 0;
       1*:  139:  if (argc == 2 && strcmp(argv[1], "1") == 0)
    #####:  140:    print_hash_value = 1;
        1:  141:  platform_main_begin();
        1:  142:  crc32_gentab();
        1:  143:  func_1();
        6:  144:  for (i = 0; i < 5; i++) {
        5:  145:    transparent_crc(g_3[i], "g_3[i]", print_hash_value);
        5:  146:    if (print_hash_value)
    #####:  147:      printf("index = [%d]\n", i);
        -:  148:  }
        1:  149:  transparent_crc(g_6, "g_6", print_hash_value);
        1:  150:  transparent_crc(g_30, "g_30", print_hash_value);
        1:  151:  transparent_crc(g_40, "g_40", print_hash_value);
        1:  152:  transparent_crc(g_51, "g_51", print_hash_value);
        4:  153:  for (i = 0; i < 3; i++) {
       18:  154:    for (j = 0; j < 5; j++) {
       15:  155:      transparent_crc(g_61[i][j], "g_61[i][j]", print_hash_value);
       15:  156:      if (print_hash_value)
    #####:  157:        printf("index = [%d][%d]\n", i, j);
        -:  158:    }
        -:  159:  }
        1:  160:  transparent_crc(g_63, "g_63", print_hash_value);
        1:  161:  transparent_crc(g_81, "g_81", print_hash_value);
        1:  162:  transparent_crc(g_82, "g_82", print_hash_value);
        1:  163:  transparent_crc(g_85.f0, "g_85.f0", print_hash_value);
        1:  164:  transparent_crc(g_85.f1, "g_85.f1", print_hash_value);
        1:  165:  transparent_crc(g_85.f2.f0, "g_85.f2.f0", print_hash_value);
        1:  166:  transparent_crc(g_85.f2.f1, "g_85.f2.f1", print_hash_value);
        1:  167:  transparent_crc(g_85.f2.f2, "g_85.f2.f2", print_hash_value);
        1:  168:  platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
        1:  169:  return 0;
        -:  170:}
