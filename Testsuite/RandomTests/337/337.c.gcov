        -:    0:Source:337.c
        -:    0:Graph:337.gcno
        -:    0:Data:337.gcda
        -:    0:Runs:1
        -:    1:// Options:   --concise --max-struct-fields 5 --max-funcs 2 --max-array-len-per-dim 5 --max-block-depth 3 --max-block-size 2
        -:    2:#include "csmith.h"
        -:    3:
        -:    4:static long __undefined;
        -:    5:
        -:    6:struct S1 {
        -:    7:  unsigned f0 : 21;
        -:    8:  const unsigned f1 : 3;
        -:    9:  const unsigned f2 : 14;
        -:   10:};
        -:   11:
        -:   12:union U2 {
        -:   13:  volatile int32_t f0;
        -:   14:  const volatile uint16_t f1;
        -:   15:  uint32_t f2;
        -:   16:  uint32_t f3;
        -:   17:  int32_t f4;
        -:   18:};
        -:   19:
        -:   20:union U3 {
        -:   21:  uint32_t f0;
        -:   22:  int32_t f1;
        -:   23:  uint32_t f2;
        -:   24:  uint32_t f3;
        -:   25:  uint16_t f4;
        -:   26:};
        -:   27:
        -:   28:static int32_t g_6[1] = {0x7747BB7AL};
        -:   29:static union U3 g_24 = {0xE3B00B72L};
        -:   30:static int32_t *g_27 = &g_6[0];
        -:   31:static uint64_t g_36 = 0x3978D11E8E103CA5LL;
        -:   32:static volatile union U2 g_41 = {-2L};
        -:   33:static int32_t ***volatile g_53 = (void *)0;
        -:   34:static int32_t *volatile g_55 = (void *)0;
        -:   35:static int32_t *volatile g_56 = &g_6[0];
        -:   36:static struct S1 g_57 = {448, 1, 21};
        -:   37:
        -:   38:static struct S1 func_1(void);
        -:   39:static int32_t func_19(union U3 p_20, const int32_t *p_21, int32_t *p_22, int32_t *p_23);
        -:   40:
        1:   41:static struct S1 func_1(void) {
        1:   42:  int64_t l_2 = 0x3244D513C61C71BCLL;
        1:   43:  int32_t l_13[4] = {0x9973063DL, 0x9973063DL, 0x9973063DL, 0x9973063DL};
        1:   44:  const int32_t *l_26 = (void *)0;
        -:   45:  int i;
        1:   46:  if (l_2) {
        1:   47:    int32_t *l_7 = &g_6[0];
        -:   48:    int32_t l_8[1][2];
        1:   49:    int32_t *l_9 = (void *)0;
        1:   50:    int32_t *l_10 = (void *)0;
        1:   51:    int32_t *l_11 = (void *)0;
        1:   52:    int32_t *l_12[4] = {&g_6[0], &g_6[0], &g_6[0], &g_6[0]};
        -:   53:    uint64_t l_14[1][5];
        -:   54:    int i, j;
        2:   55:    for (i = 0; i < 1; i++) {
        3:   56:      for (j = 0; j < 2; j++)
        2:   57:        l_8[i][j] = 0x9DADE661L;
        -:   58:    }
        2:   59:    for (i = 0; i < 1; i++) {
        6:   60:      for (j = 0; j < 5; j++)
        5:   61:        l_14[i][j] = 0x260E2EFE8E60A2FCLL;
        -:   62:    }
       1*:   63:    for (l_2 = 0; (l_2 < (-21)); l_2--) {
    #####:   64:      int32_t *l_5 = &g_6[0];
    #####:   65:      (*l_5) &= 0x07182B47L;
        -:   66:    }
        1:   67:    ++l_14[0][3];
        -:   68:  } else {
    #####:   69:    const int32_t *l_25 = &g_6[0];
    #####:   70:    for (l_2 = 23; (l_2 == 5); l_2--) {
    #####:   71:      int32_t *l_54 = &l_13[2];
    #####:   72:      (*g_56) = ((*l_54) = func_19(g_24, (l_26 = l_25), g_27, &l_13[2]));
        -:   73:    }
        -:   74:  }
        1:   75:  return g_57;
        -:   76:}
        -:   77:
    #####:   78:static int32_t func_19(union U3 p_20, const int32_t *p_21, int32_t *p_22, int32_t *p_23) {
    #####:   79:  int32_t *l_43 = &g_6[0];
    #####:   80:  int32_t l_52 = 0xE5EB906AL;
    #####:   81:  (*g_27) = 0L;
    #####:   82:  for (p_20.f1 = (-10); (p_20.f1 >= (-13)); p_20.f1 = safe_sub_func_int16_t_s_s(p_20.f1, 6)) {
    #####:   83:    int32_t **l_34 = &g_27;
    #####:   84:    uint64_t *l_35 = &g_36;
        -:   85:    const struct S1 l_45 = {1327, 0, 73};
    #####:   86:    if ((p_20.f1 == ((safe_add_func_uint8_t_u_u(0x64L, (safe_add_func_int64_t_s_s((&g_6[0] == ((*l_34) = p_23)), ((*l_35) = g_24.f0))))) ^ (safe_mod_func_int16_t_s_s(((safe_sub_func_uint64_t_u_u((g_41, p_20.f1), ((~(((*p_23) |= 0x552F0C8CL) && (l_43 == p_22))) || (-5L)))) >= g_24.f0), p_20.f1))))) {
    #####:   87:      uint32_t l_48 = 0UL;
    #####:   88:      int32_t l_51 = 0x2B2C9D53L;
    #####:   89:      if ((*g_27))
    #####:   90:        break;
    #####:   91:      l_52 &= ((*g_27) = ((g_6[0] > (((void *)0 == &g_27) || (~((((p_20, (*g_27)) || ((((-1L) <= (l_45, ((((safe_mul_func_int8_t_s_s((((l_48 && (safe_sub_func_uint8_t_u_u(((*g_27) && l_51), 0xC5L))) > g_24.f0) < p_20.f1), g_6[0])) & 0xFB9E2BF2DCFCB68BLL) < p_20.f1) != 0xDB6CL))) ^ (-1L)) & (*p_22))) || 0x43C5L) && g_36)))) ^ (*p_23)));
        -:   92:    } else {
    #####:   93:      l_34 = &p_22;
    #####:   94:      return (*p_23);
        -:   95:    }
        -:   96:  }
    #####:   97:  return (*g_27);
        -:   98:}
        -:   99:
        1:  100:int main(int argc, char *argv[]) {
        -:  101:  int i;
        1:  102:  int print_hash_value = 0;
       1*:  103:  if (argc == 2 && strcmp(argv[1], "1") == 0)
    #####:  104:    print_hash_value = 1;
        1:  105:  platform_main_begin();
        1:  106:  crc32_gentab();
        1:  107:  func_1();
        2:  108:  for (i = 0; i < 1; i++) {
        1:  109:    transparent_crc(g_6[i], "g_6[i]", print_hash_value);
        1:  110:    if (print_hash_value)
    #####:  111:      printf("index = [%d]\n", i);
        -:  112:  }
        1:  113:  transparent_crc(g_24.f0, "g_24.f0", print_hash_value);
        1:  114:  transparent_crc(g_36, "g_36", print_hash_value);
        1:  115:  transparent_crc(g_41.f0, "g_41.f0", print_hash_value);
        1:  116:  transparent_crc(g_57.f0, "g_57.f0", print_hash_value);
        1:  117:  transparent_crc(g_57.f1, "g_57.f1", print_hash_value);
        1:  118:  transparent_crc(g_57.f2, "g_57.f2", print_hash_value);
        1:  119:  platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
        1:  120:  return 0;
        -:  121:}
