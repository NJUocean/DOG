        -:    0:Source:282.c
        -:    0:Graph:282.gcno
        -:    0:Data:282.gcda
        -:    0:Runs:1
        -:    1:// Options:   --concise --max-struct-fields 5 --max-funcs 2 --max-array-len-per-dim 5 --max-block-depth 3 --max-block-size 2
        -:    2:#include "csmith.h"
        -:    3:
        -:    4:static long __undefined;
        -:    5:
        -:    6:struct S0 {
        -:    7:  unsigned f0 : 13;
        -:    8:  unsigned f1 : 14;
        -:    9:};
        -:   10:
        -:   11:union U1 {
        -:   12:  unsigned f0 : 9;
        -:   13:};
        -:   14:
        -:   15:union U2 {
        -:   16:  volatile unsigned f0 : 16;
        -:   17:  uint32_t f1;
        -:   18:  int64_t f2;
        -:   19:  const int32_t f3;
        -:   20:};
        -:   21:
        -:   22:static int32_t *volatile g_3 = (void *)0;
        -:   23:static int32_t g_5 = 0xE8588D0DL;
        -:   24:static struct S0 g_13[2] = {{1, 79}, {1, 79}};
        -:   25:static volatile union U1 g_14 = {0UL};
        -:   26:static volatile int32_t g_17 = 0x8B012130L;
        -:   27:static volatile int32_t *volatile g_16 = &g_17;
        -:   28:static int32_t *volatile g_21[5] = {(void *)0, (void *)0, (void *)0, (void *)0, (void *)0};
        -:   29:static int32_t *volatile g_22 = &g_5;
        -:   30:static union U2 g_23 = {1UL};
        -:   31:static int32_t *g_28 = (void *)0;
        -:   32:static int32_t **volatile g_27 = &g_28;
        -:   33:static uint8_t g_62 = 0x62L;
        -:   34:static uint16_t g_65 = 0UL;
        -:   35:static struct S0 *g_69 = &g_13[0];
        -:   36:static struct S0 *volatile g_73[4][4] = {{&g_13[1], &g_13[1], &g_13[1], &g_13[1]}, {&g_13[1], &g_13[1], &g_13[1], &g_13[1]}, {&g_13[1], &g_13[1], &g_13[1], &g_13[1]}, {&g_13[1], &g_13[1], &g_13[1], &g_13[1]}};
        -:   37:static struct S0 *volatile g_74 = (void *)0;
        -:   38:
        -:   39:static uint8_t func_1(void);
        -:   40:static struct S0 func_8(uint32_t p_9);
        -:   41:
        1:   42:static uint8_t func_1(void) {
        1:   43:  int8_t l_2 = (-1L);
        -:   44:  int32_t *l_4[3];
        -:   45:  int i;
        4:   46:  for (i = 0; i < 3; i++)
        3:   47:    l_4[i] = &g_5;
        1:   48:  g_5 |= l_2;
       1*:   49:  for (l_2 = 0; (l_2 == (-26)); l_2--) {
        -:   50:    int32_t *l_15[4];
    #####:   51:    struct S0 *l_75 = &g_13[1];
        -:   52:    int i;
    #####:   53:    for (i = 0; i < 4; i++)
    #####:   54:      l_15[i] = (void *)0;
    #####:   55:    (*l_75) = func_8(((g_5 <= ((((!0UL), (g_13[1], g_14)), &g_5) == l_15[1])) != ((void *)0 == l_4[2])));
    #####:   56:    for (g_65 = (-6); (g_65 < 41); g_65 = safe_add_func_int32_t_s_s(g_65, 4)) {
    #####:   57:      int64_t l_80 = 0xCD7C5103452746A0LL;
        -:   58:      int32_t l_81[1][5][2];
        -:   59:      int i, j, k;
    #####:   60:      for (i = 0; i < 1; i++) {
    #####:   61:        for (j = 0; j < 5; j++) {
    #####:   62:          for (k = 0; k < 2; k++)
    #####:   63:            l_81[i][j][k] = 0x967D4ADDL;
        -:   64:        }
        -:   65:      }
    #####:   66:      for (g_5 = 7; (g_5 >= (-13)); g_5--) {
    #####:   67:        l_81[0][3][1] &= l_80;
        -:   68:      }
        -:   69:    }
        -:   70:  }
        1:   71:  return g_23.f0;
        -:   72:}
        -:   73:
    #####:   74:static struct S0 func_8(uint32_t p_9) {
        -:   75:  int16_t l_32[3][1][5];
    #####:   76:  int32_t l_38 = 6L;
    #####:   77:  int32_t l_39 = 0x1B3B3333L;
    #####:   78:  int32_t l_40[3][3][1] = {{{0x4B440417L}, {0x92F9E84EL}, {0x4B440417L}}, {{0x92F9E84EL}, {0x4B440417L}, {0x92F9E84EL}}, {{0x4B440417L}, {0x92F9E84EL}, {0x4B440417L}}};
    #####:   79:  uint64_t l_46 = 18446744073709551608UL;
    #####:   80:  int32_t l_66 = 6L;
    #####:   81:  struct S0 l_72 = {85, 21};
        -:   82:  int i, j, k;
    #####:   83:  for (i = 0; i < 3; i++) {
    #####:   84:    for (j = 0; j < 1; j++) {
    #####:   85:      for (k = 0; k < 5; k++)
    #####:   86:        l_32[i][j][k] = 0xE2EFL;
        -:   87:    }
        -:   88:  }
    #####:   89:  (*g_16) = g_14.f0;
    #####:   90:  for (p_9 = 0; (p_9 <= 27); ++p_9) {
    #####:   91:    int32_t l_20 = (-1L);
    #####:   92:    int32_t l_41 = (-1L);
    #####:   93:    int32_t l_42 = (-1L);
    #####:   94:    int32_t l_43 = 0L;
    #####:   95:    int32_t l_44 = 1L;
    #####:   96:    int32_t **l_51 = &g_28;
    #####:   97:    const struct S0 *l_70 = &g_13[0];
    #####:   98:    (*g_22) = l_20;
    #####:   99:    if (((g_23, p_9), (!(g_13[1].f0, (l_20 <= g_13[1].f1))))) {
    #####:  100:      int8_t l_30 = 6L;
    #####:  101:      int32_t *l_31 = &g_5;
    #####:  102:      int32_t *l_33 = &g_5;
    #####:  103:      int32_t *l_34 = &g_5;
    #####:  104:      int32_t *l_35 = &g_5;
    #####:  105:      int32_t *l_36 = &g_5;
        -:  106:      int32_t *l_37[1];
        -:  107:      int32_t l_45[3][4];
        -:  108:      int i, j;
    #####:  109:      for (i = 0; i < 1; i++)
    #####:  110:        l_37[i] = (void *)0;
    #####:  111:      for (i = 0; i < 3; i++) {
    #####:  112:        for (j = 0; j < 4; j++)
    #####:  113:          l_45[i][j] = 0xE9AD3EE7L;
        -:  114:      }
    #####:  115:      for (l_20 = (-9); (l_20 <= 21); ++l_20) {
    #####:  116:        struct S0 *l_29 = &g_13[1];
    #####:  117:        (*g_27) = &g_5;
    #####:  118:        (*l_29) = g_13[1];
        -:  119:      }
    #####:  120:      l_46--;
        -:  121:    } else {
    #####:  122:      uint64_t l_52[2][1][5] = {{{18446744073709551606UL, 7UL, 7UL, 18446744073709551606UL, 7UL}}, {{18446744073709551606UL, 18446744073709551606UL, 18446744073709551613UL, 18446744073709551606UL, 18446744073709551606UL}}};
    #####:  123:      int32_t l_57 = 0x0091F4D9L;
    #####:  124:      uint8_t *l_61[2][4][4] = {{{(void *)0, &g_62, &g_62, (void *)0}, {&g_62, &g_62, &g_62, &g_62}, {&g_62, &g_62, &g_62, &g_62}, {&g_62, &g_62, &g_62, &g_62}}, {{(void *)0, &g_62, &g_62, &g_62}, {&g_62, &g_62, &g_62, &g_62}, {&g_62, (void *)0, &g_62, &g_62}, {&g_62, &g_62, &g_62, &g_62}}};
    #####:  125:      struct S0 *l_67 = &g_13[1];
    #####:  126:      struct S0 **l_68[4][2] = {{&l_67, &l_67}, {&l_67, &l_67}, {&l_67, &l_67}, {&l_67, &l_67}};
    #####:  127:      int32_t *l_71 = &l_38;
        -:  128:      int i, j, k;
    #####:  129:      (*l_71) &= ((safe_mod_func_int16_t_s_s((l_51 != &g_3), (l_52[0][0][4] |= l_46))) < ((g_69 = ((safe_div_func_uint8_t_u_u((safe_add_func_uint64_t_u_u((l_57 | (((safe_rshift_func_int32_t_s_s(((g_62 ^= (!0xB1ADF13F3F2C75BCLL)) > ((safe_add_func_int64_t_s_s((g_65 = (g_13[1].f0 < p_9)), g_5)), (g_5 || p_9))), (*g_16))) >= g_13[1].f1) ^ 0xA51C30C3L)), g_5)), l_66)), l_67)) == l_70));
        -:  130:    }
        -:  131:  }
    #####:  132:  return l_72;
        -:  133:}
        -:  134:
        1:  135:int main(int argc, char *argv[]) {
        -:  136:  int i, j;
        1:  137:  int print_hash_value = 0;
       1*:  138:  if (argc == 2 && strcmp(argv[1], "1") == 0)
    #####:  139:    print_hash_value = 1;
        1:  140:  platform_main_begin();
        1:  141:  crc32_gentab();
        1:  142:  func_1();
        1:  143:  transparent_crc(g_5, "g_5", print_hash_value);
        3:  144:  for (i = 0; i < 2; i++) {
        2:  145:    transparent_crc(g_13[i].f0, "g_13[i].f0", print_hash_value);
        2:  146:    transparent_crc(g_13[i].f1, "g_13[i].f1", print_hash_value);
        2:  147:    if (print_hash_value)
    #####:  148:      printf("index = [%d]\n", i);
        -:  149:  }
        1:  150:  transparent_crc(g_14.f0, "g_14.f0", print_hash_value);
        1:  151:  transparent_crc(g_17, "g_17", print_hash_value);
        1:  152:  transparent_crc(g_23.f0, "g_23.f0", print_hash_value);
        1:  153:  transparent_crc(g_62, "g_62", print_hash_value);
        1:  154:  transparent_crc(g_65, "g_65", print_hash_value);
        1:  155:  platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
        1:  156:  return 0;
        -:  157:}
