// Options:   --concise --max-struct-fields 5 --max-funcs 2 --max-array-len-per-dim 5 --max-block-depth 3 --max-block-size 2
#include "csmith.h"

static long __undefined;

struct S0 {
  unsigned f0 : 13;
  unsigned f1 : 14;
};

union U1 {
  unsigned f0 : 9;
};

union U2 {
  volatile unsigned f0 : 16;
  uint32_t f1;
  int64_t f2;
  const int32_t f3;
};

static int32_t *volatile g_3 = (void *)0;
static int32_t g_5 = 0xE8588D0DL;
static struct S0 g_13[2] = {{1, 79}, {1, 79}};
static volatile union U1 g_14 = {0UL};
static volatile int32_t g_17 = 0x8B012130L;
static volatile int32_t *volatile g_16 = &g_17;
static int32_t *volatile g_21[5] = {(void *)0, (void *)0, (void *)0, (void *)0, (void *)0};
static int32_t *volatile g_22 = &g_5;
static union U2 g_23 = {1UL};
static int32_t *g_28 = (void *)0;
static int32_t **volatile g_27 = &g_28;
static uint8_t g_62 = 0x62L;
static uint16_t g_65 = 0UL;
static struct S0 *g_69 = &g_13[0];
static struct S0 *volatile g_73[4][4] = {{&g_13[1], &g_13[1], &g_13[1], &g_13[1]}, {&g_13[1], &g_13[1], &g_13[1], &g_13[1]}, {&g_13[1], &g_13[1], &g_13[1], &g_13[1]}, {&g_13[1], &g_13[1], &g_13[1], &g_13[1]}};
static struct S0 *volatile g_74 = (void *)0;

static uint8_t func_1(void);
static struct S0 func_8(uint32_t p_9);

static uint8_t func_1(void) {
  int8_t l_2 = (-1L);
  int32_t *l_4[3];
  int i;
  for (i = 0; i < 3; i++)
    l_4[i] = &g_5;
  g_5 |= l_2;
  for (l_2 = 0; (l_2 == (-26)); l_2--) {
    int32_t *l_15[4];
    struct S0 *l_75 = &g_13[1];
    int i;
    for (i = 0; i < 4; i++)
      l_15[i] = (void *)0;
    (*l_75) = func_8(((g_5 <= ((((!0UL), (g_13[1], g_14)), &g_5) == l_15[1])) != ((void *)0 == l_4[2])));
    for (g_65 = (-6); (g_65 < 41); g_65 = safe_add_func_int32_t_s_s(g_65, 4)) {
      int64_t l_80 = 0xCD7C5103452746A0LL;
      int32_t l_81[1][5][2];
      int i, j, k;
      for (i = 0; i < 1; i++) {
        for (j = 0; j < 5; j++) {
          for (k = 0; k < 2; k++)
            l_81[i][j][k] = 0x967D4ADDL;
        }
      }
      for (g_5 = 7; (g_5 >= (-13)); g_5--) {
        l_81[0][3][1] &= l_80;
      }
    }
  }
  return g_23.f0;
}

static struct S0 func_8(uint32_t p_9) {
  int16_t l_32[3][1][5];
  int32_t l_38 = 6L;
  int32_t l_39 = 0x1B3B3333L;
  int32_t l_40[3][3][1] = {{{0x4B440417L}, {0x92F9E84EL}, {0x4B440417L}}, {{0x92F9E84EL}, {0x4B440417L}, {0x92F9E84EL}}, {{0x4B440417L}, {0x92F9E84EL}, {0x4B440417L}}};
  uint64_t l_46 = 18446744073709551608UL;
  int32_t l_66 = 6L;
  struct S0 l_72 = {85, 21};
  int i, j, k;
  for (i = 0; i < 3; i++) {
    for (j = 0; j < 1; j++) {
      for (k = 0; k < 5; k++)
        l_32[i][j][k] = 0xE2EFL;
    }
  }
  (*g_16) = g_14.f0;
  for (p_9 = 0; (p_9 <= 27); ++p_9) {
    int32_t l_20 = (-1L);
    int32_t l_41 = (-1L);
    int32_t l_42 = (-1L);
    int32_t l_43 = 0L;
    int32_t l_44 = 1L;
    int32_t **l_51 = &g_28;
    const struct S0 *l_70 = &g_13[0];
    (*g_22) = l_20;
    if (((g_23, p_9), (!(g_13[1].f0, (l_20 <= g_13[1].f1))))) {
      int8_t l_30 = 6L;
      int32_t *l_31 = &g_5;
      int32_t *l_33 = &g_5;
      int32_t *l_34 = &g_5;
      int32_t *l_35 = &g_5;
      int32_t *l_36 = &g_5;
      int32_t *l_37[1];
      int32_t l_45[3][4];
      int i, j;
      for (i = 0; i < 1; i++)
        l_37[i] = (void *)0;
      for (i = 0; i < 3; i++) {
        for (j = 0; j < 4; j++)
          l_45[i][j] = 0xE9AD3EE7L;
      }
      for (l_20 = (-9); (l_20 <= 21); ++l_20) {
        struct S0 *l_29 = &g_13[1];
        (*g_27) = &g_5;
        (*l_29) = g_13[1];
      }
      l_46--;
    } else {
      uint64_t l_52[2][1][5] = {{{18446744073709551606UL, 7UL, 7UL, 18446744073709551606UL, 7UL}}, {{18446744073709551606UL, 18446744073709551606UL, 18446744073709551613UL, 18446744073709551606UL, 18446744073709551606UL}}};
      int32_t l_57 = 0x0091F4D9L;
      uint8_t *l_61[2][4][4] = {{{(void *)0, &g_62, &g_62, (void *)0}, {&g_62, &g_62, &g_62, &g_62}, {&g_62, &g_62, &g_62, &g_62}, {&g_62, &g_62, &g_62, &g_62}}, {{(void *)0, &g_62, &g_62, &g_62}, {&g_62, &g_62, &g_62, &g_62}, {&g_62, (void *)0, &g_62, &g_62}, {&g_62, &g_62, &g_62, &g_62}}};
      struct S0 *l_67 = &g_13[1];
      struct S0 **l_68[4][2] = {{&l_67, &l_67}, {&l_67, &l_67}, {&l_67, &l_67}, {&l_67, &l_67}};
      int32_t *l_71 = &l_38;
      int i, j, k;
      (*l_71) &= ((safe_mod_func_int16_t_s_s((l_51 != &g_3), (l_52[0][0][4] |= l_46))) < ((g_69 = ((safe_div_func_uint8_t_u_u((safe_add_func_uint64_t_u_u((l_57 | (((safe_rshift_func_int32_t_s_s(((g_62 ^= (!0xB1ADF13F3F2C75BCLL)) > ((safe_add_func_int64_t_s_s((g_65 = (g_13[1].f0 < p_9)), g_5)), (g_5 || p_9))), (*g_16))) >= g_13[1].f1) ^ 0xA51C30C3L)), g_5)), l_66)), l_67)) == l_70));
    }
  }
  return l_72;
}

int main(int argc, char *argv[]) {
  int i, j;
  int print_hash_value = 0;
  if (argc == 2 && strcmp(argv[1], "1") == 0)
    print_hash_value = 1;
  platform_main_begin();
  crc32_gentab();
  func_1();
  transparent_crc(g_5, "g_5", print_hash_value);
  for (i = 0; i < 2; i++) {
    transparent_crc(g_13[i].f0, "g_13[i].f0", print_hash_value);
    transparent_crc(g_13[i].f1, "g_13[i].f1", print_hash_value);
    if (print_hash_value)
      printf("index = [%d]\n", i);
  }
  transparent_crc(g_14.f0, "g_14.f0", print_hash_value);
  transparent_crc(g_17, "g_17", print_hash_value);
  transparent_crc(g_23.f0, "g_23.f0", print_hash_value);
  transparent_crc(g_62, "g_62", print_hash_value);
  transparent_crc(g_65, "g_65", print_hash_value);
  platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
  return 0;
}
