// Options:   --concise --max-struct-fields 5 --max-funcs 2 --max-array-len-per-dim 5 --max-block-depth 3 --max-block-size 2
#include "csmith.h"

static long __undefined;

#pragma pack(push)
#pragma pack(1)
struct S0 {
  uint16_t f0;
  volatile signed f1 : 5;
  uint64_t f2;
  const int32_t f3;
};
#pragma pack(pop)

union U1 {
  uint16_t f0;
  const int8_t f1;
  int32_t f2;
  volatile uint64_t f3;
  const uint32_t f4;
};

static int32_t g_12 = 1L;
static int16_t g_35[5] = {0x20F6L, 0x20F6L, 0x20F6L, 0x20F6L, 0x20F6L};
static int16_t g_37 = (-8L);
static volatile struct S0 g_43[3] = {{0xCB06L, 3, 1UL, 5L}, {0xCB06L, 3, 1UL, 5L}, {0xCB06L, 3, 1UL, 5L}};
static int64_t g_49 = 0xB6377F0A061FA46BLL;
static uint16_t g_51 = 0x6F1AL;
static uint16_t g_53 = 0x412FL;
static uint64_t g_55 = 0xBD61C064292628F0LL;
static uint8_t g_57 = 0x64L;
static volatile int32_t g_81 = (-9L);
static volatile int32_t *volatile g_80[2] = {&g_81, &g_81};
static volatile int32_t *volatile *g_79[5][2][4] = {{{&g_80[1], &g_80[1], &g_80[0], &g_80[1]}, {&g_80[1], &g_80[0], (void *)0, &g_80[1]}}, {{&g_80[0], &g_80[1], &g_80[0], (void *)0}, {&g_80[1], &g_80[1], &g_80[0], &g_80[1]}}, {{&g_80[1], &g_80[0], &g_80[0], &g_80[1]}, {&g_80[0], &g_80[1], &g_80[0], (void *)0}}, {{&g_80[1], &g_80[1], &g_80[0], &g_80[1]}, {&g_80[1], &g_80[0], &g_80[0], &g_80[1]}}, {{&g_80[0], &g_80[1], (void *)0, (void *)0}, {&g_80[0], &g_80[0], &g_80[1], &g_80[0]}}};
static volatile union U1 g_93 = {6UL};
static int32_t g_111 = 0x3782E33FL;
static int32_t *g_110 = &g_111;
static uint16_t *g_117 = (void *)0;
static uint16_t **volatile g_116 = &g_117;
static uint8_t g_129[2][5] = {{0xC0L, 0xC0L, 0xC0L, 0xC0L, 0xC0L}, {0x22L, 0x22L, 0x22L, 0x22L, 0x22L}};
static uint8_t g_130[5][3][2] = {{{0x52L, 255UL}, {0x37L, 255UL}, {0x52L, 0xCFL}}, {{0xCFL, 0x52L}, {255UL, 0x37L}, {255UL, 0x52L}}, {{0xCFL, 0xCFL}, {0x52L, 255UL}, {0x37L, 255UL}}, {{0x52L, 0xCFL}, {0xCFL, 0x52L}, {255UL, 0x37L}}, {{255UL, 0x52L}, {0xCFL, 0xCFL}, {0x52L, 255UL}}};
static volatile struct S0 *g_136 = &g_43[2];
static volatile struct S0 **volatile g_135 = &g_136;
static int32_t **volatile g_139 = &g_110;
static int32_t **volatile g_143 = &g_110;

static const int64_t func_1(void);
static int16_t func_17(uint64_t p_18);

static const int64_t func_1(void) {
  uint16_t l_2 = 0x9C4CL;
  int32_t *l_138 = &g_111;
  if (l_2) {
    uint32_t l_19 = 4294967287UL;
    int32_t l_120[2][5][2] = {{{0x567760C7L, 0x567760C7L}, {0x567760C7L, 0x567760C7L}, {0x567760C7L, 0x567760C7L}, {0x567760C7L, 0x567760C7L}, {0x567760C7L, 0x567760C7L}}, {{0x567760C7L, 0x567760C7L}, {0x567760C7L, 0x567760C7L}, {0x567760C7L, 0x567760C7L}, {0x567760C7L, 0x567760C7L}, {0x567760C7L, 0x567760C7L}}};
    uint8_t l_126[3];
    int i, j, k;
    for (i = 0; i < 3; i++)
      l_126[i] = 0xB7L;
    for (l_2 = 22; (l_2 <= 33); ++l_2) {
      uint16_t *l_119[5][3][3] = {{{&g_51, &g_51, (void *)0}, {&g_53, &l_2, &g_53}, {&g_53, &g_51, &l_2}}, {{&g_51, &g_53, &g_53}, {&l_2, &g_53, (void *)0}, {&g_51, &g_51, (void *)0}}, {{&l_2, &l_2, (void *)0}, {&g_51, &g_51, (void *)0}, {&g_53, &l_2, &g_53}}, {{&g_53, &g_51, &l_2}, {&g_51, &g_53, &g_53}, {&l_2, &g_53, (void *)0}}, {{&g_51, &g_51, (void *)0}, {&l_2, &l_2, (void *)0}, {&g_51, &g_51, (void *)0}}};
      uint8_t *l_128 = &g_129[0][4];
      int32_t l_131 = (-2L);
      int32_t l_132 = 0x739FF1EAL;
      int i, j, k;
      l_131 = (safe_sub_func_int32_t_s_s(1L, ((safe_mul_func_int16_t_s_s(((g_130[1][2][0] = (!(safe_div_func_int16_t_s_s((((*l_128) |= (g_12 || ((safe_add_func_uint64_t_u_u((safe_sub_func_uint32_t_u_u(((func_17(l_19) || ((g_51--) & (safe_mul_func_uint8_t_u_u(0xC9L, (+(*g_110)))))) <= l_126[2]), l_120[0][3][1])), (~g_111))) >= 1UL))), l_2), (-1L))))) < 0x907DL), 0L)) > l_126[2])));
      (*g_110) = l_132;
    }
  } else {
    for (g_55 = (-7); (g_55 != 58); g_55 = safe_add_func_int64_t_s_s(g_55, 5)) {
      const uint16_t l_137 = 0x62B8L;
      (*g_135) = &g_43[2];
      (*g_139) = (l_137, l_138);
    }
    for (g_57 = (-20); (g_57 == 26); g_57 = safe_add_func_uint8_t_u_u(g_57, 9)) {
      int32_t *l_142 = &g_111;
      (*g_143) = l_142;
    }
  }
  (*l_138) = (*g_110);
  return (*l_138);
}

static int16_t func_17(uint64_t p_18) {
  uint32_t l_20[4][3][5] = {{{4294967295UL, 1UL, 4294967295UL, 1UL, 4294967295UL}, {0xC5A3D7F1L, 0xC5A3D7F1L, 0xC5A3D7F1L, 0xC5A3D7F1L, 0xC5A3D7F1L}, {4294967295UL, 1UL, 4294967295UL, 1UL, 4294967295UL}}, {{0xC5A3D7F1L, 0xC5A3D7F1L, 0xC5A3D7F1L, 0xC5A3D7F1L, 0xC5A3D7F1L}, {4294967295UL, 1UL, 4294967295UL, 1UL, 4294967295UL}, {0xC5A3D7F1L, 0xC5A3D7F1L, 0xC5A3D7F1L, 0xC5A3D7F1L, 0xC5A3D7F1L}}, {{4294967295UL, 1UL, 4294967295UL, 1UL, 4294967295UL}, {0xC5A3D7F1L, 0xC5A3D7F1L, 0xC5A3D7F1L, 0xC5A3D7F1L, 0xC5A3D7F1L}, {4294967295UL, 1UL, 4294967295UL, 1UL, 4294967295UL}}, {{0xC5A3D7F1L, 0xC5A3D7F1L, 0xC5A3D7F1L, 0xC5A3D7F1L, 0xC5A3D7F1L}, {4294967295UL, 1UL, 4294967295UL, 1UL, 4294967295UL}, {0xC5A3D7F1L, 0xC5A3D7F1L, 0xC5A3D7F1L, 0xC5A3D7F1L, 0xC5A3D7F1L}}};
  int32_t l_60 = (-7L);
  uint16_t *l_65 = &g_51;
  uint16_t l_78 = 65534UL;
  int32_t **l_82[1];
  uint8_t *l_96 = &g_57;
  int64_t *l_103 = &g_49;
  int i, j, k;
  for (i = 0; i < 1; i++)
    l_82[i] = (void *)0;
  for (g_12 = 2; (g_12 >= 0); g_12 -= 1) {
    int32_t l_33[1];
    int16_t *l_34 = &g_35[0];
    int16_t *l_36 = &g_37;
    int64_t *l_48 = &g_49;
    uint16_t *l_50 = &g_51;
    uint16_t *l_52 = &g_53;
    uint64_t *l_54 = &g_55;
    uint8_t *l_56 = &g_57;
    int32_t l_58[1][3][1];
    uint32_t *l_59 = &l_20[0][0][1];
    uint8_t l_101 = 0xB3L;
    const int64_t *l_102 = &g_49;
    uint64_t l_104[2];
    int8_t *l_105 = (void *)0;
    int32_t l_106[3][3] = {{0L, 7L, 7L}, {0L, 7L, 7L}, {0L, 7L, 7L}};
    uint32_t l_112 = 0xD3BC2F6DL;
    int32_t l_115 = 0x1EF9C6BEL;
    int i, j, k;
    for (i = 0; i < 1; i++)
      l_33[i] = 0L;
    for (i = 0; i < 1; i++) {
      for (j = 0; j < 3; j++) {
        for (k = 0; k < 1; k++)
          l_58[i][j][k] = 0xBABA27FAL;
      }
    }
    for (i = 0; i < 2; i++)
      l_104[i] = 0xA3610563AB882180LL;
        if (((0xE7C1L != (((safe_lshift_func_uint8_t_u_s(((safe_rshift_func_int16_t_s_s(((safe_rshift_func_uint64_t_u_s((((((((*l_59) = ((safe_mul_func_uint32_t_u_u(((safe_mod_func_int32_t_s_s((((*l_56) ^= ((safe_mul_func_uint16_t_u_u((((*l_54) = (l_33[0] > (((((*l_52) = (((*l_36) |= ((*l_34) |= p_18)) == ((*l_50) ^= (((p_18 , (((safe_div_func_int8_t_s_s((((~((safe_sub_func_uint8_t_u_u((g_43[2] , (safe_add_func_uint8_t_u_u(g_12, (safe_sub_func_int64_t_s_s(g_12, ((*l_48) = 7L)))))), g_12)) > l_33[0])) > 0L) <= 65533UL), p_18)) , l_20[2][0][1]) | g_12)) ^ 5L) | l_33[0])))) < g_12) == 1UL) >= (-1L)))) , g_51), 0UL)) >= p_18)) > p_18), l_58[0][2][0])) & l_20[0][2][4]), 0x09EDB9CCL)) | l_33[0])) && 0x9633EF28L) >= l_60) , g_55) | g_12) & g_12), g_12)) & l_58[0][2][0]), 4)) | p_18), g_12)) , g_12) < (-5L))) ^ 0xFFEA361FL))
        {
          if (p_18)
            break;
        } else {
          int64_t l_83 = 0x00AFC62902D27084LL;
          for (l_60 = 2; (l_60 >= 0); l_60 -= 1) {
            int32_t *l_62 = &l_58[0][0][0];
            int32_t **l_61 = &l_62;
            (*l_61) = &l_60;
            if (g_55)
              break;
          }
          l_83 &= ((((safe_div_func_int32_t_s_s((((void *)0 != l_65) > (((l_20[1][0][4], (l_60 && (safe_lshift_func_int32_t_s_s(((safe_sub_func_int64_t_s_s(((l_58[0][2][0] ^= (safe_sub_func_uint64_t_u_u(((--(*l_56)) < (l_20[0][2][2] > (safe_sub_func_int32_t_s_s((safe_rshift_func_uint32_t_u_s(l_78, 2)), (g_79[2][0][0] == l_82[0]))))), (g_55 ^ 0xE774L)))) < g_43[2].f1), p_18)) == 0x6D0AL), 10)))), (void *)0) != l_82[0])), 0x19DC0990L)), p_18) >= g_55), 0L);
        }
  }
  for (g_49 = 0; g_49 < 4; g_49 += 1) {
    for (l_78 = 0; l_78 < 3; l_78 += 1) {
      for (g_93.f2 = 0; g_93.f2 < 5; g_93.f2 += 1) {
        l_20[g_49][l_78][g_93.f2] = 1UL;
      }
    }
  }
  return g_81;
}

int main(int argc, char *argv[]) {
  int i, j, k;
  int print_hash_value = 0;
  if (argc == 2 && strcmp(argv[1], "1") == 0)
    print_hash_value = 1;
  platform_main_begin();
  crc32_gentab();
  func_1();
  transparent_crc(g_12, "g_12", print_hash_value);
  for (i = 0; i < 5; i++) {
    transparent_crc(g_35[i], "g_35[i]", print_hash_value);
    if (print_hash_value)
      printf("index = [%d]\n", i);
  }
  transparent_crc(g_37, "g_37", print_hash_value);
  for (i = 0; i < 3; i++) {
    transparent_crc(g_43[i].f0, "g_43[i].f0", print_hash_value);
    transparent_crc(g_43[i].f1, "g_43[i].f1", print_hash_value);
    transparent_crc(g_43[i].f2, "g_43[i].f2", print_hash_value);
    transparent_crc(g_43[i].f3, "g_43[i].f3", print_hash_value);
    if (print_hash_value)
      printf("index = [%d]\n", i);
  }
  transparent_crc(g_49, "g_49", print_hash_value);
  transparent_crc(g_51, "g_51", print_hash_value);
  transparent_crc(g_53, "g_53", print_hash_value);
  transparent_crc(g_55, "g_55", print_hash_value);
  transparent_crc(g_57, "g_57", print_hash_value);
  transparent_crc(g_81, "g_81", print_hash_value);
  transparent_crc(g_93.f0, "g_93.f0", print_hash_value);
  transparent_crc(g_111, "g_111", print_hash_value);
  for (i = 0; i < 2; i++) {
    for (j = 0; j < 5; j++) {
      transparent_crc(g_129[i][j], "g_129[i][j]", print_hash_value);
      if (print_hash_value)
        printf("index = [%d][%d]\n", i, j);
    }
  }
  for (i = 0; i < 5; i++) {
    for (j = 0; j < 3; j++) {
      for (k = 0; k < 2; k++) {
        transparent_crc(g_130[i][j][k], "g_130[i][j][k]", print_hash_value);
        if (print_hash_value)
          printf("index = [%d][%d][%d]\n", i, j, k);
      }
    }
  }
  platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
  return 0;
}
