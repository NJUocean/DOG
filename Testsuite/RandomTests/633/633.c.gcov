        -:    0:Source:633.c
        -:    0:Graph:633.gcno
        -:    0:Data:633.gcda
        -:    0:Runs:1
        -:    1:// Options:   --concise --max-struct-fields 5 --max-funcs 2 --max-array-len-per-dim 5 --max-block-depth 3 --max-block-size 2
        -:    2:#include "csmith.h"
        -:    3:
        -:    4:static long __undefined;
        -:    5:
        -:    6:#pragma pack(push)
        -:    7:#pragma pack(1)
        -:    8:struct S0 {
        -:    9:  uint16_t f0;
        -:   10:  volatile signed f1 : 5;
        -:   11:  uint64_t f2;
        -:   12:  const int32_t f3;
        -:   13:};
        -:   14:#pragma pack(pop)
        -:   15:
        -:   16:union U1 {
        -:   17:  uint16_t f0;
        -:   18:  const int8_t f1;
        -:   19:  int32_t f2;
        -:   20:  volatile uint64_t f3;
        -:   21:  const uint32_t f4;
        -:   22:};
        -:   23:
        -:   24:static int32_t g_12 = 1L;
        -:   25:static int16_t g_35[5] = {0x20F6L, 0x20F6L, 0x20F6L, 0x20F6L, 0x20F6L};
        -:   26:static int16_t g_37 = (-8L);
        -:   27:static volatile struct S0 g_43[3] = {{0xCB06L, 3, 1UL, 5L}, {0xCB06L, 3, 1UL, 5L}, {0xCB06L, 3, 1UL, 5L}};
        -:   28:static int64_t g_49 = 0xB6377F0A061FA46BLL;
        -:   29:static uint16_t g_51 = 0x6F1AL;
        -:   30:static uint16_t g_53 = 0x412FL;
        -:   31:static uint64_t g_55 = 0xBD61C064292628F0LL;
        -:   32:static uint8_t g_57 = 0x64L;
        -:   33:static volatile int32_t g_81 = (-9L);
        -:   34:static volatile int32_t *volatile g_80[2] = {&g_81, &g_81};
        -:   35:static volatile int32_t *volatile *g_79[5][2][4] = {{{&g_80[1], &g_80[1], &g_80[0], &g_80[1]}, {&g_80[1], &g_80[0], (void *)0, &g_80[1]}}, {{&g_80[0], &g_80[1], &g_80[0], (void *)0}, {&g_80[1], &g_80[1], &g_80[0], &g_80[1]}}, {{&g_80[1], &g_80[0], &g_80[0], &g_80[1]}, {&g_80[0], &g_80[1], &g_80[0], (void *)0}}, {{&g_80[1], &g_80[1], &g_80[0], &g_80[1]}, {&g_80[1], &g_80[0], &g_80[0], &g_80[1]}}, {{&g_80[0], &g_80[1], (void *)0, (void *)0}, {&g_80[0], &g_80[0], &g_80[1], &g_80[0]}}};
        -:   36:static volatile union U1 g_93 = {6UL};
        -:   37:static int32_t g_111 = 0x3782E33FL;
        -:   38:static int32_t *g_110 = &g_111;
        -:   39:static uint16_t *g_117 = (void *)0;
        -:   40:static uint16_t **volatile g_116 = &g_117;
        -:   41:static uint8_t g_129[2][5] = {{0xC0L, 0xC0L, 0xC0L, 0xC0L, 0xC0L}, {0x22L, 0x22L, 0x22L, 0x22L, 0x22L}};
        -:   42:static uint8_t g_130[5][3][2] = {{{0x52L, 255UL}, {0x37L, 255UL}, {0x52L, 0xCFL}}, {{0xCFL, 0x52L}, {255UL, 0x37L}, {255UL, 0x52L}}, {{0xCFL, 0xCFL}, {0x52L, 255UL}, {0x37L, 255UL}}, {{0x52L, 0xCFL}, {0xCFL, 0x52L}, {255UL, 0x37L}}, {{255UL, 0x52L}, {0xCFL, 0xCFL}, {0x52L, 255UL}}};
        -:   43:static volatile struct S0 *g_136 = &g_43[2];
        -:   44:static volatile struct S0 **volatile g_135 = &g_136;
        -:   45:static int32_t **volatile g_139 = &g_110;
        -:   46:static int32_t **volatile g_143 = &g_110;
        -:   47:
        -:   48:static const int64_t func_1(void);
        -:   49:static int16_t func_17(uint64_t p_18);
        -:   50:
        1:   51:static const int64_t func_1(void) {
        1:   52:  uint16_t l_2 = 0x9C4CL;
        1:   53:  int32_t *l_138 = &g_111;
        1:   54:  if (l_2) {
        1:   55:    uint32_t l_19 = 4294967287UL;
        1:   56:    int32_t l_120[2][5][2] = {{{0x567760C7L, 0x567760C7L}, {0x567760C7L, 0x567760C7L}, {0x567760C7L, 0x567760C7L}, {0x567760C7L, 0x567760C7L}, {0x567760C7L, 0x567760C7L}}, {{0x567760C7L, 0x567760C7L}, {0x567760C7L, 0x567760C7L}, {0x567760C7L, 0x567760C7L}, {0x567760C7L, 0x567760C7L}, {0x567760C7L, 0x567760C7L}}};
        -:   57:    uint8_t l_126[3];
        -:   58:    int i, j, k;
        4:   59:    for (i = 0; i < 3; i++)
        3:   60:      l_126[i] = 0xB7L;
       13:   61:    for (l_2 = 22; (l_2 <= 33); ++l_2) {
       12:   62:      uint16_t *l_119[5][3][3] = {{{&g_51, &g_51, (void *)0}, {&g_53, &l_2, &g_53}, {&g_53, &g_51, &l_2}}, {{&g_51, &g_53, &g_53}, {&l_2, &g_53, (void *)0}, {&g_51, &g_51, (void *)0}}, {{&l_2, &l_2, (void *)0}, {&g_51, &g_51, (void *)0}, {&g_53, &l_2, &g_53}}, {{&g_53, &g_51, &l_2}, {&g_51, &g_53, &g_53}, {&l_2, &g_53, (void *)0}}, {{&g_51, &g_51, (void *)0}, {&l_2, &l_2, (void *)0}, {&g_51, &g_51, (void *)0}}};
       12:   63:      uint8_t *l_128 = &g_129[0][4];
       12:   64:      int32_t l_131 = (-2L);
       12:   65:      int32_t l_132 = 0x739FF1EAL;
        -:   66:      int i, j, k;
      12*:   67:      l_131 = (safe_sub_func_int32_t_s_s(1L, ((safe_mul_func_int16_t_s_s(((g_130[1][2][0] = (!(safe_div_func_int16_t_s_s((((*l_128) |= (g_12 || ((safe_add_func_uint64_t_u_u((safe_sub_func_uint32_t_u_u(((func_17(l_19) || ((g_51--) & (safe_mul_func_uint8_t_u_u(0xC9L, (+(*g_110)))))) <= l_126[2]), l_120[0][3][1])), (~g_111))) >= 1UL))), l_2), (-1L))))) < 0x907DL), 0L)) > l_126[2])));
       12:   68:      (*g_110) = l_132;
        -:   69:    }
        -:   70:  } else {
    #####:   71:    for (g_55 = (-7); (g_55 != 58); g_55 = safe_add_func_int64_t_s_s(g_55, 5)) {
    #####:   72:      const uint16_t l_137 = 0x62B8L;
    #####:   73:      (*g_135) = &g_43[2];
    #####:   74:      (*g_139) = (l_137, l_138);
        -:   75:    }
    #####:   76:    for (g_57 = (-20); (g_57 == 26); g_57 = safe_add_func_uint8_t_u_u(g_57, 9)) {
    #####:   77:      int32_t *l_142 = &g_111;
    #####:   78:      (*g_143) = l_142;
        -:   79:    }
        -:   80:  }
        1:   81:  (*l_138) = (*g_110);
        1:   82:  return (*l_138);
        -:   83:}
        -:   84:
    #####:   85:static int16_t func_17(uint64_t p_18) {
    #####:   86:  uint32_t l_20[4][3][5] = {{{4294967295UL, 1UL, 4294967295UL, 1UL, 4294967295UL}, {0xC5A3D7F1L, 0xC5A3D7F1L, 0xC5A3D7F1L, 0xC5A3D7F1L, 0xC5A3D7F1L}, {4294967295UL, 1UL, 4294967295UL, 1UL, 4294967295UL}}, {{0xC5A3D7F1L, 0xC5A3D7F1L, 0xC5A3D7F1L, 0xC5A3D7F1L, 0xC5A3D7F1L}, {4294967295UL, 1UL, 4294967295UL, 1UL, 4294967295UL}, {0xC5A3D7F1L, 0xC5A3D7F1L, 0xC5A3D7F1L, 0xC5A3D7F1L, 0xC5A3D7F1L}}, {{4294967295UL, 1UL, 4294967295UL, 1UL, 4294967295UL}, {0xC5A3D7F1L, 0xC5A3D7F1L, 0xC5A3D7F1L, 0xC5A3D7F1L, 0xC5A3D7F1L}, {4294967295UL, 1UL, 4294967295UL, 1UL, 4294967295UL}}, {{0xC5A3D7F1L, 0xC5A3D7F1L, 0xC5A3D7F1L, 0xC5A3D7F1L, 0xC5A3D7F1L}, {4294967295UL, 1UL, 4294967295UL, 1UL, 4294967295UL}, {0xC5A3D7F1L, 0xC5A3D7F1L, 0xC5A3D7F1L, 0xC5A3D7F1L, 0xC5A3D7F1L}}};
    #####:   87:  int32_t l_60 = (-7L);
    #####:   88:  uint16_t *l_65 = &g_51;
    #####:   89:  uint16_t l_78 = 65534UL;
        -:   90:  int32_t **l_82[1];
    #####:   91:  uint8_t *l_96 = &g_57;
    #####:   92:  int64_t *l_103 = &g_49;
        -:   93:  int i, j, k;
    #####:   94:  for (i = 0; i < 1; i++)
    #####:   95:    l_82[i] = (void *)0;
    #####:   96:  for (g_12 = 2; (g_12 >= 0); g_12 -= 1) {
        -:   97:    int32_t l_33[1];
    #####:   98:    int16_t *l_34 = &g_35[0];
    #####:   99:    int16_t *l_36 = &g_37;
    #####:  100:    int64_t *l_48 = &g_49;
    #####:  101:    uint16_t *l_50 = &g_51;
    #####:  102:    uint16_t *l_52 = &g_53;
    #####:  103:    uint64_t *l_54 = &g_55;
    #####:  104:    uint8_t *l_56 = &g_57;
        -:  105:    int32_t l_58[1][3][1];
    #####:  106:    uint32_t *l_59 = &l_20[0][0][1];
    #####:  107:    uint8_t l_101 = 0xB3L;
    #####:  108:    const int64_t *l_102 = &g_49;
        -:  109:    uint64_t l_104[2];
    #####:  110:    int8_t *l_105 = (void *)0;
    #####:  111:    int32_t l_106[3][3] = {{0L, 7L, 7L}, {0L, 7L, 7L}, {0L, 7L, 7L}};
    #####:  112:    uint32_t l_112 = 0xD3BC2F6DL;
    #####:  113:    int32_t l_115 = 0x1EF9C6BEL;
        -:  114:    int i, j, k;
    #####:  115:    for (i = 0; i < 1; i++)
    #####:  116:      l_33[i] = 0L;
    #####:  117:    for (i = 0; i < 1; i++) {
    #####:  118:      for (j = 0; j < 3; j++) {
    #####:  119:        for (k = 0; k < 1; k++)
    #####:  120:          l_58[i][j][k] = 0xBABA27FAL;
        -:  121:      }
        -:  122:    }
    #####:  123:    for (i = 0; i < 2; i++)
    #####:  124:      l_104[i] = 0xA3610563AB882180LL;
    #####:  125:        if (((0xE7C1L != (((safe_lshift_func_uint8_t_u_s(((safe_rshift_func_int16_t_s_s(((safe_rshift_func_uint64_t_u_s((((((((*l_59) = ((safe_mul_func_uint32_t_u_u(((safe_mod_func_int32_t_s_s((((*l_56) ^= ((safe_mul_func_uint16_t_u_u((((*l_54) = (l_33[0] > (((((*l_52) = (((*l_36) |= ((*l_34) |= p_18)) == ((*l_50) ^= (((p_18 , (((safe_div_func_int8_t_s_s((((~((safe_sub_func_uint8_t_u_u((g_43[2] , (safe_add_func_uint8_t_u_u(g_12, (safe_sub_func_int64_t_s_s(g_12, ((*l_48) = 7L)))))), g_12)) > l_33[0])) > 0L) <= 65533UL), p_18)) , l_20[2][0][1]) | g_12)) ^ 5L) | l_33[0])))) < g_12) == 1UL) >= (-1L)))) , g_51), 0UL)) >= p_18)) > p_18), l_58[0][2][0])) & l_20[0][2][4]), 0x09EDB9CCL)) | l_33[0])) && 0x9633EF28L) >= l_60) , g_55) | g_12) & g_12), g_12)) & l_58[0][2][0]), 4)) | p_18), g_12)) , g_12) < (-5L))) ^ 0xFFEA361FL))
        -:  126:        {
    #####:  127:          if (p_18)
    #####:  128:            break;
        -:  129:        } else {
        -:  130:          int64_t l_83 = 0x00AFC62902D27084LL;
        -:  131:          for (l_60 = 2; (l_60 >= 0); l_60 -= 1) {
        -:  132:            int32_t *l_62 = &l_58[0][0][0];
        -:  133:            int32_t **l_61 = &l_62;
        -:  134:            (*l_61) = &l_60;
        -:  135:            if (g_55)
        -:  136:              break;
        -:  137:          }
        -:  138:          l_83 &= ((((safe_div_func_int32_t_s_s((((void *)0 != l_65) > (((l_20[1][0][4], (l_60 && (safe_lshift_func_int32_t_s_s(((safe_sub_func_int64_t_s_s(((l_58[0][2][0] ^= (safe_sub_func_uint64_t_u_u(((--(*l_56)) < (l_20[0][2][2] > (safe_sub_func_int32_t_s_s((safe_rshift_func_uint32_t_u_s(l_78, 2)), (g_79[2][0][0] == l_82[0]))))), (g_55 ^ 0xE774L)))) < g_43[2].f1), p_18)) == 0x6D0AL), 10)))), (void *)0) != l_82[0])), 0x19DC0990L)), p_18) >= g_55), 0L);
        -:  139:        }
        -:  140:  }
    #####:  141:  for (g_49 = 0; g_49 < 4; g_49 += 1) {
    #####:  142:    for (l_78 = 0; l_78 < 3; l_78 += 1) {
    #####:  143:      for (g_93.f2 = 0; g_93.f2 < 5; g_93.f2 += 1) {
    #####:  144:        l_20[g_49][l_78][g_93.f2] = 1UL;
        -:  145:      }
        -:  146:    }
        -:  147:  }
    #####:  148:  return g_81;
        -:  149:}
        -:  150:
        1:  151:int main(int argc, char *argv[]) {
        -:  152:  int i, j, k;
        1:  153:  int print_hash_value = 0;
       1*:  154:  if (argc == 2 && strcmp(argv[1], "1") == 0)
    #####:  155:    print_hash_value = 1;
        1:  156:  platform_main_begin();
        1:  157:  crc32_gentab();
        1:  158:  func_1();
        1:  159:  transparent_crc(g_12, "g_12", print_hash_value);
        6:  160:  for (i = 0; i < 5; i++) {
        5:  161:    transparent_crc(g_35[i], "g_35[i]", print_hash_value);
        5:  162:    if (print_hash_value)
    #####:  163:      printf("index = [%d]\n", i);
        -:  164:  }
        1:  165:  transparent_crc(g_37, "g_37", print_hash_value);
        4:  166:  for (i = 0; i < 3; i++) {
        3:  167:    transparent_crc(g_43[i].f0, "g_43[i].f0", print_hash_value);
        3:  168:    transparent_crc(g_43[i].f1, "g_43[i].f1", print_hash_value);
        3:  169:    transparent_crc(g_43[i].f2, "g_43[i].f2", print_hash_value);
        3:  170:    transparent_crc(g_43[i].f3, "g_43[i].f3", print_hash_value);
        3:  171:    if (print_hash_value)
    #####:  172:      printf("index = [%d]\n", i);
        -:  173:  }
        1:  174:  transparent_crc(g_49, "g_49", print_hash_value);
        1:  175:  transparent_crc(g_51, "g_51", print_hash_value);
        1:  176:  transparent_crc(g_53, "g_53", print_hash_value);
        1:  177:  transparent_crc(g_55, "g_55", print_hash_value);
        1:  178:  transparent_crc(g_57, "g_57", print_hash_value);
        1:  179:  transparent_crc(g_81, "g_81", print_hash_value);
        1:  180:  transparent_crc(g_93.f0, "g_93.f0", print_hash_value);
        1:  181:  transparent_crc(g_111, "g_111", print_hash_value);
        3:  182:  for (i = 0; i < 2; i++) {
       12:  183:    for (j = 0; j < 5; j++) {
       10:  184:      transparent_crc(g_129[i][j], "g_129[i][j]", print_hash_value);
       10:  185:      if (print_hash_value)
    #####:  186:        printf("index = [%d][%d]\n", i, j);
        -:  187:    }
        -:  188:  }
        6:  189:  for (i = 0; i < 5; i++) {
       20:  190:    for (j = 0; j < 3; j++) {
       45:  191:      for (k = 0; k < 2; k++) {
       30:  192:        transparent_crc(g_130[i][j][k], "g_130[i][j][k]", print_hash_value);
       30:  193:        if (print_hash_value)
    #####:  194:          printf("index = [%d][%d][%d]\n", i, j, k);
        -:  195:      }
        -:  196:    }
        -:  197:  }
        1:  198:  platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
        1:  199:  return 0;
        -:  200:}
