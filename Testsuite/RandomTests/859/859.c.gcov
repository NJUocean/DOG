        -:    0:Source:859.c
        -:    0:Graph:859.gcno
        -:    0:Data:859.gcda
        -:    0:Runs:1
        -:    1:// Options:   --concise --max-struct-fields 5 --max-funcs 2 --max-array-len-per-dim 5 --max-block-depth 3 --max-block-size 2
        -:    2:#include "csmith.h"
        -:    3:
        -:    4:static long __undefined;
        -:    5:
        -:    6:struct S0 {
        -:    7:  unsigned f0 : 31;
        -:    8:};
        -:    9:
        -:   10:struct S1 {
        -:   11:  const unsigned f0 : 3;
        -:   12:};
        -:   13:
        -:   14:static volatile int8_t g_13 = 0x7EL;
        -:   15:static uint16_t g_14 = 0x8D19L;
        -:   16:static struct S1 g_15 = {1};
        -:   17:static int32_t g_29[4][5][2] = {{{0L, 0xE1D4595AL}, {0x2044653FL, 0xD21462CCL}, {0L, 3L}, {1L, (-9L)}, {(-9L), (-2L)}}, {{0xC5C6A3F1L, 1L}, {0xD402DA3CL, 0xE712C519L}, {3L, 0xE712C519L}, {0xD402DA3CL, 1L}, {0xC5C6A3F1L, (-2L)}}, {{(-9L), (-9L)}, {1L, 3L}, {0L, 0xD21462CCL}, {0x2044653FL, 0xE1D4595AL}, {0L, 0x2044653FL}}, {{(-1L), 0xD402DA3CL}, {(-1L), 0x2044653FL}, {0L, 0xE1D4595AL}, {0x2044653FL, 0xD21462CCL}, {0L, 3L}}};
        -:   18:static int8_t g_49 = (-1L);
        -:   19:static uint32_t g_85 = 0x599F3DF3L;
        -:   20:static struct S0 g_95 = {39168};
        -:   21:static struct S0 *volatile g_94 = &g_95;
        -:   22:static struct S0 *volatile g_97 = &g_95;
        -:   23:static uint64_t g_116[2] = {0x72B5AE5FB0772E7DLL, 0x72B5AE5FB0772E7DLL};
        -:   24:
        -:   25:static int64_t func_1(void);
        -:   26:static const struct S0 func_2(uint32_t p_3);
        -:   27:
        1:   28:static int64_t func_1(void) {
        1:   29:  struct S1 l_4 = {1};
        1:   30:  int32_t *l_28 = &g_29[3][2][0];
        -:   31:  int32_t l_30[1];
        1:   32:  uint16_t l_112 = 0xF2D9L;
        1:   33:  uint64_t *l_115 = &g_116[0];
        -:   34:  int i;
        2:   35:  for (i = 0; i < 1; i++)
        1:   36:    l_30[i] = (-9L);
       1*:   37:  (*g_97) = func_2((l_4, (safe_lshift_func_uint64_t_u_u((((safe_add_func_int8_t_s_s(l_4.f0, (safe_mod_func_uint8_t_u_u((safe_add_func_int16_t_s_s((g_13 ^ g_14), ((g_15, ((safe_lshift_func_uint8_t_u_s((safe_rshift_func_uint8_t_u_s((safe_mod_func_uint8_t_u_u((safe_div_func_int8_t_s_s(g_15.f0, (safe_rshift_func_uint32_t_u_s((((g_14 == ((safe_mul_func_uint32_t_u_u(l_4.f0, ((*l_28) = l_4.f0))) | 0xC6F79B34L)) || g_29[3][2][0]) & g_15.f0), g_15.f0)))), g_14)), 0)), 4)) | g_15.f0)) && l_30[0]))), g_15.f0)))) == g_15.f0) | g_14), 33))));
       1*:   38:  if ((safe_div_func_int8_t_s_s((0xEBE1D701D6BCCD07LL & ((*l_115) = (safe_mod_func_int32_t_s_s(((0xBBBBCA15L && (safe_add_func_uint32_t_u_u(((safe_sub_func_uint16_t_u_u(6UL, (safe_mod_func_uint16_t_u_u((*l_28), (safe_add_func_uint32_t_u_u(((safe_add_func_uint8_t_u_u((*l_28), (g_29[0][4][0] < l_112))), (((safe_lshift_func_uint8_t_u_s(0xCCL, g_15.f0)) || g_15.f0) >= (*l_28))), (*l_28))))))) == (*l_28)), g_13))) | g_14), 0xC2550360L)))), (*l_28)))) {
        1:   39:    (*l_28) = g_85;
        -:   40:  } else {
    #####:   41:    uint8_t l_117 = 5UL;
    #####:   42:    (*l_28) = (&g_95 == (void *)0);
    #####:   43:    l_117 &= ((*l_28) = g_49);
        -:   44:  }
        1:   45:  return g_13;
        -:   46:}
        -:   47:
        1:   48:static const struct S0 func_2(uint32_t p_3) {
        1:   49:  int32_t *l_35 = &g_29[3][2][0];
        1:   50:  uint8_t l_50 = 0xC7L;
        1:   51:  int32_t l_86 = 0L;
        -:   52:  int32_t l_87[5];
        1:   53:  const struct S0 l_96 = {34456};
        -:   54:  int i;
        6:   55:  for (i = 0; i < 5; i++)
        5:   56:    l_87[i] = 0x2AD413EDL;
        3:   57:  for (g_14 = 0; (g_14 <= 1); g_14 += 1) {
        -:   58:    int32_t *l_31[3];
        2:   59:    uint16_t l_90 = 1UL;
        -:   60:    int i;
        8:   61:    for (i = 0; i < 3; i++)
        6:   62:      l_31[i] = &g_29[3][2][0];
        2:   63:    if ((l_31[1] != &g_29[0][2][1])) {
        2:   64:      int32_t **l_32 = (void *)0;
        2:   65:      int32_t **l_33 = (void *)0;
        2:   66:      int32_t **l_34 = &l_31[0];
        2:   67:      g_29[3][2][0] = (((*l_34) = &g_29[2][2][0]) == l_35);
        6:   68:      for (p_3 = 0; (p_3 <= 1); p_3 += 1) {
        4:   69:        struct S1 l_46 = {0};
        4:   70:        int8_t *l_47 = (void *)0;
        4:   71:        int8_t *l_48 = &g_49;
        4:   72:        (**l_34) = (safe_lshift_func_int32_t_s_u(((p_3 != ((((*l_48) = ((safe_unary_minus_func_int8_t_s((1UL >= (g_14 > (((~0x0B2DE47E5F8F0B53LL) != ((p_3, (safe_lshift_func_uint8_t_u_s(((((p_3 || (-3L)), l_46), 0L), 7UL), p_3))) < g_29[3][2][0])) < 0x9A2DD318431BB57CLL))))) | 0x00L)) | l_50) | p_3)) ^ p_3), p_3));
        -:   73:      }
        -:   74:    } else {
    #####:   75:      (*l_35) = (safe_sub_func_int32_t_s_s(g_14, 0x8F300406L));
        -:   76:    }
        6:   77:    for (p_3 = 0; (p_3 <= 1); p_3 += 1) {
        4:   78:      int64_t l_64 = 0xB03C758019D44E41LL;
        4:   79:      int32_t l_88 = 0x5566EC8BL;
        4:   80:      int32_t l_89 = 0x2584F164L;
        4:   81:      struct S0 l_93 = {32992};
       4*:   82:      g_85 ^= (safe_rshift_func_uint64_t_u_s(((safe_add_func_int64_t_s_s((safe_mul_func_uint8_t_u_u((!g_15.f0), p_3)), (g_29[2][4][0], (((safe_lshift_func_int32_t_s_s(((*l_35) = (safe_mod_func_int8_t_s_s(l_64, p_3))), 16)) > (safe_rshift_func_uint8_t_u_u(((safe_lshift_func_uint16_t_u_u((safe_sub_func_int8_t_s_s(((safe_div_func_uint16_t_u_u(((safe_rshift_func_int16_t_s_u(((((p_3 <= (safe_mul_func_uint8_t_u_u((safe_lshift_func_int64_t_s_u((safe_rshift_func_uint8_t_u_s((((safe_mod_func_int64_t_s_s((safe_mod_func_uint64_t_u_u(g_49, (l_64 || g_15.f0))), p_3)) <= g_15.f0) < g_14), g_13)), 0)), g_15.f0))) != g_14), l_31[2]) != (void *)0), 9)) ^ l_64), 1UL)) | p_3), 250UL)), l_50)), g_15.f0), l_64))) || p_3)))), l_64), 50));
        4:   83:      l_90--;
       12:   84:      for (l_64 = 1; (l_64 >= 0); l_64 -= 1) {
        8:   85:        (*g_94) = l_93;
        -:   86:      }
        -:   87:    }
        -:   88:  }
        1:   89:  return l_96;
        -:   90:}
        -:   91:
        1:   92:int main(int argc, char *argv[]) {
        -:   93:  int i, j, k;
        1:   94:  int print_hash_value = 0;
       1*:   95:  if (argc == 2 && strcmp(argv[1], "1") == 0)
    #####:   96:    print_hash_value = 1;
        1:   97:  platform_main_begin();
        1:   98:  crc32_gentab();
        1:   99:  func_1();
        1:  100:  transparent_crc(g_13, "g_13", print_hash_value);
        1:  101:  transparent_crc(g_14, "g_14", print_hash_value);
        1:  102:  transparent_crc(g_15.f0, "g_15.f0", print_hash_value);
        5:  103:  for (i = 0; i < 4; i++) {
       24:  104:    for (j = 0; j < 5; j++) {
       60:  105:      for (k = 0; k < 2; k++) {
       40:  106:        transparent_crc(g_29[i][j][k], "g_29[i][j][k]", print_hash_value);
       40:  107:        if (print_hash_value)
    #####:  108:          printf("index = [%d][%d][%d]\n", i, j, k);
        -:  109:      }
        -:  110:    }
        -:  111:  }
        1:  112:  transparent_crc(g_49, "g_49", print_hash_value);
        1:  113:  transparent_crc(g_85, "g_85", print_hash_value);
        1:  114:  transparent_crc(g_95.f0, "g_95.f0", print_hash_value);
        3:  115:  for (i = 0; i < 2; i++) {
        2:  116:    transparent_crc(g_116[i], "g_116[i]", print_hash_value);
        2:  117:    if (print_hash_value)
    #####:  118:      printf("index = [%d]\n", i);
        -:  119:  }
        1:  120:  platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
        1:  121:  return 0;
        -:  122:}
