// Options:   --concise --max-struct-fields 5 --max-funcs 2 --max-array-len-per-dim 5 --max-block-depth 3 --max-block-size 2
#include "csmith.h"

static long __undefined;

struct S0 {
  signed f0 : 15;
  volatile signed f1 : 8;
};

#pragma pack(push)
#pragma pack(1)
struct S1 {
  volatile unsigned f0 : 18;
  signed f1 : 15;
  signed f2 : 31;
};
#pragma pack(pop)

union U2 {
  const int32_t f0;
  uint8_t f1;
  const int8_t f2;
  int32_t f3;
  uint32_t f4;
};

static volatile int32_t g_2 = (-2L);
static int32_t g_3 = 0xAFA2FAFDL;
static volatile int32_t g_7 = 0x3DE0369BL;
static int32_t g_8[2][1] = {{0L}, {0L}};
static int32_t g_9[1] = {(-1L)};
static volatile struct S0 g_12 = {122, 9};
static volatile struct S0 *volatile g_13 = &g_12;
static int32_t *g_16 = &g_3;
static int32_t **volatile g_15[4][1][2] = {{{&g_16, &g_16}}, {{&g_16, &g_16}}, {{&g_16, &g_16}}, {{&g_16, &g_16}}};
static uint16_t g_26 = 0UL;
static struct S0 g_37 = {-72, -4};
static int16_t g_39[1] = {0xAD14L};
static const union U2 g_47 = {0xEFAADAD2L};
static int32_t *g_59[4] = {&g_9[0], &g_9[0], &g_9[0], &g_9[0]};
static int32_t **const volatile g_58 = &g_59[3];
static struct S1 g_63 = {429, -60, -40726};
static struct S1 *const volatile g_62[1][2][1] = {{{&g_63}, {&g_63}}};
static int32_t **volatile g_70 = (void *)0;
static int32_t *volatile g_82 = &g_9[0];

static const uint8_t func_1(void);
static int32_t *func_10(int32_t *p_11);

static const uint8_t func_1(void) {
  int16_t l_6[3][1];
  const struct S0 *l_45 = &g_37;
  int32_t *l_69 = &g_8[1][0];
  int i, j;
  for (i = 0; i < 3; i++) {
    for (j = 0; j < 1; j++)
      l_6[i][j] = 0xE86FL;
  }
  for (g_3 = 0; (g_3 <= (-17)); g_3--) {
    uint16_t l_36[3];
    int16_t *l_60 = &l_6[2][0];
    int i;
    for (i = 0; i < 3; i++)
      l_36[i] = 65535UL;
    for (g_8[0][0] = 0; (g_8[0][0] <= 0); g_8[0][0] += 1) {
      uint16_t *l_25 = &g_26;
      int16_t *l_38 = &g_39[0];
      uint16_t l_40 = 1UL;
      int16_t l_41[5] = {0xCE9DL, 0xCE9DL, 0xCE9DL, 0xCE9DL, 0xCE9DL};
      struct S0 *l_44 = (void *)0;
      int i, j;
      for (g_9[0] = 0; (g_9[0] <= 0); g_9[0] += 1) {
        int32_t **l_17 = &g_16;
        (*l_17) = func_10(&g_8[0][0]);
      }
      if ((safe_mul_func_uint32_t_u_u((safe_lshift_func_uint32_t_u_u(((!(safe_mul_func_int32_t_s_s((0x5A8DF0442E11914CLL && ((((((--(*l_25)) || 0x4ADCL) & (((((~((safe_sub_func_int8_t_s_s((safe_add_func_uint32_t_u_u(l_6[(g_8[0][0] + 1)][g_8[0][0]], (safe_div_func_int16_t_s_s(((0x6FL | (g_9[0] != g_9[0])), ((*l_38) = (l_36[0] & (0L == (g_37, l_6[(g_8[0][0] + 1)][g_8[0][0]]))))), l_40)))), l_36[2])), g_2)) < 0x5D06L) ^ g_8[0][0]) ^ l_6[2][0]) ^ g_3)) == g_9[0]) <= 0x44F8L) != l_41[2])), 4L))) <= 4UL), l_6[0][0])), l_36[0]))) {
        uint64_t l_48 = 0x349A2DD318431BB5LL;
        int16_t *l_55 = &l_6[1][0];
        int16_t *l_56 = &l_41[2];
        int32_t **l_57 = &g_16;
        int16_t **l_61 = &l_55;
        struct S1 *l_65 = (void *)0;
        struct S1 *volatile *l_64 = &l_65;
        (*g_58) = ((*l_57) = func_10((((((*l_56) = ((*l_55) = ((safe_sub_func_int32_t_s_s((l_44 != l_45), (~((g_47, l_48) < l_48)))) == ((((void *)0 != &g_26) | ((l_6[1][0] == ((*l_38) = ((safe_sub_func_uint16_t_u_u(((safe_mod_func_uint64_t_u_u((safe_rshift_func_int16_t_s_s(((g_12.f0 >= 6UL) ^ g_39[0]), 5)), l_6[0][0])) & g_39[0]), g_8[0][0])) || g_37.f0))) < 0x95C7L)) < 0x460EE42AL)))), g_2) >= g_8[0][0]), (void *)0)));
        (*l_64) = ((l_60 == ((*l_61) = &l_6[(g_8[0][0] + 1)][g_8[0][0]])), g_62[0][0][0]);
      } else {
        int32_t *l_66 = &g_9[0];
        (*l_66) = l_6[0][0];
      }
    }
  }
  for (g_26 = 0; (g_26 <= 56); g_26 = safe_add_func_uint32_t_u_u(g_26, 1)) {
    l_69 = func_10(func_10(l_69));
    for (g_3 = 0; (g_3 == (-19)); --g_3) {
      uint64_t l_73 = 18446744073709551613UL;
      int16_t *l_76 = (void *)0;
      int16_t *l_77[2][2] = {{&g_39[0], &g_39[0]}, {&g_39[0], &g_39[0]}};
      int32_t l_78 = 5L;
      int i, j;
      if (((&g_63 != &g_63) <= (((*g_13), l_73) < (safe_div_func_int16_t_s_s((l_78 = 0x0A73L), g_3))))) {
        struct S1 *l_79 = &g_63;
        (*l_79) = g_63;
      } else {
        int32_t **l_80 = (void *)0;
        int32_t **l_81 = &l_69;
        (*l_81) = func_10(l_69);
        (*g_82) |= (((void *)0 == &g_39[0]) >= 0xAC80L);
      }
    }
  }
  return (*l_69);
}

static int32_t *func_10(int32_t *p_11) {
  int32_t *l_14[2][4][1] = {{{&g_8[0][0]}, {&g_3}, {&g_3}, {&g_8[0][0]}}, {{&g_3}, {&g_3}, {&g_8[0][0]}, {&g_3}}};
  int i, j, k;
  (*g_13) = g_12;
  return l_14[1][1][0];
}

int main(int argc, char *argv[]) {
  int i, j, k;
  int print_hash_value = 0;
  if (argc == 2 && strcmp(argv[1], "1") == 0)
    print_hash_value = 1;
  platform_main_begin();
  crc32_gentab();
  func_1();
  transparent_crc(g_2, "g_2", print_hash_value);
  transparent_crc(g_3, "g_3", print_hash_value);
  transparent_crc(g_7, "g_7", print_hash_value);
  for (i = 0; i < 2; i++) {
    for (j = 0; j < 1; j++) {
      transparent_crc(g_8[i][j], "g_8[i][j]", print_hash_value);
      if (print_hash_value)
        printf("index = [%d][%d]\n", i, j);
    }
  }
  for (i = 0; i < 1; i++) {
    transparent_crc(g_9[i], "g_9[i]", print_hash_value);
    if (print_hash_value)
      printf("index = [%d]\n", i);
  }
  transparent_crc(g_12.f0, "g_12.f0", print_hash_value);
  transparent_crc(g_12.f1, "g_12.f1", print_hash_value);
  transparent_crc(g_26, "g_26", print_hash_value);
  transparent_crc(g_37.f0, "g_37.f0", print_hash_value);
  transparent_crc(g_37.f1, "g_37.f1", print_hash_value);
  for (i = 0; i < 1; i++) {
    transparent_crc(g_39[i], "g_39[i]", print_hash_value);
    if (print_hash_value)
      printf("index = [%d]\n", i);
  }
  transparent_crc(g_47.f0, "g_47.f0", print_hash_value);
  transparent_crc(g_63.f0, "g_63.f0", print_hash_value);
  transparent_crc(g_63.f1, "g_63.f1", print_hash_value);
  transparent_crc(g_63.f2, "g_63.f2", print_hash_value);
  platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
  return 0;
}
