        -:    0:Source:500.c
        -:    0:Graph:500.gcno
        -:    0:Data:500.gcda
        -:    0:Runs:1
        -:    1:// Options:   --concise --max-struct-fields 5 --max-funcs 2 --max-array-len-per-dim 5 --max-block-depth 3 --max-block-size 2
        -:    2:#include "csmith.h"
        -:    3:
        -:    4:static long __undefined;
        -:    5:
        -:    6:union U0 {
        -:    7:  int8_t f0;
        -:    8:  volatile int32_t f1;
        -:    9:  const int64_t f2;
        -:   10:  uint16_t f3;
        -:   11:  volatile uint32_t f4;
        -:   12:};
        -:   13:
        -:   14:union U1 {
        -:   15:  const int8_t f0;
        -:   16:  const volatile uint8_t f1;
        -:   17:  volatile uint64_t f2;
        -:   18:  const uint16_t f3;
        -:   19:  unsigned f4 : 30;
        -:   20:};
        -:   21:
        -:   22:static union U0 g_9 = {0L};
        -:   23:static volatile union U1 g_26 = {0xA1L};
        -:   24:static int8_t g_34 = 8L;
        -:   25:static int32_t g_39 = 0x56A759F3L;
        -:   26:static int32_t g_43 = 0xD231D576L;
        -:   27:static int32_t g_45 = 0x7B11082EL;
        -:   28:static int32_t *volatile g_44 = &g_45;
        -:   29:static int16_t g_52[5][4] = {{0x8E44L, 0x26B1L, 0xD942L, 0xD942L}, {0x122EL, 0x122EL, 0x8E44L, 0xD942L}, {0L, 0x26B1L, 0L, 0x8E44L}, {0L, 0x8E44L, 0x8E44L, 0L}, {0x122EL, 0x8E44L, 0xD942L, 0x8E44L}};
        -:   30:static volatile int16_t g_53 = (-1L);
        -:   31:static int32_t *volatile g_61 = &g_45;
        -:   32:static int32_t g_65 = 0x7F16C3B1L;
        -:   33:static volatile uint16_t g_67 = 65535UL;
        -:   34:static volatile uint16_t *g_66 = &g_67;
        -:   35:static uint16_t g_70 = 0x99C2L;
        -:   36:static uint16_t *g_72 = (void *)0;
        -:   37:static int64_t g_75[4][1] = {{0L}, {0x4559F947EB5F43E0LL}, {0L}, {0x4559F947EB5F43E0LL}};
        -:   38:static uint16_t *g_79 = &g_70;
        -:   39:static int32_t *volatile g_80 = &g_45;
        -:   40:
        -:   41:static int32_t func_1(void);
        -:   42:static int16_t func_4(int32_t p_5, uint32_t p_6, uint8_t p_7, const uint64_t p_8);
        -:   43:
        1:   44:static int32_t func_1(void) {
        1:   45:  uint32_t l_12 = 1UL;
        1:   46:  uint16_t *l_71 = (void *)0;
        1:   47:  uint16_t *l_78 = (void *)0;
        1:   48:  if (((safe_add_func_int16_t_s_s((0xDED6L <= 65534UL), func_4((g_9, (safe_mul_func_uint32_t_u_u(l_12, 0x3414B58EL))), (safe_div_func_uint64_t_u_u(0x1245C8100C4307E4LL, (+l_12))), g_9.f0, l_12))), l_12)) {
        1:   49:    uint16_t *l_63 = &g_9.f3;
        -:   50:    uint32_t *l_64[5];
        1:   51:    uint16_t *l_69 = &g_70;
        -:   52:    uint16_t **l_68[4];
        -:   53:    int64_t *l_74[3];
        1:   54:    int32_t l_76 = 1L;
        -:   55:    int i;
        6:   56:    for (i = 0; i < 5; i++)
        5:   57:      l_64[i] = &l_12;
        5:   58:    for (i = 0; i < 4; i++)
        4:   59:      l_68[i] = &l_69;
        4:   60:    for (i = 0; i < 3; i++)
        3:   61:      l_74[i] = &g_75[1][0];
       1*:   62:    (*g_80) = (~(((*l_63) = g_53) | ((((g_65 = 0x7DF0EBE3L), (g_66 == (g_72 = (l_71 = l_63)))) & ((l_76 |= (~g_39)) && l_12)) >= (+(((g_45, ((g_79 = l_78) != l_78)) & 0xBDL) != 0x065C771C75621C9ALL)))));
        -:   63:  } else {
    #####:   64:    return g_53;
        -:   65:  }
        1:   66:  return l_12;
        -:   67:}
        -:   68:
        1:   69:static int16_t func_4(int32_t p_5, uint32_t p_6, uint8_t p_7, const uint64_t p_8) {
        -:   70:  int32_t l_16[1][1][3];
        1:   71:  int64_t l_17 = (-1L);
        1:   72:  uint16_t l_40 = 0x60A3L;
        1:   73:  int32_t l_50 = 0x38DBEC8BL;
        1:   74:  int8_t l_60 = 0xC7L;
        -:   75:  int i, j, k;
        2:   76:  for (i = 0; i < 1; i++) {
        2:   77:    for (j = 0; j < 1; j++) {
        4:   78:      for (k = 0; k < 3; k++)
        3:   79:        l_16[i][j][k] = 8L;
        -:   80:    }
        -:   81:  }
       1*:   82:  for (p_6 = 0; (p_6 <= 0); p_6 += 1) {
        -:   83:    int8_t l_37[3];
        1:   84:    int32_t *l_46 = &l_16[0][0][2];
        -:   85:    int i;
        4:   86:    for (i = 0; i < 3; i++)
        3:   87:      l_37[i] = 0xD4L;
        1:   88:    if (l_17)
        1:   89:      break;
    #####:   90:    for (p_7 = 0; (p_7 <= 0); p_7 += 1) {
    #####:   91:      uint64_t l_41 = 0xD55E0ECF58A4122ELL;
        -:   92:      int8_t *l_47[4][1];
    #####:   93:      int32_t l_48 = 0xA1818855L;
    #####:   94:      int32_t l_49 = 0x39FA237FL;
    #####:   95:      int16_t *l_51 = &g_52[4][3];
    #####:   96:      int32_t *l_54 = &l_50;
    #####:   97:      int32_t *l_55 = (void *)0;
        -:   98:      int i, j;
    #####:   99:      for (i = 0; i < 4; i++) {
    #####:  100:        for (j = 0; j < 1; j++)
    #####:  101:          l_47[i][j] = &l_37[1];
        -:  102:      }
    #####:  103:      for (g_9.f0 = 0; (g_9.f0 >= 0); g_9.f0 -= 1) {
        -:  104:        int64_t *l_33[5];
    #####:  105:        int32_t l_35 = 8L;
    #####:  106:        int16_t l_36 = (-1L);
        -:  107:        int16_t *l_38[3];
    #####:  108:        int32_t *l_42 = &g_43;
        -:  109:        int i, j, k;
    #####:  110:        for (i = 0; i < 5; i++)
    #####:  111:          l_33[i] = &l_17;
    #####:  112:        for (i = 0; i < 3; i++)
    #####:  113:          l_38[i] = (void *)0;
    #####:  114:        (*g_44) = ((*l_42) |= (((safe_mul_func_uint8_t_u_u((l_16[g_9.f0][g_9.f0][(p_7 + 1)] | ((((l_16[g_9.f0][g_9.f0][(p_7 + 1)], (safe_mod_func_int64_t_s_s(0x5CC7C44D99649744LL, g_9.f0))) < (((((l_40 |= (g_39 = (((safe_mul_func_uint64_t_u_u((safe_add_func_uint8_t_u_u((g_26, (g_9.f0 != (safe_lshift_func_uint64_t_u_s(((safe_sub_func_int32_t_s_s((safe_add_func_int64_t_s_s(((p_8 && (g_34 &= 1L)), (l_35 = p_8)), 1UL)), l_36)) & l_37[1]), 49)))), g_9.f0)), 0x515ED761E7FF5188LL)) ^ l_17) > (-2L)))) | 0x5F6BL), p_8) == g_9.f0) == 3L)) < l_41) && l_16[g_9.f0][g_9.f0][(p_7 + 1)])), 0x94L)) > l_36) < 0x89A45823L));
    #####:  115:        (*l_46) ^= (&p_5 == l_46);
        -:  116:      }
    #####:  117:      if ((p_5 = (((*l_46) = ((g_34 & (l_49 = (l_48 = (l_41 && 0x36C2L)))) != 0L)) != (((*l_51) |= (l_50 ^= l_41)), ((*l_54) = ((0xDBD1BD9FL ^ (3L > (((0UL < ((-1L) != p_7)) == l_17) > g_53))) ^ g_43)))))) {
    #####:  118:        (*l_54) = p_8;
        -:  119:      } else {
    #####:  120:        int16_t *l_59[5][1] = {{&g_52[1][2]}, {(void *)0}, {&g_52[1][2]}, {(void *)0}, {&g_52[1][2]}};
        -:  121:        int i, j;
    #####:  122:        (*l_46) = (+(l_50 |= (0x3FE8L || (safe_mul_func_uint16_t_u_u(g_53, (l_59[4][0] != l_59[4][0]))))));
        -:  123:      }
        -:  124:    }
        -:  125:  }
        1:  126:  (*g_61) ^= l_60;
        1:  127:  return l_60;
        -:  128:}
        -:  129:
        1:  130:int main(int argc, char *argv[]) {
        -:  131:  int i, j;
        1:  132:  int print_hash_value = 0;
       1*:  133:  if (argc == 2 && strcmp(argv[1], "1") == 0)
    #####:  134:    print_hash_value = 1;
        1:  135:  platform_main_begin();
        1:  136:  crc32_gentab();
        1:  137:  func_1();
        1:  138:  transparent_crc(g_26.f0, "g_26.f0", print_hash_value);
        1:  139:  transparent_crc(g_34, "g_34", print_hash_value);
        1:  140:  transparent_crc(g_39, "g_39", print_hash_value);
        1:  141:  transparent_crc(g_43, "g_43", print_hash_value);
        1:  142:  transparent_crc(g_45, "g_45", print_hash_value);
        6:  143:  for (i = 0; i < 5; i++) {
       25:  144:    for (j = 0; j < 4; j++) {
       20:  145:      transparent_crc(g_52[i][j], "g_52[i][j]", print_hash_value);
       20:  146:      if (print_hash_value)
    #####:  147:        printf("index = [%d][%d]\n", i, j);
        -:  148:    }
        -:  149:  }
        1:  150:  transparent_crc(g_53, "g_53", print_hash_value);
        1:  151:  transparent_crc(g_65, "g_65", print_hash_value);
        1:  152:  transparent_crc(g_67, "g_67", print_hash_value);
        1:  153:  transparent_crc(g_70, "g_70", print_hash_value);
        5:  154:  for (i = 0; i < 4; i++) {
        8:  155:    for (j = 0; j < 1; j++) {
        4:  156:      transparent_crc(g_75[i][j], "g_75[i][j]", print_hash_value);
        4:  157:      if (print_hash_value)
    #####:  158:        printf("index = [%d][%d]\n", i, j);
        -:  159:    }
        -:  160:  }
        1:  161:  platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
        1:  162:  return 0;
        -:  163:}
