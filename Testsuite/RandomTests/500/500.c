// Options:   --concise --max-struct-fields 5 --max-funcs 2 --max-array-len-per-dim 5 --max-block-depth 3 --max-block-size 2
#include "csmith.h"

static long __undefined;

union U0 {
  int8_t f0;
  volatile int32_t f1;
  const int64_t f2;
  uint16_t f3;
  volatile uint32_t f4;
};

union U1 {
  const int8_t f0;
  const volatile uint8_t f1;
  volatile uint64_t f2;
  const uint16_t f3;
  unsigned f4 : 30;
};

static union U0 g_9 = {0L};
static volatile union U1 g_26 = {0xA1L};
static int8_t g_34 = 8L;
static int32_t g_39 = 0x56A759F3L;
static int32_t g_43 = 0xD231D576L;
static int32_t g_45 = 0x7B11082EL;
static int32_t *volatile g_44 = &g_45;
static int16_t g_52[5][4] = {{0x8E44L, 0x26B1L, 0xD942L, 0xD942L}, {0x122EL, 0x122EL, 0x8E44L, 0xD942L}, {0L, 0x26B1L, 0L, 0x8E44L}, {0L, 0x8E44L, 0x8E44L, 0L}, {0x122EL, 0x8E44L, 0xD942L, 0x8E44L}};
static volatile int16_t g_53 = (-1L);
static int32_t *volatile g_61 = &g_45;
static int32_t g_65 = 0x7F16C3B1L;
static volatile uint16_t g_67 = 65535UL;
static volatile uint16_t *g_66 = &g_67;
static uint16_t g_70 = 0x99C2L;
static uint16_t *g_72 = (void *)0;
static int64_t g_75[4][1] = {{0L}, {0x4559F947EB5F43E0LL}, {0L}, {0x4559F947EB5F43E0LL}};
static uint16_t *g_79 = &g_70;
static int32_t *volatile g_80 = &g_45;

static int32_t func_1(void);
static int16_t func_4(int32_t p_5, uint32_t p_6, uint8_t p_7, const uint64_t p_8);

static int32_t func_1(void) {
  uint32_t l_12 = 1UL;
  uint16_t *l_71 = (void *)0;
  uint16_t *l_78 = (void *)0;
  if (((safe_add_func_int16_t_s_s((0xDED6L <= 65534UL), func_4((g_9, (safe_mul_func_uint32_t_u_u(l_12, 0x3414B58EL))), (safe_div_func_uint64_t_u_u(0x1245C8100C4307E4LL, (+l_12))), g_9.f0, l_12))), l_12)) {
    uint16_t *l_63 = &g_9.f3;
    uint32_t *l_64[5];
    uint16_t *l_69 = &g_70;
    uint16_t **l_68[4];
    int64_t *l_74[3];
    int32_t l_76 = 1L;
    int i;
    for (i = 0; i < 5; i++)
      l_64[i] = &l_12;
    for (i = 0; i < 4; i++)
      l_68[i] = &l_69;
    for (i = 0; i < 3; i++)
      l_74[i] = &g_75[1][0];
    (*g_80) = (~(((*l_63) = g_53) | ((((g_65 = 0x7DF0EBE3L), (g_66 == (g_72 = (l_71 = l_63)))) & ((l_76 |= (~g_39)) && l_12)) >= (+(((g_45, ((g_79 = l_78) != l_78)) & 0xBDL) != 0x065C771C75621C9ALL)))));
  } else {
    return g_53;
  }
  return l_12;
}

static int16_t func_4(int32_t p_5, uint32_t p_6, uint8_t p_7, const uint64_t p_8) {
  int32_t l_16[1][1][3];
  int64_t l_17 = (-1L);
  uint16_t l_40 = 0x60A3L;
  int32_t l_50 = 0x38DBEC8BL;
  int8_t l_60 = 0xC7L;
  int i, j, k;
  for (i = 0; i < 1; i++) {
    for (j = 0; j < 1; j++) {
      for (k = 0; k < 3; k++)
        l_16[i][j][k] = 8L;
    }
  }
  for (p_6 = 0; (p_6 <= 0); p_6 += 1) {
    int8_t l_37[3];
    int32_t *l_46 = &l_16[0][0][2];
    int i;
    for (i = 0; i < 3; i++)
      l_37[i] = 0xD4L;
    if (l_17)
      break;
    for (p_7 = 0; (p_7 <= 0); p_7 += 1) {
      uint64_t l_41 = 0xD55E0ECF58A4122ELL;
      int8_t *l_47[4][1];
      int32_t l_48 = 0xA1818855L;
      int32_t l_49 = 0x39FA237FL;
      int16_t *l_51 = &g_52[4][3];
      int32_t *l_54 = &l_50;
      int32_t *l_55 = (void *)0;
      int i, j;
      for (i = 0; i < 4; i++) {
        for (j = 0; j < 1; j++)
          l_47[i][j] = &l_37[1];
      }
      for (g_9.f0 = 0; (g_9.f0 >= 0); g_9.f0 -= 1) {
        int64_t *l_33[5];
        int32_t l_35 = 8L;
        int16_t l_36 = (-1L);
        int16_t *l_38[3];
        int32_t *l_42 = &g_43;
        int i, j, k;
        for (i = 0; i < 5; i++)
          l_33[i] = &l_17;
        for (i = 0; i < 3; i++)
          l_38[i] = (void *)0;
        (*g_44) = ((*l_42) |= (((safe_mul_func_uint8_t_u_u((l_16[g_9.f0][g_9.f0][(p_7 + 1)] | ((((l_16[g_9.f0][g_9.f0][(p_7 + 1)], (safe_mod_func_int64_t_s_s(0x5CC7C44D99649744LL, g_9.f0))) < (((((l_40 |= (g_39 = (((safe_mul_func_uint64_t_u_u((safe_add_func_uint8_t_u_u((g_26, (g_9.f0 != (safe_lshift_func_uint64_t_u_s(((safe_sub_func_int32_t_s_s((safe_add_func_int64_t_s_s(((p_8 && (g_34 &= 1L)), (l_35 = p_8)), 1UL)), l_36)) & l_37[1]), 49)))), g_9.f0)), 0x515ED761E7FF5188LL)) ^ l_17) > (-2L)))) | 0x5F6BL), p_8) == g_9.f0) == 3L)) < l_41) && l_16[g_9.f0][g_9.f0][(p_7 + 1)])), 0x94L)) > l_36) < 0x89A45823L));
        (*l_46) ^= (&p_5 == l_46);
      }
      if ((p_5 = (((*l_46) = ((g_34 & (l_49 = (l_48 = (l_41 && 0x36C2L)))) != 0L)) != (((*l_51) |= (l_50 ^= l_41)), ((*l_54) = ((0xDBD1BD9FL ^ (3L > (((0UL < ((-1L) != p_7)) == l_17) > g_53))) ^ g_43)))))) {
        (*l_54) = p_8;
      } else {
        int16_t *l_59[5][1] = {{&g_52[1][2]}, {(void *)0}, {&g_52[1][2]}, {(void *)0}, {&g_52[1][2]}};
        int i, j;
        (*l_46) = (+(l_50 |= (0x3FE8L || (safe_mul_func_uint16_t_u_u(g_53, (l_59[4][0] != l_59[4][0]))))));
      }
    }
  }
  (*g_61) ^= l_60;
  return l_60;
}

int main(int argc, char *argv[]) {
  int i, j;
  int print_hash_value = 0;
  if (argc == 2 && strcmp(argv[1], "1") == 0)
    print_hash_value = 1;
  platform_main_begin();
  crc32_gentab();
  func_1();
  transparent_crc(g_26.f0, "g_26.f0", print_hash_value);
  transparent_crc(g_34, "g_34", print_hash_value);
  transparent_crc(g_39, "g_39", print_hash_value);
  transparent_crc(g_43, "g_43", print_hash_value);
  transparent_crc(g_45, "g_45", print_hash_value);
  for (i = 0; i < 5; i++) {
    for (j = 0; j < 4; j++) {
      transparent_crc(g_52[i][j], "g_52[i][j]", print_hash_value);
      if (print_hash_value)
        printf("index = [%d][%d]\n", i, j);
    }
  }
  transparent_crc(g_53, "g_53", print_hash_value);
  transparent_crc(g_65, "g_65", print_hash_value);
  transparent_crc(g_67, "g_67", print_hash_value);
  transparent_crc(g_70, "g_70", print_hash_value);
  for (i = 0; i < 4; i++) {
    for (j = 0; j < 1; j++) {
      transparent_crc(g_75[i][j], "g_75[i][j]", print_hash_value);
      if (print_hash_value)
        printf("index = [%d][%d]\n", i, j);
    }
  }
  platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
  return 0;
}
