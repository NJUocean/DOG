        -:    0:Source:785.c
        -:    0:Graph:785.gcno
        -:    0:Data:785.gcda
        -:    0:Runs:1
        -:    1:// Options:   --concise --max-struct-fields 5 --max-funcs 2 --max-array-len-per-dim 5 --max-block-depth 3 --max-block-size 2
        -:    2:#include "csmith.h"
        -:    3:
        -:    4:static long __undefined;
        -:    5:
        -:    6:union U0 {
        -:    7:  uint8_t f0;
        -:    8:  signed f1 : 1;
        -:    9:  volatile uint8_t f2;
        -:   10:};
        -:   11:
        -:   12:union U1 {
        -:   13:  volatile uint16_t f0;
        -:   14:  volatile uint32_t f1;
        -:   15:  const uint8_t f2;
        -:   16:  volatile int64_t f3;
        -:   17:};
        -:   18:
        -:   19:union U2 {
        -:   20:  const volatile uint64_t f0;
        -:   21:  volatile uint16_t f1;
        -:   22:  volatile int64_t f2;
        -:   23:};
        -:   24:
        -:   25:union U3 {
        -:   26:  volatile int8_t f0;
        -:   27:  const signed f1 : 17;
        -:   28:  uint32_t f2;
        -:   29:  volatile uint32_t f3;
        -:   30:  const int8_t f4;
        -:   31:};
        -:   32:
        -:   33:static volatile union U0 g_11[5] = {{0xF9L}, {0xF9L}, {0xF9L}, {0xF9L}, {0xF9L}};
        -:   34:static uint8_t g_13 = 0x5DL;
        -:   35:static const int64_t g_14 = 1L;
        -:   36:static volatile union U3 g_34[5] = {{1L}, {1L}, {1L}, {1L}, {1L}};
        -:   37:static int8_t g_50 = 0xDBL;
        -:   38:static int16_t g_53 = (-2L);
        -:   39:static int32_t g_59[4] = {8L, 8L, 8L, 8L};
        -:   40:static int32_t *const g_58 = &g_59[2];
        -:   41:static uint64_t g_71 = 18446744073709551607UL;
        -:   42:static int64_t g_75 = (-1L);
        -:   43:static int64_t *g_74 = &g_75;
        -:   44:static uint16_t g_82 = 1UL;
        -:   45:static union U1 g_86 = {0xED78L};
        -:   46:static uint32_t g_88 = 1UL;
        -:   47:static int16_t g_95 = 1L;
        -:   48:static int16_t *g_94 = &g_95;
        -:   49:static union U1 g_97 = {65535UL};
        -:   50:static int32_t **volatile g_98 = (void *)0;
        -:   51:static int32_t *g_100 = &g_59[2];
        -:   52:static int32_t **volatile g_99 = &g_100;
        -:   53:static uint32_t g_106 = 4294967286UL;
        -:   54:static uint32_t *g_132 = &g_88;
        -:   55:static uint32_t *const *volatile g_131 = &g_132;
        -:   56:static int32_t **volatile g_134 = &g_100;
        -:   57:static union U2 g_156 = {0UL};
        -:   58:
        -:   59:static uint8_t func_1(void);
        -:   60:static int64_t func_2(uint64_t p_3, uint32_t p_4, int32_t p_5);
        -:   61:
        1:   62:static uint8_t func_1(void) {
        1:   63:  uint8_t l_6 = 250UL;
        1:   64:  int64_t l_9 = 0x7D50F82BAEF6E229LL;
        1:   65:  uint8_t *l_12 = &g_13;
        -:   66:  int64_t *l_55[1][5][5];
        -:   67:  int32_t l_56[1][2];
        1:   68:  uint32_t *l_104 = (void *)0;
        1:   69:  uint32_t *l_105 = &g_106;
        1:   70:  int32_t l_115 = 0xA27851EDL;
        1:   71:  int32_t **l_149 = (void *)0;
        -:   72:  int i, j, k;
        2:   73:  for (i = 0; i < 1; i++) {
        6:   74:    for (j = 0; j < 5; j++) {
       30:   75:      for (k = 0; k < 5; k++)
       25:   76:        l_55[i][j][k] = &l_9;
        -:   77:    }
        -:   78:  }
        2:   79:  for (i = 0; i < 1; i++) {
        3:   80:    for (j = 0; j < 2; j++)
        2:   81:      l_56[i][j] = 0x485393F1L;
        -:   82:  }
       1*:   83:  if ((((l_56[0][1] = func_2(((l_6 == (safe_add_func_uint64_t_u_u(l_9, ((~((((g_11[4], ((*l_12) = 0UL)) > l_6) && 6UL) & g_14)) || ((safe_unary_minus_func_int64_t_s(((g_11[4], g_11[4].f0) >= 0UL))) >= 0x1F7DL))))) < g_14), g_14, l_9)) || 0xA6F2DB44E93343DELL), 1L)) {
        1:   84:    int32_t *l_57 = &l_56[0][1];
        1:   85:    (*l_57) = g_50;
        -:   86:  } else {
        -:   87:    uint64_t l_70 = 2UL;
        -:   88:    (*g_58) |= ((&l_56[0][1] == (g_53, g_58)) && ((0x298BL != 0x65B2L) ^ (((safe_mod_func_int64_t_s_s(g_53, (safe_mul_func_uint32_t_u_u((safe_mod_func_int64_t_s_s(g_34[2].f0, (g_71 ^= (((((l_9 ^ (safe_mul_func_int64_t_s_s(5L, 1L))), l_56[0][1]) && l_70) > 0UL) > l_70)))), 4294967290UL)))) > 0x1AE2D2C9L), (-8L))));
        -:   89:    for (g_71 = 0; (g_71 == 1); ++g_71) {
        -:   90:      int64_t **l_76 = &l_55[0][1][4];
        -:   91:      uint16_t *l_81[1][3][3] = {{{&g_82, &g_82, &g_82}, {&g_82, &g_82, &g_82}, {&g_82, &g_82, &g_82}}};
        -:   92:      int32_t l_83 = 0x0F8796DEL;
        -:   93:      uint32_t *l_87 = &g_88;
        -:   94:      int16_t *l_93 = &g_53;
        -:   95:      int16_t **l_96 = (void *)0;
        -:   96:      int8_t l_101[5][3] = {{0xC1L, 2L, 0xC1L}, {0xAAL, 0xD5L, (-1L)}, {0xAAL, 0xAAL, 0xD5L}, {0xC1L, 0xD5L, 0xD5L}, {0xD5L, 2L, (-1L)}};
        -:   97:      int i, j, k;
        -:   98:      (*g_58) = (((*l_76) = g_74) != &g_75);
        -:   99:      if ((safe_mul_func_uint8_t_u_u(((*g_74) > (safe_sub_func_uint16_t_u_u((g_82 = 0x5A8DL), (l_83 ^ (((safe_rshift_func_uint16_t_u_s((g_50 == (g_86, (((*l_87)++), (*g_74)))), 0)), l_70) != ((*l_93) = (!(~l_56[0][1])))))))), ((g_94 = g_94) != &g_95)))) {
        -:  100:        (*g_99) = (g_97, &l_56[0][1]);
        -:  101:        return l_101[0][2];
        -:  102:      } else {
        -:  103:        (*g_100) &= (&g_74 != &l_55[0][1][4]);
        -:  104:      }
        -:  105:    }
        -:  106:  }
        1:  107:  if (((*g_100) = (safe_sub_func_uint8_t_u_u((((*l_105) = g_97.f0) > (safe_lshift_func_int64_t_s_u((l_105 == &g_88), ((&g_88 == (((*g_94) == 0x7EFFL), l_104)) | 0xCE03L)))), (safe_add_func_uint16_t_u_u((((0xADD5L && l_56[0][1]) > 0xA48933ACL) <= (*g_100)), 0xC48AL)))))) {
        1:  108:    int8_t *l_126 = (void *)0;
        1:  109:    int32_t l_127 = 0x438E4B99L;
        1:  110:    uint16_t *l_128 = (void *)0;
        1:  111:    uint64_t *l_129 = &g_71;
        1:  112:    uint32_t l_130[5] = {0xF146544CL, 0xF146544CL, 0xF146544CL, 0xF146544CL, 0xF146544CL};
        1:  113:    const int16_t *l_157 = &g_95;
        -:  114:    uint32_t l_164[2];
        1:  115:    int32_t l_168 = (-7L);
        -:  116:    int i;
        3:  117:    for (i = 0; i < 2; i++)
        2:  118:      l_164[i] = 18446744073709551615UL;
        1:  119:    (*g_58) ^= (((*l_129) = (((((safe_div_func_int32_t_s_s(0x4ED4C97AL, (safe_lshift_func_uint64_t_u_u(((((*g_99) == &l_56[0][1]) ^ ((*l_105)--)), 18446744073709551613UL), 24)))) >= l_56[0][1]), (safe_rshift_func_uint8_t_u_s((safe_sub_func_uint16_t_u_u((l_56[0][1] = (safe_add_func_uint64_t_u_u((((((safe_add_func_uint32_t_u_u((((((g_50 &= l_115), g_88) | (*g_74)) <= l_56[0][1]) != 0xA7CFL), g_106)) & l_127) | 0x9347L) != 0UL), l_127), 0x412C06D41FC1B3DFLL))), 0x677AL)), g_82))) >= l_127) < (*g_74))) == 0xD9F78EB292015BDFLL);
        1:  120:    if (l_130[0]) {
        1:  121:      uint32_t *const *volatile l_133 = &g_132;
        2:  122:      for (g_106 = 0; (g_106 <= 0); g_106 += 1) {
        1:  123:        l_133 = g_131;
        1:  124:        (*g_100) = l_56[0][1];
        -:  125:      }
        -:  126:    } else {
    #####:  127:      uint64_t l_141 = 18446744073709551615UL;
    #####:  128:      const int16_t l_144 = 9L;
    #####:  129:      int32_t **l_151 = &g_100;
    #####:  130:      int16_t **l_158 = &g_94;
    #####:  131:      (*g_134) = &l_56[0][1];
    #####:  132:      if ((safe_sub_func_uint8_t_u_u((safe_sub_func_uint64_t_u_u((((+(~(g_13 &= l_141))) < (safe_mod_func_int32_t_s_s((0x4755L && l_144), ((5L <= 0x31C418A4L) | (l_141 != ((&g_71 == l_55[0][1][4]) <= l_130[1])))))) >= g_75), 1UL)), l_6))) {
    #####:  133:        int32_t ***l_150 = &l_149;
    #####:  134:        int32_t ***l_152 = &l_151;
    #####:  135:        int16_t *l_155 = &g_53;
    #####:  136:        (*g_58) ^= ((((l_115 == ((void *)0 != &g_106)) >= ((((*l_150) = l_149) == ((*l_152) = l_151)) != (((safe_rshift_func_int8_t_s_s(((l_155 != (g_156, l_157)) || l_56[0][1]), g_13)) < (*g_94)) && 18446744073709551614UL))) != 65530UL) ^ 0xBAEA5EAFL);
    #####:  137:        (*g_100) = (0x072EL || (l_158 == ((((*g_74) >= g_71), ((void *)0 != &l_55[0][1][1])), &g_94)));
        -:  138:      } else {
    #####:  139:        uint32_t l_167 = 9UL;
    #####:  140:        uint64_t l_169 = 0x3A2A3A725CFA702CLL;
    #####:  141:        (*l_151) = (*g_99);
    #####:  142:        l_127 |= (safe_lshift_func_uint32_t_u_s(((safe_add_func_int32_t_s_s(((0L > ((**l_151) ^= ((!l_164[0]) | ((((0L && (((g_34[2], &g_13) == &l_6) >= (safe_div_func_uint32_t_u_u((((*g_58), &g_58) != &g_100), l_167)))) <= 0x7A7AL), l_167), 0xA5094A51L)))) < l_9), l_168)) == (*g_58)), l_169));
        -:  143:      }
        -:  144:    }
        -:  145:  } else {
    #####:  146:    int32_t *l_170 = &l_56[0][1];
    #####:  147:    (*l_170) ^= (**g_99);
        -:  148:  }
        1:  149:  return g_95;
        -:  150:}
        -:  151:
        1:  152:static int64_t func_2(uint64_t p_3, uint32_t p_4, int32_t p_5) {
        1:  153:  uint16_t l_51 = 0UL;
       1*:  154:  for (p_4 = 17; (p_4 > 34); p_4 = safe_add_func_uint32_t_u_u(p_4, 9)) {
    #####:  155:    uint16_t l_30 = 0xD4A7L;
    #####:  156:    uint8_t *l_44 = &g_13;
    #####:  157:    int8_t *l_49 = &g_50;
        -:  158:    int16_t *l_52[5];
    #####:  159:    int32_t l_54 = (-1L);
        -:  160:    int i;
    #####:  161:    for (i = 0; i < 5; i++)
    #####:  162:      l_52[i] = &g_53;
        -:  163:  }
        1:  164:  return p_4;
        -:  165:}
        -:  166:
        1:  167:int main(int argc, char *argv[]) {
        -:  168:  int i;
        1:  169:  int print_hash_value = 0;
       1*:  170:  if (argc == 2 && strcmp(argv[1], "1") == 0)
    #####:  171:    print_hash_value = 1;
        1:  172:  platform_main_begin();
        1:  173:  crc32_gentab();
        1:  174:  func_1();
        6:  175:  for (i = 0; i < 5; i++) {
        5:  176:    transparent_crc(g_11[i].f0, "g_11[i].f0", print_hash_value);
        5:  177:    if (print_hash_value)
    #####:  178:      printf("index = [%d]\n", i);
        -:  179:  }
        1:  180:  transparent_crc(g_13, "g_13", print_hash_value);
        1:  181:  transparent_crc(g_14, "g_14", print_hash_value);
        6:  182:  for (i = 0; i < 5; i++) {
        5:  183:    transparent_crc(g_34[i].f0, "g_34[i].f0", print_hash_value);
        5:  184:    if (print_hash_value)
    #####:  185:      printf("index = [%d]\n", i);
        -:  186:  }
        1:  187:  transparent_crc(g_50, "g_50", print_hash_value);
        1:  188:  transparent_crc(g_53, "g_53", print_hash_value);
        5:  189:  for (i = 0; i < 4; i++) {
        4:  190:    transparent_crc(g_59[i], "g_59[i]", print_hash_value);
        4:  191:    if (print_hash_value)
    #####:  192:      printf("index = [%d]\n", i);
        -:  193:  }
        1:  194:  transparent_crc(g_71, "g_71", print_hash_value);
        1:  195:  transparent_crc(g_75, "g_75", print_hash_value);
        1:  196:  transparent_crc(g_82, "g_82", print_hash_value);
        1:  197:  transparent_crc(g_86.f0, "g_86.f0", print_hash_value);
        1:  198:  transparent_crc(g_88, "g_88", print_hash_value);
        1:  199:  transparent_crc(g_95, "g_95", print_hash_value);
        1:  200:  transparent_crc(g_97.f0, "g_97.f0", print_hash_value);
        1:  201:  transparent_crc(g_106, "g_106", print_hash_value);
        1:  202:  transparent_crc(g_156.f0, "g_156.f0", print_hash_value);
        1:  203:  platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
        1:  204:  return 0;
        -:  205:}
