// Options:   --concise --max-struct-fields 5 --max-funcs 2 --max-array-len-per-dim 5 --max-block-depth 3 --max-block-size 2
#include "csmith.h"

static long __undefined;

#pragma pack(push)
#pragma pack(1)
struct S0 {
  uint8_t f0;
  volatile int64_t f1;
};
#pragma pack(pop)

#pragma pack(push)
#pragma pack(1)
struct S2 {
  volatile signed f0 : 29;
  volatile unsigned : 0;
  const signed f1 : 7;
};
#pragma pack(pop)

union U4 {
  uint32_t f0;
};

static int32_t g_2 = 0L;
static int8_t g_26 = (-1L);
static uint8_t g_31 = 0x86L;
static uint32_t g_39 = 4UL;
static const struct S2 g_40 = {4692, -4};
static uint8_t *g_51 = &g_31;
static uint8_t **g_50 = &g_51;
static int32_t g_63 = 0xF1B003BAL;
static int32_t *volatile g_62[3][3][4] = {{{&g_63, &g_63, &g_63, &g_63}, {&g_63, &g_63, &g_63, &g_63}, {&g_63, &g_63, &g_63, &g_63}}, {{&g_63, &g_63, &g_63, &g_63}, {&g_63, &g_63, &g_63, &g_63}, {&g_63, &g_63, &g_63, &g_63}}, {{&g_63, &g_63, &g_63, &g_63}, {&g_63, &g_63, &g_63, &g_63}, {&g_63, &g_63, &g_63, &g_63}}};
static int8_t g_65[3][1] = {{6L}, {6L}, {6L}};
static volatile struct S0 g_67[2] = {{0UL, 0x3638B4FD08915CC6LL}, {0UL, 0x3638B4FD08915CC6LL}};
static uint16_t g_79[2] = {1UL, 1UL};
static struct S0 g_93 = {0x4EL, 0L};
static int32_t *volatile g_98 = (void *)0;
static const uint8_t ***volatile g_101 = (void *)0;
static const uint8_t ***volatile g_102 = (void *)0;
static union U4 g_116 = {4294967289UL};
static int32_t g_134[3][2] = {{0x93C2DF58L, 0x93C2DF58L}, {0x93C2DF58L, 0x93C2DF58L}, {0x93C2DF58L, 0x93C2DF58L}};

static const uint32_t func_1(void);
static int32_t func_6(uint32_t p_7, int16_t p_8, uint32_t p_9);

static const uint32_t func_1(void) {
  int32_t l_41 = 0x49EF57A5L;
  const uint8_t *l_111 = &g_31;
  const uint8_t **l_110 = &l_111;
  const uint8_t ***l_109 = &l_110;
  for (g_2 = 0; (g_2 < (-29)); g_2 = safe_sub_func_int64_t_s_s(g_2, 1)) {
    union U4 l_5 = {4294967293UL};
    int32_t l_32 = 0x9CEA445AL;
    int64_t l_77 = 0x2358CEDF6E77A780LL;
    if ((l_5, l_5.f0)) {
      uint64_t l_29 = 0xF0F5EBEC5EC62BB2LL;
      uint8_t *l_30[2];
      int i;
      for (i = 0; i < 2; i++)
        l_30[i] = &g_31;
      if (func_6((safe_add_func_int32_t_s_s((safe_mod_func_int16_t_s_s((safe_lshift_func_int16_t_s_u(8L, 13)), (safe_sub_func_uint16_t_u_u(g_2, (safe_add_func_int8_t_s_s((safe_div_func_int64_t_s_s(((safe_div_func_int64_t_s_s((safe_div_func_int32_t_s_s((g_26 = (-1L)), (((safe_mul_func_uint8_t_u_u((l_32 = l_29), (safe_rshift_func_int64_t_s_u(((safe_div_func_int8_t_s_s(0x99L, ((g_2 == (((((g_39 = (g_31 = (safe_rshift_func_uint8_t_u_s(g_31, 3)))) > 0L) || (g_40, g_31)) && l_41) >= l_5.f0)) & g_2))) | 0L), 42)))) < 255UL) ^ l_41))), g_2)), l_29), l_5.f0)), g_2)))))), 3L)), g_40.f1, g_40.f1)) {
        int32_t *l_66 = &g_63;
        (*l_66) = (&g_51 != &l_30[1]);
      } else {
        volatile struct S0 *l_68 = &g_67[0];
        (*l_68) = g_67[0];
      }
    } else {
      const uint8_t *l_84[3];
      struct S0 *l_92 = &g_93;
      int32_t l_100 = 0x1E7967B2L;
      const uint8_t **l_104 = &l_84[0];
      const uint8_t ***l_103 = &l_104;
      int i;
      for (i = 0; i < 3; i++)
        l_84[i] = (void *)0;
      for (l_5.f0 = 0; (l_5.f0 >= 27); l_5.f0 = safe_add_func_int64_t_s_s(l_5.f0, 1)) {
        uint8_t ***const l_74[3][5][5] = {{{&g_50, &g_50, (void *)0, (void *)0, &g_50}, {(void *)0, &g_50, &g_50, &g_50, (void *)0}, {(void *)0, &g_50, &g_50, &g_50, &g_50}, {&g_50, &g_50, &g_50, &g_50, (void *)0}, {&g_50, &g_50, (void *)0, &g_50, (void *)0}}, {{&g_50, &g_50, (void *)0, (void *)0, &g_50}, {&g_50, &g_50, &g_50, &g_50, &g_50}, {&g_50, &g_50, &g_50, &g_50, &g_50}, {&g_50, &g_50, &g_50, &g_50, &g_50}, {(void *)0, &g_50, &g_50, &g_50, &g_50}}, {{(void *)0, &g_50, (void *)0, &g_50, &g_50}, {&g_50, (void *)0, &g_50, (void *)0, &g_50}, {&g_50, &g_50, &g_50, (void *)0, (void *)0}, {&g_50, &g_50, &g_50, &g_50, (void *)0}, {&g_50, &g_50, (void *)0, &g_50, &g_50}}};
        uint16_t *l_78 = &g_79[1];
        int32_t l_91 = 0x2F93B9B4L;
        int8_t *l_94 = (void *)0;
        int8_t *l_95 = &g_65[2][0];
        int32_t *l_96 = (void *)0;
        int32_t *l_97 = &l_91;
        int32_t *l_99[1];
        int i, j, k;
        for (i = 0; i < 1; i++)
          l_99[i] = &g_63;
        l_100 = ((*l_97) = (!(((g_26 = ((safe_rshift_func_int8_t_s_s((g_65[1][0] = (l_74[0][3][1] == &g_50)), 0)), (g_65[2][0], ((*l_95) = ((((safe_lshift_func_uint64_t_u_u((l_77 && ((*l_78)--)), (safe_lshift_func_int8_t_s_u(l_32, 5)))) | ((l_84[0] == ((*g_50) = (*g_50))) > (((safe_mul_func_int16_t_s_s(((safe_div_func_int16_t_s_s((safe_mod_func_uint8_t_u_u(((l_91, 0xEDL) < 0x58L), g_26)), (-1L))) || l_5.f0), l_41)) <= l_91) != g_31))), l_92) != (void *)0))))) || l_41) & g_40.f1)));
      }
      (*l_103) = (l_100, &l_84[0]);
    }
  }
  for (g_2 = 0; (g_2 >= 0); --g_2) {
    const int8_t *l_121 = &g_65[0][0];
    int32_t l_122 = 0L;
    if (((safe_lshift_func_uint16_t_u_s((l_109 != (void *)0), ((((safe_lshift_func_int32_t_s_s(((safe_div_func_int32_t_s_s(((g_93.f1 < (g_116, (safe_add_func_int16_t_s_s((safe_lshift_func_uint32_t_u_s(((0L >= (((void *)0 != l_121) != ((l_41, (l_41 ^ g_65[0][0])) <= g_40.f1))) || 0x57E6E873L), 22)), 0x5F89L)))) & l_122), 0x77C28433L)) <= 0x81597F86L), g_2)) && l_122) > (*g_51)) || l_41))), 0x6E94FA07L)) {
      int64_t l_123[3][4] = {{0L, 0L, 0x5127A50812B24AB7LL, 0L}, {0L, (-4L), (-4L), 0L}, {(-4L), 0L, (-4L), (-4L)}};
      int32_t *l_124[3];
      int i, j;
      for (i = 0; i < 3; i++)
        l_124[i] = &l_122;
      l_41 |= l_123[1][0];
    } else {
      const int32_t l_129 = 0xE4B147B7L;
      int32_t *l_132 = (void *)0;
      int32_t *l_133 = &g_134[0][1];
      (*l_133) |= (g_67[0].f0 & (((1L ^ l_41) >= ((safe_mul_func_int16_t_s_s(l_122, l_41)) && (safe_lshift_func_uint32_t_u_s(l_129, (0x08170AE80B3DF572LL <= (safe_rshift_func_uint8_t_u_s((0x389EL > 0x1A11L), g_63))))))) && l_122));
    }
    if (l_122)
      continue;
  }
  return g_63;
}

static int32_t func_6(uint32_t p_7, int16_t p_8, uint32_t p_9) {
  uint8_t *l_47 = &g_31;
  uint8_t **l_46 = &l_47;
  uint8_t *l_48 = &g_31;
  int32_t l_49 = 0x1B546539L;
  uint8_t ***l_52[4][1][1];
  uint8_t **l_53 = &g_51;
  uint8_t **l_58[3];
  int32_t l_61[4];
  int32_t l_64 = (-2L);
  int i, j, k;
  for (i = 0; i < 4; i++) {
    for (j = 0; j < 1; j++) {
      for (k = 0; k < 1; k++)
        l_52[i][j][k] = &g_50;
    }
  }
  for (i = 0; i < 3; i++)
    l_58[i] = &l_48;
  for (i = 0; i < 4; i++)
    l_61[i] = 1L;
  l_64 &= ((((safe_sub_func_uint16_t_u_u((g_2 & (((*l_46) = &g_31) != l_48)), l_49)) < (&l_48 == (l_53 = g_50))) > ((safe_rshift_func_uint8_t_u_u((safe_lshift_func_int16_t_s_u((&g_51 != l_58[2]), (((((safe_rshift_func_uint8_t_u_u((l_61[3] ^= (*g_51)), 0)), (*g_50)) != (*g_50)) >= (*g_51)), g_39))), (*g_51))) < l_49)) > l_49);
  return g_65[2][0];
}

int main(int argc, char *argv[]) {
  int i, j, k;
  int print_hash_value = 0;
  if (argc == 2 && strcmp(argv[1], "1") == 0)
    print_hash_value = 1;
  platform_main_begin();
  crc32_gentab();
  func_1();
  transparent_crc(g_2, "g_2", print_hash_value);
  transparent_crc(g_26, "g_26", print_hash_value);
  transparent_crc(g_31, "g_31", print_hash_value);
  transparent_crc(g_39, "g_39", print_hash_value);
  transparent_crc(g_40.f0, "g_40.f0", print_hash_value);
  transparent_crc(g_40.f1, "g_40.f1", print_hash_value);
  transparent_crc(g_63, "g_63", print_hash_value);
  for (i = 0; i < 3; i++) {
    for (j = 0; j < 1; j++) {
      transparent_crc(g_65[i][j], "g_65[i][j]", print_hash_value);
      if (print_hash_value)
        printf("index = [%d][%d]\n", i, j);
    }
  }
  for (i = 0; i < 2; i++) {
    transparent_crc(g_67[i].f0, "g_67[i].f0", print_hash_value);
    transparent_crc(g_67[i].f1, "g_67[i].f1", print_hash_value);
    if (print_hash_value)
      printf("index = [%d]\n", i);
  }
  for (i = 0; i < 2; i++) {
    transparent_crc(g_79[i], "g_79[i]", print_hash_value);
    if (print_hash_value)
      printf("index = [%d]\n", i);
  }
  transparent_crc(g_93.f0, "g_93.f0", print_hash_value);
  transparent_crc(g_93.f1, "g_93.f1", print_hash_value);
  transparent_crc(g_116.f0, "g_116.f0", print_hash_value);
  for (i = 0; i < 3; i++) {
    for (j = 0; j < 2; j++) {
      transparent_crc(g_134[i][j], "g_134[i][j]", print_hash_value);
      if (print_hash_value)
        printf("index = [%d][%d]\n", i, j);
    }
  }
  platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
  return 0;
}
