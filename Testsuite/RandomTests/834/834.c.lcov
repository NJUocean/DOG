/root/TSE2022/testsuite/RTEF/834/834.c:
    1|       |// Options:   --concise --max-struct-fields 5 --max-funcs 2 --max-array-len-per-dim 5 --max-block-depth 3 --max-block-size 2
    2|       |#include "csmith.h"
    3|       |
    4|       |static long __undefined;
    5|       |
    6|       |static volatile uint64_t g_2 = 18446744073709551615UL;
    7|       |static int8_t g_21 = 0xE0L;
    8|       |static uint32_t g_31[3] = {4294967295UL, 4294967295UL, 4294967295UL};
    9|       |static uint8_t g_60 = 1UL;
   10|       |static uint32_t g_65 = 4294967288UL;
   11|       |static int32_t g_67 = (-2L);
   12|       |static int16_t g_77 = 0x6E27L;
   13|       |static int16_t g_88 = 1L;
   14|       |static int16_t *g_87 = &g_88;
   15|       |static uint32_t g_91 = 5UL;
   16|       |static int64_t g_93 = (-1L);
   17|       |static int8_t g_119[3][1][1] = {{{0x83L}}, {{0x83L}}, {{0x83L}}};
   18|       |static int16_t g_120 = (-8L);
   19|       |static uint64_t g_142 = 0x31B5FDDB278982BFLL;
   20|       |static uint8_t g_147 = 255UL;
   21|       |static int32_t g_157 = (-7L);
   22|       |static volatile int32_t g_158[3] = {0x2B768FFDL, 0x2B768FFDL, 0x2B768FFDL};
   23|       |static uint32_t g_159 = 0x13E0D8C1L;
   24|       |static uint16_t g_179 = 1UL;
   25|       |static uint64_t g_185 = 0UL;
   26|       |static uint8_t g_208[5][1][1] = {{{1UL}}, {{1UL}}, {{1UL}}, {{1UL}}, {{1UL}}};
   27|       |static volatile uint16_t g_258 = 1UL;
   28|       |static int32_t *volatile g_291 = (void *)0;
   29|       |static int32_t g_303 = 0x92736123L;
   30|       |static int32_t *volatile g_302 = &g_303;
   31|       |static uint64_t *volatile g_315 = &g_185;
   32|       |static uint64_t *volatile *volatile g_314 = &g_315;
   33|       |
   34|       |static uint32_t func_1(void);
   35|       |static int16_t func_7(int16_t p_8, uint64_t p_9);
   36|       |
   37|      1|static uint32_t func_1(void) {
   38|      1|  const uint16_t l_18 = 0x6D4AL;
   39|      1|  uint8_t l_33 = 0xA9L;
   40|      1|  const int32_t *l_229[3][3][5] = {{{&g_67, &g_67, &g_67, &g_67, (void *)0}, {(void *)0, &g_67, &g_67, &g_67, &g_67}, {(void *)0, &g_67, (void *)0, &g_67, (void *)0}}, {{&g_67, (void *)0, (void *)0, &g_67, &g_67}, {(void *)0, (void *)0, &g_67, &g_67, (void *)0}, {(void *)0, &g_67, (void *)0, (void *)0, &g_67}}, {{&g_67, &g_67, (void *)0, &g_67, (void *)0}, {&g_67, &g_67, &g_67, (void *)0, (void *)0}, {&g_67, (void *)0, (void *)0, (void *)0, (void *)0}}};
   41|      1|  uint8_t l_236 = 249UL;
   42|      1|  int32_t l_256 = (-1L);
   43|      1|  int32_t l_257 = 0x4D7D783DL;
   44|      1|  const int8_t l_286 = 0x05L;
   45|      1|  uint16_t l_288 = 65531UL;
   46|      1|  const uint64_t l_294 = 0xB0DCBC0DA51562CALL;
   47|      1|  int16_t l_351 = 0xDCD4L;
   48|      1|  int i, j, k;
   49|      1|  if (g_2) {
   50|      1|    int32_t l_24 = 0xAF5BFB66L;
   51|      1|    uint32_t *l_30[4];
   52|      1|    int64_t l_32 = 0x8BBE26B5CFDA6C2ELL;
   53|      1|    int32_t l_283[3];
   54|      1|    int8_t l_295 = (-2L);
   55|      1|    int32_t *l_327 = (void *)0;
   56|      1|    int32_t **l_326 = &l_327;
   57|      1|    int i;
   58|      5|    for (i = 0; i < 4; i++)
   59|      4|      l_30[i] = &g_31[2];
   60|      4|    for (i = 0; i < 3; i++)
   61|      3|      l_283[i] = (-8L);
   62|      1|    if ((safe_mod_func_int8_t_s_s(((safe_lshift_func_int16_t_s_u(func_7(g_2, (safe_add_func_uint16_t_u_u(((safe_div_func_uint32_t_u_u(((((safe_lshift_func_uint8_t_u_u(((safe_rshift_func_int16_t_s_u(l_18, l_18)) >= ((safe_mul_func_uint8_t_u_u((g_21 > (((safe_lshift_func_uint8_t_u_s(l_24, 6)) && ((((l_18 < (safe_lshift_func_uint64_t_u_s((g_21 != ((((g_31[2] |= (safe_div_func_int8_t_s_s((((+1L) == 0x7B1466ACL) <= 0x0813C27F355C0C8FLL), l_24))) == l_18) == l_32) & l_33)), g_21))) | g_21) == l_32) <= g_21)) | g_21)), l_33)) ^ l_24)), l_24)) && g_31[0]), l_24), l_24), l_24)) == 0xDDBB7A2E255BB5FBLL), g_21))), 3)) > 0x18L), l_24))) {
   63|      0|      uint64_t l_216 = 18446744073709551615UL;
   64|      0|      uint8_t *l_234 = &l_33;
   65|      0|      uint64_t *l_235[5][1][5];
   66|      0|      int32_t *l_248 = &g_157;
   67|      0|      int32_t **l_247 = &l_248;
   68|      0|      int32_t *l_249 = &l_24;
   69|      0|      int32_t *l_250 = &g_67;
   70|      0|      int32_t *l_251 = &g_67;
   71|      0|      int32_t *l_252 = &l_24;
   72|      0|      int32_t l_253[4] = {0L, 0L, 0L, 0L};
   73|      0|      int32_t *l_254 = &l_253[1];
   74|      0|      int32_t *l_255[4][4][1] = {{{&l_24}, {&l_24}, {&l_24}, {&l_24}}, {{&l_24}, {&l_24}, {&l_24}, {&l_24}}, {{&l_24}, {&l_24}, {&l_24}, {&l_24}}, {{&l_24}, {&l_24}, {&l_24}, {&l_24}}};
   75|      0|      int i, j, k;
   76|      0|      for (i = 0; i < 5; i++) {
   77|      0|        for (j = 0; j < 1; j++) {
   78|      0|          for (k = 0; k < 5; k++)
   79|      0|            l_235[i][j][k] = &g_185;
   80|      0|        }
   81|      0|      }
   82|      0|      l_24 = ((safe_lshift_func_uint16_t_u_u(l_216, g_142)) ^
   83|      0|              (safe_add_func_int64_t_s_s(((safe_div_func_uint32_t_u_u(((safe_div_func_int8_t_s_s(((safe_div_func_int8_t_s_s(((safe_sub_func_uint16_t_u_u((safe_div_func_uint8_t_u_u((((((void *)0 == l_229[0][1][3]) | (((safe_add_func_uint64_t_u_u((l_236 = (safe_lshift_func_uint64_t_u_u((((*l_234) = 247UL) == g_120), 3))), (((*l_247) = ((safe_mul_func_uint8_t_u_u((g_31[2], ((safe_lshift_func_uint64_t_u_u(((safe_add_func_int8_t_s_s((safe_lshift_func_uint16_t_u_s((safe_div_func_uint64_t_u_u((4294967286UL > g_67), l_216)), 3)), g_31[2])) < (*g_87)), l_24)) == l_216)), l_216)), l_30[0])) != (void *)0))), 1UL) >= 0xC5L)) != 0xFDA0F33844FDB9DDLL) == g_65), g_88)), (*g_87))) == g_2), 0x22L)), g_158[1]), 0x48L)) | (*g_87)), (-1L))) & g_31[0]), 0x4D477D6962B2ED70LL)));
   84|      0|      ++g_258;
   85|      1|    } else {
   86|      1|      int8_t *const l_263[5] = {&g_21, &g_21, &g_21, &g_21, &g_21};
   87|      1|      int32_t l_276 = 2L;
   88|      1|      uint16_t *l_284 = (void *)0;
   89|      1|      uint16_t *l_285 = &g_179;
   90|      1|      const int32_t l_287 = 0xB484F157L;
   91|      1|      int64_t *l_289 = &l_32;
   92|      1|      int16_t l_325 = 0xB874L;
   93|      1|      int32_t **l_328[2][3] = {{&l_327, &l_327, &l_327}, {&l_327, &l_327, &l_327}};
   94|      1|      int32_t l_329 = 0xF4D6A387L;
   95|      1|      int i, j;
   96|      1|      if (((g_208[2][0][0] && (((*l_289) = (safe_rshift_func_uint8_t_u_s(((&g_21 == l_263[1]) | ((((safe_mul_func_int16_t_s_s((safe_div_func_uint16_t_u_u(g_208[0][0][0], (safe_mul_func_int16_t_s_s(((safe_sub_func_int8_t_s_s((((*l_285) = (safe_lshift_func_uint16_t_u_u((((l_276 | (safe_mod_func_int8_t_s_s((safe_mod_func_uint16_t_u_u(g_158[1], (-2L))), ((l_283[0] &= (g_31[2] |= (safe_lshift_func_int64_t_s_u((l_263[0] == &g_119[0][0][0]), g_60)))), g_179)))), 3L) <= g_208[4][0][0]), l_276))) | l_286), l_32)) >= 0xC7L), l_287)))), l_32)) >= 0xA95C22D9L) | l_288) & 0UL)), 4))) >= g_120)) >= 1UL)) {
   97|      1|        int32_t l_290 = 0x682D7458L;
   98|      1|        l_276 = l_290;
   99|      1|      } else {
  100|      0|        uint64_t l_300 = 0UL;
  101|      0|        int32_t *l_301 = &g_67;
  102|      0|        (*g_302) = ((*l_301) = (g_91, (g_60, ((l_24 &= (0x5955131BL == ((safe_lshift_func_int32_t_s_u(((((*g_87) <= (l_294 < l_295)) <= (((safe_rshift_func_uint64_t_u_s(7UL, 52)), (((safe_add_func_int32_t_s_s(((((((g_2 && l_32) == 0x90L) != g_208[2][0][0]) | 0UL) | (*g_87)), l_276), g_21)) || 0L) != g_159)) & 0x0B3DL)), 0x641BD3BCL), l_300)) > g_65))) <= 0x5FA1L))));
  103|      0|      }
  104|      1|      g_67 ^= (l_24 = ((*g_302) = (safe_add_func_uint32_t_u_u(((safe_div_func_uint64_t_u_u(((((((*l_289) = (safe_div_func_int64_t_s_s((safe_div_func_int16_t_s_s(((l_287 < ((safe_rshift_func_int8_t_s_s(((g_314 != (void *)0) == (safe_lshift_func_uint16_t_u_s(l_276, (safe_add_func_uint8_t_u_u(((((((l_283[2] < (!l_276)) == ((safe_div_func_int8_t_s_s((((*g_87) | (((safe_div_func_uint32_t_u_u(((((g_91 = l_287) == (0xBF62L <= l_295)) < 0xA182L), l_287), l_325)), l_287) < 0xDDL)) >= 3UL), (-1L))) ^ g_208[2][0][0])) == l_276), g_303), l_326) != l_328[1][0]), g_65))))), 1)) & 1UL)), 0x4F0EL), (*g_87))), g_119[0][0][0]))), l_329) >= (*g_87)) > g_65), (*g_315)), g_119[0][0][0])) && 0x6D18L), 0x1EC6C1B3L))));
  105|      1|    }
  106|      1|  } else {
  107|      0|    int32_t *l_332 = (void *)0;
  108|      0|    int32_t *l_333 = &g_67;
  109|      0|    (*l_333) = (1UL && ((safe_rshift_func_uint16_t_u_u(0xBC2AL, 1)) > (1L || g_120)));
  110|      0|    for (g_91 = 0; (g_91 == 23); g_91 = safe_add_func_int8_t_s_s(g_91, 4)) {
  111|      0|      int64_t l_336 = 0x479D91489F91F7C5LL;
  112|      0|      int32_t *l_342 = &l_256;
  113|      0|      int16_t l_353 = 0L;
  114|      0|      if ((((*g_315) == l_336) ^ (-7L))) {
  115|      0|        int32_t **l_337 = &l_333;
  116|      0|        int32_t l_352 = 0xBA7A7D87L;
  117|      0|        uint16_t *l_354 = &l_288;
  118|      0|        int32_t *l_355 = &l_257;
  119|      0|        (*l_337) = (void *)0;
  120|      0|        (*l_355) &= (((*l_354) |= (((*g_87) = ((((safe_rshift_func_uint8_t_u_s((g_303 != (*g_87)), 7)) > 0x7B4EDF28120CE1A1LL) != ((safe_mul_func_uint32_t_u_u(((void *)0 != &g_179), ((*l_337) == l_342))) != ((safe_add_func_uint64_t_u_u((safe_lshift_func_int16_t_s_u(((safe_mul_func_int32_t_s_s(((g_158[1] < (safe_div_func_int16_t_s_s((((g_185 &= ((g_208[2][0][0] < g_65) != l_351)), 0x4C57L) ^ (-4L)), 0xB972L))) > l_352), g_208[2][0][0])), (*g_87)), g_157)), g_91)) | (*l_342)))) ^ l_353)) ^ g_120)), (*g_302));
  121|      0|      } else {
  122|      0|        int32_t **l_356[2][2];
  123|      0|        int i, j;
  124|      0|        for (i = 0; i < 2; i++) {
  125|      0|          for (j = 0; j < 2; j++)
  126|      0|            l_356[i][j] = &l_332;
  127|      0|        }
  128|      0|        l_229[0][1][3] = &l_257;
  129|      0|      }
  130|      0|      for (g_157 = 0; (g_157 >= 0); g_157 -= 1) {
  131|      0|        int32_t *l_357 = &l_257;
  132|      0|        g_291 = l_357;
  133|      0|        (*g_291) &= ((g_31[0] >= g_67) || (*l_342));
  134|      0|      }
  135|      0|    }
  136|      0|  }
  137|      1|  return g_93;
  138|      1|}
  139|       |
  140|      1|static int16_t func_7(int16_t p_8, uint64_t p_9) {
  141|      1|  uint32_t l_40 = 4294967295UL;
  142|      1|  uint8_t *l_59 = &g_60;
  143|      1|  int32_t *l_66 = &g_67;
  144|      1|  int16_t *const l_89 = &g_88;
  145|      1|  int64_t *l_143 = &g_93;
  146|      1|  int32_t l_150 = 0x2206DCC1L;
  147|      1|  int64_t l_193 = (-3L);
  148|      1|  if ((p_8 & ((safe_lshift_func_uint8_t_u_u((safe_mod_func_int32_t_s_s(((*l_66) ^= (g_31[2] != (((safe_mod_func_int16_t_s_s(l_40, p_9)) < ((l_40 <= (safe_rshift_func_uint64_t_u_u((safe_rshift_func_uint16_t_u_u(p_9, 2)), (safe_div_func_uint8_t_u_u((((safe_sub_func_int16_t_s_s(0x1ACAL, (safe_add_func_int16_t_s_s(((safe_add_func_int16_t_s_s(g_21, (safe_add_func_uint8_t_u_u((safe_rshift_func_uint16_t_u_s(((g_65 = (safe_rshift_func_uint64_t_u_u(((((*l_59)++) <= (safe_mul_func_int16_t_s_s((-1L), l_40))) >= 65535UL), 22))) > l_40), 4)), p_8)))), p_9), g_21)))), &g_65) != (void *)0), 255UL))))) >= p_9)) == g_2))), g_21)), 5)) <= 0x1AB70486D4D44114LL))) {
  149|      1|    int32_t *l_80 = &g_67;
  150|      1|    int32_t *l_83[4] = {&g_67, &g_67, &g_67, &g_67};
  151|      1|    const uint32_t l_149[2][4] = {{0x08A63556L, 0x08A63556L, 0x08A63556L, 0x08A63556L}, {0x08A63556L, 0x08A63556L, 0x08A63556L, 0x08A63556L}};
  152|      1|    int i, j;
  153|      1|    if (g_65) {
  154|      0|      int16_t *l_76 = &g_77;
  155|      0|      int32_t **l_81 = (void *)0;
  156|      0|      int32_t **l_82 = (void *)0;
  157|      0|      uint64_t *l_90 = (void *)0;
  158|      0|      int64_t *l_92 = &g_93;
  159|      0|      (*l_66) = (((((*l_92) = (safe_sub_func_int64_t_s_s((safe_sub_func_int8_t_s_s((((safe_add_func_uint8_t_u_u(g_21, g_2)) > ((*l_76) ^= 0x6F3AL)), p_9), ((safe_lshift_func_int8_t_s_s((l_80 != (l_83[3] = l_80)), 1)) | (p_8 ^ (((g_91 |= (safe_rshift_func_uint64_t_u_u(((safe_unary_minus_func_int8_t_s((g_87 != l_89))) || g_67), 9))) != p_9), g_31[1]))))), p_8))) & 0L) ^ g_67) <= 0L);
  160|      0|      if (g_67) {
  161|      0|        int32_t *l_111 = (void *)0;
  162|      0|        int8_t *l_116 = &g_21;
  163|      0|        int8_t *l_117 = (void *)0;
  164|      0|        int8_t *l_118[4];
  165|      0|        int32_t l_121 = 0xCBA4768EL;
  166|      0|        int i;
  167|      0|        for (i = 0; i < 4; i++)
  168|      0|          l_118[i] = &g_119[0][0][0];
  169|      0|        l_121 |= (safe_mul_func_uint64_t_u_u((((~g_67) == ((safe_add_func_int8_t_s_s((g_120 &= (((safe_add_func_uint64_t_u_u((safe_mod_func_int64_t_s_s((g_21 && (safe_lshift_func_uint8_t_u_u((((safe_add_func_int8_t_s_s(((((((g_119[0][0][0] = ((*l_116) = (safe_mul_func_int32_t_s_s(((safe_mod_func_uint8_t_u_u((((((((g_31[2] == 18446744073709551607UL), l_111) == (g_31[2], l_111)), (((safe_mod_func_int64_t_s_s((safe_div_func_uint32_t_u_u(p_8, 0xE5819C35L)), g_65)) > (-6L)) | g_67)), &p_8) != &p_8) && (*l_66)), 0xD4L)) && g_65), g_93)))) <= 4UL) == (*l_66)) > 18446744073709551615UL) ^ 0x8767L) ^ 0x049D9BB2L), (-1L))) >= 0x082E2804L) && 1L), 3))), (-5L))), p_9)), l_118[1]) != l_59)), 2L)) == p_8)), 1UL), g_2));
  170|      0|      } else {
  171|      0|        (*l_80) = (&g_93 != &g_93);
  172|      0|      }
  173|      1|    } else {
  174|      1|      int32_t l_132 = 0xB86B6EF1L;
  175|      1|      uint64_t *l_141[1];
  176|      1|      uint64_t **l_140 = &l_141[0];
  177|      1|      uint8_t *l_146 = &g_147;
  178|      1|      int8_t *l_148 = &g_119[1][0][0];
  179|      1|      int32_t l_151[3];
  180|      1|      int i;
  181|      2|      for (i = 0; i < 1; i++)
  182|      1|        l_141[i] = &g_142;
  183|      4|      for (i = 0; i < 3; i++)
  184|      3|        l_151[i] = (-5L);
  185|      1|      (*l_80) &= (safe_rshift_func_uint64_t_u_s((safe_add_func_int8_t_s_s((safe_mod_func_int32_t_s_s((safe_div_func_uint32_t_u_u((safe_add_func_uint32_t_u_u(l_132, ((safe_mul_func_uint64_t_u_u((!(safe_lshift_func_int8_t_s_s(((*l_148) |= (g_60 & (((safe_rshift_func_uint8_t_u_s((((*l_140) = &p_9) != &p_9), 1)) >= (l_143 == &g_93)), (safe_add_func_uint8_t_u_u(((*l_146) = ((void *)0 != l_66)), p_8))))), g_93))), (-8L))) & (-1L)))), l_149[0][3])), g_88)), p_8)), l_150));
  186|      1|      l_151[2] |= p_9;
  187|      1|    }
  188|      1|    (*l_66) = 0x64217F86L;
  189|      1|  } else {
  190|      0|    int32_t **l_152 = &l_66;
  191|      0|    uint8_t *l_181[4][4][5] = {{{&g_147, &g_147, (void *)0, &g_60, (void *)0}, {&g_147, &g_147, &g_147, &g_147, (void *)0}, {&g_147, &g_147, &g_147, &g_147, (void *)0}, {&g_147, &g_147, (void *)0, &g_60, &g_60}}, {{(void *)0, &g_147, &g_147, (void *)0, (void *)0}, {&g_60, &g_147, &g_60, &g_60, &g_147}, {&g_60, &g_147, (void *)0, &g_147, &g_60}, {&g_60, &g_147, &g_147, &g_147, &g_147}}, {{(void *)0, (void *)0, (void *)0, &g_60, &g_147}, {&g_147, &g_147, &g_60, &g_147, &g_147}, {&g_147, &g_60, &g_147, &g_147, &g_60}, {&g_147, &g_147, (void *)0, &g_60, &g_147}}, {{&g_147, (void *)0, &g_147, &g_147, (void *)0}, {&g_60, &g_147, &g_147, &g_147, &g_60}, {&g_147, &g_147, (void *)0, &g_60, (void *)0}, {&g_147, &g_147, &g_147, &g_147, (void *)0}}};
  192|      0|    int i, j, k;
  193|      0|    if ((g_21 >= (g_77 | ((l_152 == &l_66) & (p_9, (**l_152)))))) {
  194|      0|      uint16_t l_155[2];
  195|      0|      int i;
  196|      0|      for (i = 0; i < 2; i++)
  197|      0|        l_155[i] = 5UL;
  198|      0|      if ((safe_rshift_func_uint64_t_u_s(p_9, 30))) {
  199|      0|        (*l_152) = &l_150;
  200|      0|      } else {
  201|      0|        int32_t *l_156[3];
  202|      0|        int i;
  203|      0|        for (i = 0; i < 3; i++)
  204|      0|          l_156[i] = &g_67;
  205|      0|        (*l_66) = l_155[0];
  206|      0|        ++g_159;
  207|      0|      }
  208|      0|      for (g_60 = 0; (g_60 == 42); ++g_60) {
  209|      0|        return p_9;
  210|      0|      }
  211|      0|    } else {
  212|      0|      uint16_t *l_177 = (void *)0;
  213|      0|      uint16_t *l_178 = &g_179;
  214|      0|      uint32_t *l_180 = &g_91;
  215|      0|      int32_t l_182 = 0L;
  216|      0|      uint64_t *l_183 = (void *)0;
  217|      0|      uint64_t *l_184 = &g_185;
  218|      0|      int32_t l_186[1][3];
  219|      0|      int i, j;
  220|      0|      for (i = 0; i < 1; i++) {
  221|      0|        for (j = 0; j < 3; j++)
  222|      0|          l_186[i][j] = 0xDC658C38L;
  223|      0|      }
  224|      0|      l_186[0][1] ^= ((**l_152) = (safe_add_func_uint64_t_u_u(((((((0xFA79916B1FF0AA6ALL <= ((safe_div_func_uint32_t_u_u(g_67, 0x3B1C7E41L)) && 0x45FDL)), ((*l_184) &= (((safe_div_func_uint64_t_u_u(((safe_sub_func_int8_t_s_s((l_59 != (((*l_66) <= (((*l_180) = (~(((**l_152) | ((*l_178) = ((**l_152) || (safe_sub_func_int16_t_s_s((0xFEA9L <= p_9), p_8))))) ^ g_65))) <= g_119[2][0][0])), l_181[1][1][3])), g_142)) & (*l_66)), (*l_66))), 0x0EL) ^ l_182))) ^ p_8) == p_9), 0x85L), l_182), g_93)));
  225|      0|      (*l_66) |= l_186[0][1];
  226|      0|    }
  227|      0|  }
  228|      1|  for (g_93 = 3; (g_93 == 7); g_93 = safe_add_func_uint16_t_u_u(g_93, 8)) {
  229|      0|    uint16_t l_203[5][4][1] = {{{0UL}, {3UL}, {7UL}, {0xBBE7L}}, {{7UL}, {3UL}, {0UL}, {0x19CCL}}, {{0xC010L}, {0x19CCL}, {0UL}, {3UL}}, {{7UL}, {0xBBE7L}, {7UL}, {3UL}}, {{0UL}, {0x19CCL}, {0xC010L}, {0x19CCL}}};
  230|      0|    int32_t l_204 = (-1L);
  231|      0|    int i, j, k;
  232|      0|    for (g_147 = 0; (g_147 <= 0); g_147 += 1) {
  233|      0|      int64_t *l_198 = (void *)0;
  234|      0|      int64_t *l_199[5];
  235|      0|      int32_t l_200 = 0xEA2508C1L;
  236|      0|      int32_t *l_201 = (void *)0;
  237|      0|      int32_t *l_202[2][3] = {{(void *)0, (void *)0, (void *)0}, {&g_157, &g_157, &g_157}};
  238|      0|      uint64_t *l_212 = (void *)0;
  239|      0|      uint64_t **l_211 = &l_212;
  240|      0|      int i, j;
  241|      0|      for (i = 0; i < 5; i++)
  242|      0|        l_199[i] = &l_193;
  243|      0|      if (((2L & (g_31[(g_147 + 2)], p_9)) | (safe_sub_func_int32_t_s_s(3L, (safe_add_func_uint8_t_u_u(((l_193, (((safe_rshift_func_uint64_t_u_u(((0x38C0632B81410193LL || ((l_203[0][1][0] = ((l_200 ^= ((safe_lshift_func_uint8_t_u_s(g_31[(g_147 + 2)], 1)) | p_9)) | (((p_9 | p_8), 7L) <= (*g_87)))), 18446744073709551615UL)) >= g_119[0][0][0]), g_31[(g_147 + 2)])) & 0xEAL) >= (*l_66))) <= p_8), g_157)))))) {
  244|      0|        (*l_66) &= 0xC8820D8BL;
  245|      0|      } else {
  246|      0|        return l_204;
  247|      0|      }
  248|      0|      for (g_65 = 0; (g_65 <= 2); g_65 += 1) {
  249|      0|        int32_t *l_205 = &g_67;
  250|      0|        int32_t *l_206 = &l_200;
  251|      0|        int32_t *l_207 = &l_200;
  252|      0|        uint64_t ***l_213 = &l_211;
  253|      0|        ++g_208[2][0][0];
  254|      0|        (*l_213) = l_211;
  255|      0|      }
  256|      0|    }
  257|      0|  }
  258|      1|  return (*g_87);
  259|      1|}
  260|       |
  261|      1|int main(int argc, char *argv[]) {
  262|      1|  int i, j, k;
  263|      1|  int print_hash_value = 0;
  264|      1|  if (argc == 2 && strcmp(argv[1], "1") == 0)
  265|      0|    print_hash_value = 1;
  266|      1|  platform_main_begin();
  267|      1|  crc32_gentab();
  268|      1|  func_1();
  269|      1|  transparent_crc(g_2, "g_2", print_hash_value);
  270|      1|  transparent_crc(g_21, "g_21", print_hash_value);
  271|      4|  for (i = 0; i < 3; i++) {
  272|      3|    transparent_crc(g_31[i], "g_31[i]", print_hash_value);
  273|      3|    if (print_hash_value)
  274|      0|      printf("index = [%d]\n", i);
  275|      3|  }
  276|      1|  transparent_crc(g_60, "g_60", print_hash_value);
  277|      1|  transparent_crc(g_65, "g_65", print_hash_value);
  278|      1|  transparent_crc(g_67, "g_67", print_hash_value);
  279|      1|  transparent_crc(g_77, "g_77", print_hash_value);
  280|      1|  transparent_crc(g_88, "g_88", print_hash_value);
  281|      1|  transparent_crc(g_91, "g_91", print_hash_value);
  282|      1|  transparent_crc(g_93, "g_93", print_hash_value);
  283|      4|  for (i = 0; i < 3; i++) {
  284|      6|    for (j = 0; j < 1; j++) {
  285|      6|      for (k = 0; k < 1; k++) {
  286|      3|        transparent_crc(g_119[i][j][k], "g_119[i][j][k]", print_hash_value);
  287|      3|        if (print_hash_value)
  288|      0|          printf("index = [%d][%d][%d]\n", i, j, k);
  289|      3|      }
  290|      3|    }
  291|      3|  }
  292|      1|  transparent_crc(g_120, "g_120", print_hash_value);
  293|      1|  transparent_crc(g_142, "g_142", print_hash_value);
  294|      1|  transparent_crc(g_147, "g_147", print_hash_value);
  295|      1|  transparent_crc(g_157, "g_157", print_hash_value);
  296|      4|  for (i = 0; i < 3; i++) {
  297|      3|    transparent_crc(g_158[i], "g_158[i]", print_hash_value);
  298|      3|    if (print_hash_value)
  299|      0|      printf("index = [%d]\n", i);
  300|      3|  }
  301|      1|  transparent_crc(g_159, "g_159", print_hash_value);
  302|      1|  transparent_crc(g_179, "g_179", print_hash_value);
  303|      1|  transparent_crc(g_185, "g_185", print_hash_value);
  304|      6|  for (i = 0; i < 5; i++) {
  305|     10|    for (j = 0; j < 1; j++) {
  306|     10|      for (k = 0; k < 1; k++) {
  307|      5|        transparent_crc(g_208[i][j][k], "g_208[i][j][k]", print_hash_value);
  308|      5|        if (print_hash_value)
  309|      0|          printf("index = [%d][%d][%d]\n", i, j, k);
  310|      5|      }
  311|      5|    }
  312|      5|  }
  313|      1|  transparent_crc(g_258, "g_258", print_hash_value);
  314|      1|  transparent_crc(g_303, "g_303", print_hash_value);
  315|      1|  platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
  316|      1|  return 0;
  317|      1|}

/root/TSE2022/testsuite/RTEF/runtime/csmith.h:
    1|       |/* -*- mode: C -*-
    2|       | *
    3|       | * Copyright (c) 2007-2011, 2013, 2014 The University of Utah
    4|       | * All rights reserved.
    5|       | *
    6|       | * This file is part of `csmith', a random generator of C programs.
    7|       | *
    8|       | * Redistribution and use in source and binary forms, with or without
    9|       | * modification, are permitted provided that the following conditions are met:
   10|       | *
   11|       | *   * Redistributions of source code must retain the above copyright notice,
   12|       | *     this list of conditions and the following disclaimer.
   13|       | *
   14|       | *   * Redistributions in binary form must reproduce the above copyright
   15|       | *     notice, this list of conditions and the following disclaimer in the
   16|       | *     documentation and/or other materials provided with the distribution.
   17|       | *
   18|       | * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   19|       | * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   20|       | * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   21|       | * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
   22|       | * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   23|       | * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   24|       | * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   25|       | * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   26|       | * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   27|       | * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   28|       | * POSSIBILITY OF SUCH DAMAGE.
   29|       | */
   30|       |
   31|       |#ifndef RANDOM_RUNTIME_H
   32|       |#define RANDOM_RUNTIME_H
   33|       |
   34|       |#ifdef CSMITH_MINIMAL
   35|       |#include "csmith_minimal.h"
   36|       |#else
   37|       |
   38|       |/*****************************************************************************/
   39|       |
   40|       |#include <string.h>
   41|       |#include <float.h>
   42|       |#include <math.h>
   43|       |
   44|       |#define __STDC_LIMIT_MACROS
   45|       |#include "random_inc.h"
   46|       |
   47|       |static uint32_t crc32_tab[256];
   48|       |static uint32_t crc32_context = 0xFFFFFFFFUL;
   49|       |
   50|       |static void 
   51|       |crc32_gentab (void)
   52|      1|{
   53|      1|	uint32_t crc;
   54|      1|	const uint32_t poly = 0xEDB88320UL;
   55|      1|	int i, j;
   56|      1|	
   57|    257|	for (i = 0; i < 256; i++) {
   58|    256|		crc = i;
   59|  2.30k|		for (j = 8; j > 0; j--) {
   60|  2.04k|			if (crc & 1) {
   61|  1.02k|				crc = (crc >> 1) ^ poly;
   62|  1.02k|			} else {
   63|  1.02k|				crc >>= 1;
   64|  1.02k|			}
   65|  2.04k|		}
   66|    256|		crc32_tab[i] = crc;
   67|    256|	}
   68|      1|}
   69|       |
   70|       |static void 
   71|    256|crc32_byte (uint8_t b) {
   72|    256|	crc32_context = 
   73|    256|		((crc32_context >> 8) & 0x00FFFFFF) ^ 
   74|    256|		crc32_tab[(crc32_context ^ b) & 0xFF];
   75|    256|}
   76|       |
   77|       |#if defined(__SPLAT__) || defined(NO_LONGLONG)
   78|       |static void 
   79|       |crc32_8bytes (uint32_t val)
   80|       |{
   81|       |	crc32_byte ((val>>0) & 0xff);
   82|       |	crc32_byte ((val>>8) & 0xff);
   83|       |	crc32_byte ((val>>16) & 0xff);
   84|       |	crc32_byte ((val>>24) & 0xff);
   85|       |}
   86|       |
   87|       |static void 
   88|       |transparent_crc (uint32_t val, char* vname, int flag)
   89|       |{
   90|       |	crc32_8bytes(val);
   91|       |	if (flag) {
   92|       |  		printf("...checksum after hashing %s : %X\n", vname, crc32_context ^ 0xFFFFFFFFU);
   93|       |	}
   94|       |}
   95|       |#else
   96|       |static void 
   97|       |crc32_8bytes (uint64_t val)
   98|     32|{
   99|     32|	crc32_byte ((val>>0) & 0xff);
  100|     32|	crc32_byte ((val>>8) & 0xff);
  101|     32|	crc32_byte ((val>>16) & 0xff);
  102|     32|	crc32_byte ((val>>24) & 0xff);
  103|     32|	crc32_byte ((val>>32) & 0xff);
  104|     32|	crc32_byte ((val>>40) & 0xff);
  105|     32|	crc32_byte ((val>>48) & 0xff);
  106|     32|	crc32_byte ((val>>56) & 0xff);
  107|     32|}
  108|       |
  109|       |static void 
  110|       |transparent_crc (uint64_t val, char* vname, int flag)
  111|     32|{
  112|     32|	crc32_8bytes(val);
  113|     32|	if (flag) {
  114|      0|  		printf("...checksum after hashing %s : %lX\n", vname, crc32_context ^ 0xFFFFFFFFUL);
  115|      0|	}
  116|     32|}
  117|       |
  118|       |#endif
  119|       |
  120|       |static void 
  121|       |transparent_crc_bytes (char *ptr, int nbytes, char* vname, int flag)
  122|      0|{
  123|      0|    int i;
  124|      0|    for (i=0; i<nbytes; i++) {
  125|      0|        crc32_byte(ptr[i]);
  126|      0|    }
  127|      0|	if (flag) {
  128|      0|  		printf("...checksum after hashing %s : %lX\n", vname, crc32_context ^ 0xFFFFFFFFUL);
  129|      0|	}
  130|      0|}
  131|       |
  132|       |/*****************************************************************************/
  133|       |
  134|       |#endif
  135|       |
  136|       |#endif /* RANDOM_RUNTIME_H */
  137|       |
  138|       |/*
  139|       | * Local Variables:
  140|       | * c-basic-offset: 4
  141|       | * tab-width: 4
  142|       | * End:
  143|       | */
  144|       |
  145|       |/* End of file. */

/root/TSE2022/testsuite/RTEF/runtime/platform_generic.h:
    1|       |/* -*- mode: C -*-
    2|       | *
    3|       | * Copyright (c) 2007, 2008, 2011, 2013 The University of Utah
    4|       | * All rights reserved.
    5|       | *
    6|       | * This file is part of `csmith', a random generator of C programs.
    7|       | *
    8|       | * Redistribution and use in source and binary forms, with or without
    9|       | * modification, are permitted provided that the following conditions are met:
   10|       | *
   11|       | *   * Redistributions of source code must retain the above copyright notice,
   12|       | *     this list of conditions and the following disclaimer.
   13|       | *
   14|       | *   * Redistributions in binary form must reproduce the above copyright
   15|       | *     notice, this list of conditions and the following disclaimer in the
   16|       | *     documentation and/or other materials provided with the distribution.
   17|       | *
   18|       | * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   19|       | * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   20|       | * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   21|       | * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
   22|       | * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   23|       | * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   24|       | * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   25|       | * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   26|       | * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   27|       | * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   28|       | * POSSIBILITY OF SUCH DAMAGE.
   29|       | */
   30|       |
   31|       |#ifndef PLATFORM_GENERIC_H
   32|       |#define PLATFORM_GENERIC_H
   33|       |
   34|       |/*****************************************************************************/
   35|       |
   36|       |#ifdef STANDALONE
   37|       |extern int printf (const char *, ...);
   38|       |#else
   39|       |#include <stdio.h>
   40|       |#endif
   41|       |
   42|       |static void
   43|       |platform_main_begin(void)
   44|      1|{
   45|      1|	/* Nothing to do. */
   46|      1|}
   47|       |
   48|       |static void
   49|       |platform_main_end(uint32_t crc, int flag)
   50|      1|{
   51|       |#if defined (__FRAMAC)
   52|       |    Frama_C_dump_assert_each();
   53|       |#endif
   54|      1|
   55|      1|#ifndef NOT_PRINT_CHECKSUM
   56|      1|	printf ("checksum = %X\n", crc);
   57|      1|#endif
   58|      1|
   59|       |#if defined (LOG_WRAPPERS)
   60|       |	{
   61|       |		int i, first;
   62|       |
   63|       |		printf ("executed wrappers: ");
   64|       |		first = 1;
   65|       |		for (i=1; i<N_WRAP+1; i++) {
   66|       |			if (__executed_checks[i]) {
   67|       |				if (!first) {
   68|       |					printf (",");
   69|       |				} else {
   70|       |					first = 0;
   71|       |				}
   72|       |				printf ("%d", i);
   73|       |			}
   74|       |		}
   75|       |		printf ("\n");
   76|       |
   77|       |		printf ("dead wrappers: ");
   78|       |		first = 1;
   79|       |		for (i=1; i<N_WRAP+1; i++) {
   80|       |			if (!__executed_checks[i]) {
   81|       |				if (!first) {
   82|       |					printf (",");
   83|       |				} else {
   84|       |					first = 0;
   85|       |				}
   86|       |				printf ("%d", i);
   87|       |			}
   88|       |		}
   89|       |		printf ("\n");
   90|       |
   91|       |		printf ("wrappers that failed at least once: ");
   92|       |		first = 1;
   93|       |		for (i=1; i<N_WRAP+1; i++) {
   94|       |			if (__failed_checks[i]) {
   95|       |				if (!first) {
   96|       |					printf (",");
   97|       |				} else {
   98|       |					first = 0;
   99|       |				}
  100|       |				printf ("%d", i);
  101|       |			}
  102|       |		}
  103|       |		printf ("\n");
  104|       |
  105|       |		printf ("wrappers that never failed (or never executed): ");
  106|       |		first = 1;
  107|       |		for (i=1; i<N_WRAP+1; i++) {
  108|       |			if (!__failed_checks[i]) {
  109|       |				if (!first) {
  110|       |					printf (",");
  111|       |				} else {
  112|       |					first = 0;
  113|       |				}
  114|       |				printf ("%d", i);
  115|       |			}
  116|       |		}
  117|       |		printf ("\n");
  118|       |	}
  119|       |#endif
  120|      1|}
  121|       |
  122|       |#define MB (1<<20)
  123|       |
  124|       |/*****************************************************************************/
  125|       |
  126|       |#endif /* PLATFORM_GENERIC_H */
  127|       |
  128|       |/*
  129|       | * Local Variables:
  130|       | * c-basic-offset: 4
  131|       | * tab-width: 4
  132|       | * End:
  133|       | */
  134|       |
  135|       |/* End of file. */

/root/TSE2022/testsuite/RTEF/runtime/random_inc.h:
    1|       |/* -*- mode: C -*-
    2|       | *
    3|       | * Copyright (c) 2007-2010, 2011 The University of Utah
    4|       | * All rights reserved.
    5|       | *
    6|       | * This file is part of `csmith', a random generator of C programs.
    7|       | *
    8|       | * Redistribution and use in source and binary forms, with or without
    9|       | * modification, are permitted provided that the following conditions are met:
   10|       | *
   11|       | *   * Redistributions of source code must retain the above copyright notice,
   12|       | *     this list of conditions and the following disclaimer.
   13|       | *
   14|       | *   * Redistributions in binary form must reproduce the above copyright
   15|       | *     notice, this list of conditions and the following disclaimer in the
   16|       | *     documentation and/or other materials provided with the distribution.
   17|       | *
   18|       | * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   19|       | * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   20|       | * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   21|       | * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
   22|       | * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   23|       | * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   24|       | * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   25|       | * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   26|       | * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   27|       | * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   28|       | * POSSIBILITY OF SUCH DAMAGE.
   29|       | */
   30|       |
   31|       |#ifndef RANDOM_INC_H
   32|       |#define RANDOM_INC_H
   33|       |
   34|       |
   35|       |#if defined(STANDALONE)
   36|       |  #if defined(_MSC_VER)
   37|       |    #include <limits.h>
   38|       |    #include "windows/stdint.h"
   39|       |  #elif defined (IA32_ARCH)
   40|       |    #include "stdint_ia32.h"
   41|       |  #elif defined (IA64_ARCH)
   42|       |    #include "stdint_ia64.h"
   43|       |  #elif defined (MSP430)
   44|       |    #include "stdint_msp430.h"
   45|       |  #elif defined (AVR_ARCH)
   46|       |    #include "stdint_avr.h"
   47|       |  #else
   48|       |    #include "stdint_ia32.h"
   49|       |  #endif
   50|       |#else
   51|       |  #include <limits.h>
   52|       |  #if defined(_MSC_VER)
   53|       |    #include "windows/stdint.h"
   54|       |  #else
   55|       |    #include <stdint.h>
   56|       |  #endif
   57|       |#endif
   58|       |
   59|       |#include <assert.h>
   60|       |
   61|       |/*****************************************************************************/
   62|       |
   63|       |#ifndef DEPUTY
   64|       |#define COUNT(n)
   65|       |#define TC
   66|       |#define SAFE
   67|       |#endif
   68|       |
   69|       |/*****************************************************************************/
   70|       |
   71|       |#ifdef LOG_WRAPPERS
   72|       |#include "wrapper.h"
   73|       |char __failed_checks[N_WRAP+1];
   74|       |char __executed_checks[N_WRAP+1];
   75|       |#define UNDEFINED(__val) (__failed_checks[index]=1,(__val))
   76|       |#define LOG_INDEX , int index
   77|       |#define LOG_EXEC __executed_checks[index]=1;
   78|       |#else
   79|      8|#define UNDEFINED(__val) (__val)
   80|       |#define LOG_INDEX
   81|       |#define LOG_EXEC
   82|       |#endif
   83|       |
   84|       |#if defined(AVR_ARCH)
   85|       |#include "platform_avr.h"
   86|       |#elif defined (MSP430)
   87|       |#include "platform_msp430.h"
   88|       |#else
   89|       |#include "platform_generic.h"
   90|       |#endif
   91|       |
   92|       |#define STATIC static
   93|       |
   94|       |#if defined (USE_MATH_MACROS_NOTMP)
   95|       |#include "safe_math_macros_notmp.h"
   96|       |#elif defined (USE_MATH_MACROS)
   97|       |#include "safe_math_macros.h"
   98|       |#else
   99|       |#define FUNC_NAME(x) (safe_##x)
  100|       |#include "safe_math.h"
  101|       |#undef FUNC_NAME
  102|       |#endif
  103|       |
  104|       |#define INT_BIT (sizeof(int)*CHAR_BIT)
  105|       |#define _CSMITH_BITFIELD(x) (((x)>INT_BIT)?((x)%INT_BIT):(x))
  106|       |
  107|       |#ifdef TCC
  108|       |
  109|       |void* memcpy(void* dest, const void* src, size_t count) {
  110|       |  char* dst8 = (char*)dest;
  111|       |  char* src8 = (char*)src;
  112|       |  
  113|       |  while (count--) {
  114|       |    *dst8++ = *src8++;
  115|       |  }
  116|       |  return dest;
  117|       |}
  118|       |
  119|       |void *memset(void *s, int c, size_t n)
  120|       |{
  121|       |    unsigned char* p=s;
  122|       |    while(n--)
  123|       |        *p++ = (unsigned char)c;
  124|       |    return s;
  125|       |}
  126|       |
  127|       |#endif
  128|       |
  129|       |#endif // RANDOM_INC_H

/root/TSE2022/testsuite/RTEF/runtime/safe_math.h:
    1|       |
    2|       |#ifndef SAFE_MATH_H
    3|       |#define SAFE_MATH_H
    4|       |
    5|       |
    6|       |
    7|       |
    8|       |
    9|       |
   10|       |
   11|       |
   12|       |
   13|       |STATIC int8_t
   14|       |FUNC_NAME(unary_minus_func_int8_t_s)(int8_t si LOG_INDEX)
   15|      0|{
   16|      0|  LOG_EXEC
   17|      0|  return 
   18|      0|#ifndef UNSAFE
   19|       |#if (INT8_MAX>=INT_MAX)
   20|       |    (si==INT8_MIN) ?
   21|       |    (UNDEFINED(si)) :
   22|       |#endif
   23|      0|#endif
   24|      0|    -si;
   25|      0|}
   26|       |
   27|       |STATIC int8_t
   28|       |FUNC_NAME(add_func_int8_t_s_s)(int8_t si1, int8_t si2 LOG_INDEX)
   29|      1|{
   30|      1|  LOG_EXEC
   31|      1|  return 
   32|      1|#ifndef UNSAFE
   33|       |#if (INT8_MAX>=INT_MAX)
   34|       |    (((si1>0) && (si2>0) && (si1 > (INT8_MAX-si2))) || ((si1<0) && (si2<0) && (si1 < (INT8_MIN-si2)))) ?
   35|       |    (UNDEFINED(si1)) :
   36|       |#endif
   37|      1|#endif
   38|      1|    (si1 + si2);
   39|      1|}
   40|       |
   41|       |STATIC int8_t
   42|       |FUNC_NAME(sub_func_int8_t_s_s)(int8_t si1, int8_t si2 LOG_INDEX)
   43|      1|{
   44|      1|  LOG_EXEC
   45|      1|  return 
   46|      1|#ifndef UNSAFE
   47|       |#if (INT8_MAX>=INT_MAX)
   48|       |    (((si1^si2) & (((si1 ^ ((si1^si2) & (~INT8_MAX)))-si2)^si2)) < 0) ? 
   49|       |    (UNDEFINED(si1)) : 
   50|       |#endif
   51|      1|#endif
   52|      1|    (si1 - si2);
   53|      1|}
   54|       |
   55|       |STATIC int8_t
   56|       |FUNC_NAME(mul_func_int8_t_s_s)(int8_t si1, int8_t si2 LOG_INDEX)
   57|      0|{
   58|      0|  LOG_EXEC
   59|      0|  return 
   60|      0|#ifndef UNSAFE
   61|      0|#if (INT8_MAX>=INT_MAX)
   62|      0|    (((si1 > 0) && (si2 > 0) && (si1 > (INT8_MAX / si2))) || ((si1 > 0) && (si2 <= 0) && (si2 < (INT8_MIN / si1))) || ((si1 <= 0) && (si2 > 0) && (si1 < (INT8_MIN / si2))) || ((si1 <= 0) && (si2 <= 0) && (si1 != 0) && (si2 < (INT8_MAX / si1)))) ? 
   63|      0|    (UNDEFINED(si1)) : 
   64|      0|#endif
   65|      0|#endif
   66|      0|    si1 * si2;
   67|      0|}
   68|       |
   69|       |STATIC int8_t
   70|       |FUNC_NAME(mod_func_int8_t_s_s)(int8_t si1, int8_t si2 LOG_INDEX)
   71|      2|{
   72|      2|  LOG_EXEC
   73|      2|  return 
   74|      2|#ifndef UNSAFE
   75|      2|    ((si2 == 0) || ((si1 == INT8_MIN) && (si2 == (-1)))) ? 
   76|      0|    (UNDEFINED(si1)) : 
   77|      2|#endif
   78|      2|    (si1 % si2);
   79|      2|}
   80|       |
   81|       |STATIC int8_t
   82|       |FUNC_NAME(div_func_int8_t_s_s)(int8_t si1, int8_t si2 LOG_INDEX)
   83|      2|{
   84|      2|  LOG_EXEC
   85|      2|  return 
   86|      2|#ifndef UNSAFE
   87|      2|    ((si2 == 0) || ((si1 == INT8_MIN) && (si2 == (-1)))) ? 
   88|      0|    (UNDEFINED(si1)) : 
   89|      2|#endif
   90|      2|    (si1 / si2);
   91|      2|}
   92|       |
   93|       |STATIC int8_t
   94|       |FUNC_NAME(lshift_func_int8_t_s_s)(int8_t left, int right LOG_INDEX)
   95|      1|{
   96|      1|  LOG_EXEC
   97|      1|  return 
   98|      1|#ifndef UNSAFE
   99|      1|    ((left < 0) || (((int)right) < 0) || (((int)right) >= 32) || (left > (INT8_MAX >> ((int)right)))) ? 
  100|      1|    (UNDEFINED(left)) : 
  101|      1|#endif
  102|      1|    (left << ((int)right));
  103|      1|}
  104|       |
  105|       |STATIC int8_t
  106|       |FUNC_NAME(lshift_func_int8_t_s_u)(int8_t left, unsigned int right LOG_INDEX)
  107|      0|{
  108|      0|  LOG_EXEC
  109|      0|  return 
  110|      0|#ifndef UNSAFE
  111|      0|    ((left < 0) || (((unsigned int)right) >= 32) || (left > (INT8_MAX >> ((unsigned int)right)))) ? 
  112|      0|    (UNDEFINED(left)) : 
  113|      0|#endif
  114|      0|    (left << ((unsigned int)right));
  115|      0|}
  116|       |
  117|       |STATIC int8_t
  118|       |FUNC_NAME(rshift_func_int8_t_s_s)(int8_t left, int right LOG_INDEX)
  119|      1|{
  120|      1|  LOG_EXEC
  121|      1|  return 
  122|      1|#ifndef UNSAFE
  123|      1|    ((left < 0) || (((int)right) < 0) || (((int)right) >= 32))? 
  124|      0|    (UNDEFINED(left)) : 
  125|      1|#endif
  126|      1|    (left >> ((int)right));
  127|      1|}
  128|       |
  129|       |STATIC int8_t
  130|       |FUNC_NAME(rshift_func_int8_t_s_u)(int8_t left, unsigned int right LOG_INDEX)
  131|      0|{
  132|      0|  LOG_EXEC
  133|      0|  return 
  134|      0|#ifndef UNSAFE
  135|      0|    ((left < 0) || (((unsigned int)right) >= 32)) ? 
  136|      0|    (UNDEFINED(left)) : 
  137|      0|#endif
  138|      0|    (left >> ((unsigned int)right));
  139|      0|}
  140|       |
  141|       |
  142|       |
  143|       |STATIC int16_t
  144|       |FUNC_NAME(unary_minus_func_int16_t_s)(int16_t si LOG_INDEX)
  145|      0|{
  146|      0|  LOG_EXEC
  147|      0|  return 
  148|      0|#ifndef UNSAFE
  149|      0|#if (INT16_MAX>=INT_MAX)
  150|      0|    (si==INT16_MIN) ?
  151|      0|    (UNDEFINED(si)) :
  152|      0|#endif
  153|      0|#endif
  154|      0|    -si;
  155|      0|}
  156|       |
  157|       |STATIC int16_t
  158|       |FUNC_NAME(add_func_int16_t_s_s)(int16_t si1, int16_t si2 LOG_INDEX)
  159|      2|{
  160|      2|  LOG_EXEC
  161|      2|  return 
  162|      2|#ifndef UNSAFE
  163|       |#if (INT16_MAX>=INT_MAX)
  164|       |    (((si1>0) && (si2>0) && (si1 > (INT16_MAX-si2))) || ((si1<0) && (si2<0) && (si1 < (INT16_MIN-si2)))) ?
  165|       |    (UNDEFINED(si1)) :
  166|       |#endif
  167|      2|#endif
  168|      2|    (si1 + si2);
  169|      2|}
  170|       |
  171|       |STATIC int16_t
  172|       |FUNC_NAME(sub_func_int16_t_s_s)(int16_t si1, int16_t si2 LOG_INDEX)
  173|      1|{
  174|      1|  LOG_EXEC
  175|      1|  return 
  176|      1|#ifndef UNSAFE
  177|       |#if (INT16_MAX>=INT_MAX)
  178|       |    (((si1^si2) & (((si1 ^ ((si1^si2) & (~INT16_MAX)))-si2)^si2)) < 0) ? 
  179|       |    (UNDEFINED(si1)) : 
  180|       |#endif
  181|      1|#endif
  182|      1|    (si1 - si2);
  183|      1|}
  184|       |
  185|       |STATIC int16_t
  186|       |FUNC_NAME(mul_func_int16_t_s_s)(int16_t si1, int16_t si2 LOG_INDEX)
  187|      3|{
  188|      3|  LOG_EXEC
  189|      3|  return 
  190|      3|#ifndef UNSAFE
  191|       |#if (INT16_MAX>=INT_MAX)
  192|       |    (((si1 > 0) && (si2 > 0) && (si1 > (INT16_MAX / si2))) || ((si1 > 0) && (si2 <= 0) && (si2 < (INT16_MIN / si1))) || ((si1 <= 0) && (si2 > 0) && (si1 < (INT16_MIN / si2))) || ((si1 <= 0) && (si2 <= 0) && (si1 != 0) && (si2 < (INT16_MAX / si1)))) ? 
  193|       |    (UNDEFINED(si1)) : 
  194|       |#endif
  195|      3|#endif
  196|      3|    si1 * si2;
  197|      3|}
  198|       |
  199|       |STATIC int16_t
  200|       |FUNC_NAME(mod_func_int16_t_s_s)(int16_t si1, int16_t si2 LOG_INDEX)
  201|      1|{
  202|      1|  LOG_EXEC
  203|      1|  return 
  204|      1|#ifndef UNSAFE
  205|      1|    ((si2 == 0) || ((si1 == INT16_MIN) && (si2 == (-1)))) ? 
  206|      0|    (UNDEFINED(si1)) : 
  207|      1|#endif
  208|      1|    (si1 % si2);
  209|      1|}
  210|       |
  211|       |STATIC int16_t
  212|       |FUNC_NAME(div_func_int16_t_s_s)(int16_t si1, int16_t si2 LOG_INDEX)
  213|      1|{
  214|      1|  LOG_EXEC
  215|      1|  return 
  216|      1|#ifndef UNSAFE
  217|      1|    ((si2 == 0) || ((si1 == INT16_MIN) && (si2 == (-1)))) ? 
  218|      0|    (UNDEFINED(si1)) : 
  219|      1|#endif
  220|      1|    (si1 / si2);
  221|      1|}
  222|       |
  223|       |STATIC int16_t
  224|       |FUNC_NAME(lshift_func_int16_t_s_s)(int16_t left, int right LOG_INDEX)
  225|      0|{
  226|      0|  LOG_EXEC
  227|      0|  return 
  228|      0|#ifndef UNSAFE
  229|      0|    ((left < 0) || (((int)right) < 0) || (((int)right) >= 32) || (left > (INT16_MAX >> ((int)right)))) ? 
  230|      0|    (UNDEFINED(left)) : 
  231|      0|#endif
  232|      0|    (left << ((int)right));
  233|      0|}
  234|       |
  235|       |STATIC int16_t
  236|       |FUNC_NAME(lshift_func_int16_t_s_u)(int16_t left, unsigned int right LOG_INDEX)
  237|      1|{
  238|      1|  LOG_EXEC
  239|      1|  return 
  240|      1|#ifndef UNSAFE
  241|      1|    ((left < 0) || (((unsigned int)right) >= 32) || (left > (INT16_MAX >> ((unsigned int)right)))) ? 
  242|      0|    (UNDEFINED(left)) : 
  243|      1|#endif
  244|      1|    (left << ((unsigned int)right));
  245|      1|}
  246|       |
  247|       |STATIC int16_t
  248|       |FUNC_NAME(rshift_func_int16_t_s_s)(int16_t left, int right LOG_INDEX)
  249|      0|{
  250|      0|  LOG_EXEC
  251|      0|  return 
  252|      0|#ifndef UNSAFE
  253|      0|    ((left < 0) || (((int)right) < 0) || (((int)right) >= 32))? 
  254|      0|    (UNDEFINED(left)) : 
  255|      0|#endif
  256|      0|    (left >> ((int)right));
  257|      0|}
  258|       |
  259|       |STATIC int16_t
  260|       |FUNC_NAME(rshift_func_int16_t_s_u)(int16_t left, unsigned int right LOG_INDEX)
  261|      1|{
  262|      1|  LOG_EXEC
  263|      1|  return 
  264|      1|#ifndef UNSAFE
  265|      1|    ((left < 0) || (((unsigned int)right) >= 32)) ? 
  266|      1|    (UNDEFINED(left)) : 
  267|      1|#endif
  268|      1|    (left >> ((unsigned int)right));
  269|      1|}
  270|       |
  271|       |
  272|       |
  273|       |STATIC int32_t
  274|       |FUNC_NAME(unary_minus_func_int32_t_s)(int32_t si LOG_INDEX)
  275|      0|{
  276|      0|  LOG_EXEC
  277|      0|  return 
  278|      0|#ifndef UNSAFE
  279|      0|#if (INT32_MAX>=INT_MAX)
  280|      0|    (si==INT32_MIN) ?
  281|      0|    (UNDEFINED(si)) :
  282|      0|#endif
  283|      0|#endif
  284|      0|    -si;
  285|      0|}
  286|       |
  287|       |STATIC int32_t
  288|       |FUNC_NAME(add_func_int32_t_s_s)(int32_t si1, int32_t si2 LOG_INDEX)
  289|      0|{
  290|      0|  LOG_EXEC
  291|      0|  return 
  292|      0|#ifndef UNSAFE
  293|      0|#if (INT32_MAX>=INT_MAX)
  294|      0|    (((si1>0) && (si2>0) && (si1 > (INT32_MAX-si2))) || ((si1<0) && (si2<0) && (si1 < (INT32_MIN-si2)))) ?
  295|      0|    (UNDEFINED(si1)) :
  296|      0|#endif
  297|      0|#endif
  298|      0|    (si1 + si2);
  299|      0|}
  300|       |
  301|       |STATIC int32_t
  302|       |FUNC_NAME(sub_func_int32_t_s_s)(int32_t si1, int32_t si2 LOG_INDEX)
  303|      0|{
  304|      0|  LOG_EXEC
  305|      0|  return 
  306|      0|#ifndef UNSAFE
  307|      0|#if (INT32_MAX>=INT_MAX)
  308|      0|    (((si1^si2) & (((si1 ^ ((si1^si2) & (~INT32_MAX)))-si2)^si2)) < 0) ? 
  309|      0|    (UNDEFINED(si1)) : 
  310|      0|#endif
  311|      0|#endif
  312|      0|    (si1 - si2);
  313|      0|}
  314|       |
  315|       |STATIC int32_t
  316|       |FUNC_NAME(mul_func_int32_t_s_s)(int32_t si1, int32_t si2 LOG_INDEX)
  317|      0|{
  318|      0|  LOG_EXEC
  319|      0|  return 
  320|      0|#ifndef UNSAFE
  321|      0|#if (INT32_MAX>=INT_MAX)
  322|      0|    (((si1 > 0) && (si2 > 0) && (si1 > (INT32_MAX / si2))) || ((si1 > 0) && (si2 <= 0) && (si2 < (INT32_MIN / si1))) || ((si1 <= 0) && (si2 > 0) && (si1 < (INT32_MIN / si2))) || ((si1 <= 0) && (si2 <= 0) && (si1 != 0) && (si2 < (INT32_MAX / si1)))) ? 
  323|      0|    (UNDEFINED(si1)) : 
  324|      0|#endif
  325|      0|#endif
  326|      0|    si1 * si2;
  327|      0|}
  328|       |
  329|       |STATIC int32_t
  330|       |FUNC_NAME(mod_func_int32_t_s_s)(int32_t si1, int32_t si2 LOG_INDEX)
  331|      2|{
  332|      2|  LOG_EXEC
  333|      2|  return 
  334|      2|#ifndef UNSAFE
  335|      2|    ((si2 == 0) || ((si1 == INT32_MIN) && (si2 == (-1)))) ? 
  336|      0|    (UNDEFINED(si1)) : 
  337|      2|#endif
  338|      2|    (si1 % si2);
  339|      2|}
  340|       |
  341|       |STATIC int32_t
  342|       |FUNC_NAME(div_func_int32_t_s_s)(int32_t si1, int32_t si2 LOG_INDEX)
  343|      0|{
  344|      0|  LOG_EXEC
  345|      0|  return 
  346|      0|#ifndef UNSAFE
  347|      0|    ((si2 == 0) || ((si1 == INT32_MIN) && (si2 == (-1)))) ? 
  348|      0|    (UNDEFINED(si1)) : 
  349|      0|#endif
  350|      0|    (si1 / si2);
  351|      0|}
  352|       |
  353|       |STATIC int32_t
  354|       |FUNC_NAME(lshift_func_int32_t_s_s)(int32_t left, int right LOG_INDEX)
  355|      0|{
  356|      0|  LOG_EXEC
  357|      0|  return 
  358|      0|#ifndef UNSAFE
  359|      0|    ((left < 0) || (((int)right) < 0) || (((int)right) >= 32) || (left > (INT32_MAX >> ((int)right)))) ? 
  360|      0|    (UNDEFINED(left)) : 
  361|      0|#endif
  362|      0|    (left << ((int)right));
  363|      0|}
  364|       |
  365|       |STATIC int32_t
  366|       |FUNC_NAME(lshift_func_int32_t_s_u)(int32_t left, unsigned int right LOG_INDEX)
  367|      0|{
  368|      0|  LOG_EXEC
  369|      0|  return 
  370|      0|#ifndef UNSAFE
  371|      0|    ((left < 0) || (((unsigned int)right) >= 32) || (left > (INT32_MAX >> ((unsigned int)right)))) ? 
  372|      0|    (UNDEFINED(left)) : 
  373|      0|#endif
  374|      0|    (left << ((unsigned int)right));
  375|      0|}
  376|       |
  377|       |STATIC int32_t
  378|       |FUNC_NAME(rshift_func_int32_t_s_s)(int32_t left, int right LOG_INDEX)
  379|      0|{
  380|      0|  LOG_EXEC
  381|      0|  return 
  382|      0|#ifndef UNSAFE
  383|      0|    ((left < 0) || (((int)right) < 0) || (((int)right) >= 32))? 
  384|      0|    (UNDEFINED(left)) : 
  385|      0|#endif
  386|      0|    (left >> ((int)right));
  387|      0|}
  388|       |
  389|       |STATIC int32_t
  390|       |FUNC_NAME(rshift_func_int32_t_s_u)(int32_t left, unsigned int right LOG_INDEX)
  391|      0|{
  392|      0|  LOG_EXEC
  393|      0|  return 
  394|      0|#ifndef UNSAFE
  395|      0|    ((left < 0) || (((unsigned int)right) >= 32)) ? 
  396|      0|    (UNDEFINED(left)) : 
  397|      0|#endif
  398|      0|    (left >> ((unsigned int)right));
  399|      0|}
  400|       |
  401|       |#ifndef NO_LONGLONG
  402|       |
  403|       |
  404|       |STATIC int64_t
  405|       |FUNC_NAME(unary_minus_func_int64_t_s)(int64_t si LOG_INDEX)
  406|      0|{
  407|      0|  LOG_EXEC
  408|      0|  return 
  409|      0|#ifndef UNSAFE
  410|      0|#if (INT64_MAX>=INT_MAX)
  411|      0|    (si==INT64_MIN) ?
  412|      0|    (UNDEFINED(si)) :
  413|      0|#endif
  414|      0|#endif
  415|      0|    -si;
  416|      0|}
  417|       |
  418|       |STATIC int64_t
  419|       |FUNC_NAME(add_func_int64_t_s_s)(int64_t si1, int64_t si2 LOG_INDEX)
  420|      0|{
  421|      0|  LOG_EXEC
  422|      0|  return 
  423|      0|#ifndef UNSAFE
  424|      0|#if (INT64_MAX>=INT_MAX)
  425|      0|    (((si1>0) && (si2>0) && (si1 > (INT64_MAX-si2))) || ((si1<0) && (si2<0) && (si1 < (INT64_MIN-si2)))) ?
  426|      0|    (UNDEFINED(si1)) :
  427|      0|#endif
  428|      0|#endif
  429|      0|    (si1 + si2);
  430|      0|}
  431|       |
  432|       |STATIC int64_t
  433|       |FUNC_NAME(sub_func_int64_t_s_s)(int64_t si1, int64_t si2 LOG_INDEX)
  434|      0|{
  435|      0|  LOG_EXEC
  436|      0|  return 
  437|      0|#ifndef UNSAFE
  438|      0|#if (INT64_MAX>=INT_MAX)
  439|      0|    (((si1^si2) & (((si1 ^ ((si1^si2) & (~INT64_MAX)))-si2)^si2)) < 0) ? 
  440|      0|    (UNDEFINED(si1)) : 
  441|      0|#endif
  442|      0|#endif
  443|      0|    (si1 - si2);
  444|      0|}
  445|       |
  446|       |STATIC int64_t
  447|       |FUNC_NAME(mul_func_int64_t_s_s)(int64_t si1, int64_t si2 LOG_INDEX)
  448|      0|{
  449|      0|  LOG_EXEC
  450|      0|  return 
  451|      0|#ifndef UNSAFE
  452|      0|#if (INT64_MAX>=INT_MAX)
  453|      0|    (((si1 > 0) && (si2 > 0) && (si1 > (INT64_MAX / si2))) || ((si1 > 0) && (si2 <= 0) && (si2 < (INT64_MIN / si1))) || ((si1 <= 0) && (si2 > 0) && (si1 < (INT64_MIN / si2))) || ((si1 <= 0) && (si2 <= 0) && (si1 != 0) && (si2 < (INT64_MAX / si1)))) ? 
  454|      0|    (UNDEFINED(si1)) : 
  455|      0|#endif
  456|      0|#endif
  457|      0|    si1 * si2;
  458|      0|}
  459|       |
  460|       |STATIC int64_t
  461|       |FUNC_NAME(mod_func_int64_t_s_s)(int64_t si1, int64_t si2 LOG_INDEX)
  462|      0|{
  463|      0|  LOG_EXEC
  464|      0|  return 
  465|      0|#ifndef UNSAFE
  466|      0|    ((si2 == 0) || ((si1 == INT64_MIN) && (si2 == (-1)))) ? 
  467|      0|    (UNDEFINED(si1)) : 
  468|      0|#endif
  469|      0|    (si1 % si2);
  470|      0|}
  471|       |
  472|       |STATIC int64_t
  473|       |FUNC_NAME(div_func_int64_t_s_s)(int64_t si1, int64_t si2 LOG_INDEX)
  474|      1|{
  475|      1|  LOG_EXEC
  476|      1|  return 
  477|      1|#ifndef UNSAFE
  478|      1|    ((si2 == 0) || ((si1 == INT64_MIN) && (si2 == (-1)))) ? 
  479|      0|    (UNDEFINED(si1)) : 
  480|      1|#endif
  481|      1|    (si1 / si2);
  482|      1|}
  483|       |
  484|       |STATIC int64_t
  485|       |FUNC_NAME(lshift_func_int64_t_s_s)(int64_t left, int right LOG_INDEX)
  486|      0|{
  487|      0|  LOG_EXEC
  488|      0|  return 
  489|      0|#ifndef UNSAFE
  490|      0|    ((left < 0) || (((int)right) < 0) || (((int)right) >= 32) || (left > (INT64_MAX >> ((int)right)))) ? 
  491|      0|    (UNDEFINED(left)) : 
  492|      0|#endif
  493|      0|    (left << ((int)right));
  494|      0|}
  495|       |
  496|       |STATIC int64_t
  497|       |FUNC_NAME(lshift_func_int64_t_s_u)(int64_t left, unsigned int right LOG_INDEX)
  498|      1|{
  499|      1|  LOG_EXEC
  500|      1|  return 
  501|      1|#ifndef UNSAFE
  502|      1|    ((left < 0) || (((unsigned int)right) >= 32) || (left > (INT64_MAX >> ((unsigned int)right)))) ? 
  503|      0|    (UNDEFINED(left)) : 
  504|      1|#endif
  505|      1|    (left << ((unsigned int)right));
  506|      1|}
  507|       |
  508|       |STATIC int64_t
  509|       |FUNC_NAME(rshift_func_int64_t_s_s)(int64_t left, int right LOG_INDEX)
  510|      0|{
  511|      0|  LOG_EXEC
  512|      0|  return 
  513|      0|#ifndef UNSAFE
  514|      0|    ((left < 0) || (((int)right) < 0) || (((int)right) >= 32))? 
  515|      0|    (UNDEFINED(left)) : 
  516|      0|#endif
  517|      0|    (left >> ((int)right));
  518|      0|}
  519|       |
  520|       |STATIC int64_t
  521|       |FUNC_NAME(rshift_func_int64_t_s_u)(int64_t left, unsigned int right LOG_INDEX)
  522|      0|{
  523|      0|  LOG_EXEC
  524|      0|  return 
  525|      0|#ifndef UNSAFE
  526|      0|    ((left < 0) || (((unsigned int)right) >= 32)) ? 
  527|      0|    (UNDEFINED(left)) : 
  528|      0|#endif
  529|      0|    (left >> ((unsigned int)right));
  530|      0|}
  531|       |
  532|       |#endif
  533|       |
  534|       |
  535|       |
  536|       |
  537|       |
  538|       |STATIC uint8_t
  539|       |FUNC_NAME(unary_minus_func_uint8_t_u)(uint8_t ui LOG_INDEX)
  540|      0|{
  541|      0|  LOG_EXEC
  542|      0|  return -ui;
  543|      0|}
  544|       |
  545|       |STATIC uint8_t
  546|       |FUNC_NAME(add_func_uint8_t_u_u)(uint8_t ui1, uint8_t ui2 LOG_INDEX)
  547|      3|{
  548|      3|  LOG_EXEC
  549|      3|  return ui1 + ui2;
  550|      3|}
  551|       |
  552|       |STATIC uint8_t
  553|       |FUNC_NAME(sub_func_uint8_t_u_u)(uint8_t ui1, uint8_t ui2 LOG_INDEX)
  554|      0|{
  555|      0|  LOG_EXEC
  556|      0|  return ui1 - ui2;
  557|      0|}
  558|       |
  559|       |STATIC uint8_t
  560|       |FUNC_NAME(mul_func_uint8_t_u_u)(uint8_t ui1, uint8_t ui2 LOG_INDEX)
  561|      1|{
  562|      1|  LOG_EXEC
  563|      1|  return ((unsigned int)ui1) * ((unsigned int)ui2);
  564|      1|}
  565|       |
  566|       |STATIC uint8_t
  567|       |FUNC_NAME(mod_func_uint8_t_u_u)(uint8_t ui1, uint8_t ui2 LOG_INDEX)
  568|      0|{
  569|      0|  LOG_EXEC
  570|      0|  return 
  571|      0|#ifndef UNSAFE
  572|      0|    (ui2 == 0) ? 
  573|      0|    (UNDEFINED(ui1)) : 
  574|      0|#endif
  575|      0|    (ui1 % ui2);
  576|      0|}
  577|       |
  578|       |STATIC uint8_t
  579|       |FUNC_NAME(div_func_uint8_t_u_u)(uint8_t ui1, uint8_t ui2 LOG_INDEX)
  580|      1|{
  581|      1|  LOG_EXEC
  582|      1|  return 
  583|      1|#ifndef UNSAFE
  584|      1|    (ui2 == 0) ? 
  585|      0|    (UNDEFINED(ui1)) : 
  586|      1|#endif
  587|      1|    (ui1 / ui2);
  588|      1|}
  589|       |
  590|       |STATIC uint8_t
  591|       |FUNC_NAME(lshift_func_uint8_t_u_s)(uint8_t left, int right LOG_INDEX)
  592|      1|{
  593|      1|  LOG_EXEC
  594|      1|  return 
  595|      1|#ifndef UNSAFE
  596|      1|    ((((int)right) < 0) || (((int)right) >= 32) || (left > (UINT8_MAX >> ((int)right)))) ? 
  597|      1|    (UNDEFINED(left)) : 
  598|      1|#endif
  599|      1|    (left << ((int)right));
  600|      1|}
  601|       |
  602|       |STATIC uint8_t
  603|       |FUNC_NAME(lshift_func_uint8_t_u_u)(uint8_t left, unsigned int right LOG_INDEX)
  604|      2|{
  605|      2|  LOG_EXEC
  606|      2|  return 
  607|      2|#ifndef UNSAFE
  608|      2|    ((((unsigned int)right) >= 32) || (left > (UINT8_MAX >> ((unsigned int)right)))) ? 
  609|      2|    (UNDEFINED(left)) : 
  610|      2|#endif
  611|      2|    (left << ((unsigned int)right));
  612|      2|}
  613|       |
  614|       |STATIC uint8_t
  615|       |FUNC_NAME(rshift_func_uint8_t_u_s)(uint8_t left, int right LOG_INDEX)
  616|      2|{
  617|      2|  LOG_EXEC
  618|      2|  return 
  619|      2|#ifndef UNSAFE
  620|      2|    ((((int)right) < 0) || (((int)right) >= 32)) ? 
  621|      0|    (UNDEFINED(left)) : 
  622|      2|#endif
  623|      2|    (left >> ((int)right));
  624|      2|}
  625|       |
  626|       |STATIC uint8_t
  627|       |FUNC_NAME(rshift_func_uint8_t_u_u)(uint8_t left, unsigned int right LOG_INDEX)
  628|      0|{
  629|      0|  LOG_EXEC
  630|      0|  return 
  631|      0|#ifndef UNSAFE
  632|      0|    (((unsigned int)right) >= 32) ? 
  633|      0|    (UNDEFINED(left)) : 
  634|      0|#endif
  635|      0|    (left >> ((unsigned int)right));
  636|      0|}
  637|       |
  638|       |
  639|       |
  640|       |STATIC uint16_t
  641|       |FUNC_NAME(unary_minus_func_uint16_t_u)(uint16_t ui LOG_INDEX)
  642|      0|{
  643|      0|  LOG_EXEC
  644|      0|  return -ui;
  645|      0|}
  646|       |
  647|       |STATIC uint16_t
  648|       |FUNC_NAME(add_func_uint16_t_u_u)(uint16_t ui1, uint16_t ui2 LOG_INDEX)
  649|      1|{
  650|      1|  LOG_EXEC
  651|      1|  return ui1 + ui2;
  652|      1|}
  653|       |
  654|       |STATIC uint16_t
  655|       |FUNC_NAME(sub_func_uint16_t_u_u)(uint16_t ui1, uint16_t ui2 LOG_INDEX)
  656|      0|{
  657|      0|  LOG_EXEC
  658|      0|  return ui1 - ui2;
  659|      0|}
  660|       |
  661|       |STATIC uint16_t
  662|       |FUNC_NAME(mul_func_uint16_t_u_u)(uint16_t ui1, uint16_t ui2 LOG_INDEX)
  663|      0|{
  664|      0|  LOG_EXEC
  665|      0|  return ((unsigned int)ui1) * ((unsigned int)ui2);
  666|      0|}
  667|       |
  668|       |STATIC uint16_t
  669|       |FUNC_NAME(mod_func_uint16_t_u_u)(uint16_t ui1, uint16_t ui2 LOG_INDEX)
  670|      1|{
  671|      1|  LOG_EXEC
  672|      1|  return 
  673|      1|#ifndef UNSAFE
  674|      1|    (ui2 == 0) ? 
  675|      0|    (UNDEFINED(ui1)) : 
  676|      1|#endif
  677|      1|    (ui1 % ui2);
  678|      1|}
  679|       |
  680|       |STATIC uint16_t
  681|       |FUNC_NAME(div_func_uint16_t_u_u)(uint16_t ui1, uint16_t ui2 LOG_INDEX)
  682|      1|{
  683|      1|  LOG_EXEC
  684|      1|  return 
  685|      1|#ifndef UNSAFE
  686|      1|    (ui2 == 0) ? 
  687|      1|    (UNDEFINED(ui1)) : 
  688|      1|#endif
  689|      1|    (ui1 / ui2);
  690|      1|}
  691|       |
  692|       |STATIC uint16_t
  693|       |FUNC_NAME(lshift_func_uint16_t_u_s)(uint16_t left, int right LOG_INDEX)
  694|      1|{
  695|      1|  LOG_EXEC
  696|      1|  return 
  697|      1|#ifndef UNSAFE
  698|      1|    ((((int)right) < 0) || (((int)right) >= 32) || (left > (UINT16_MAX >> ((int)right)))) ? 
  699|      0|    (UNDEFINED(left)) : 
  700|      1|#endif
  701|      1|    (left << ((int)right));
  702|      1|}
  703|       |
  704|       |STATIC uint16_t
  705|       |FUNC_NAME(lshift_func_uint16_t_u_u)(uint16_t left, unsigned int right LOG_INDEX)
  706|      1|{
  707|      1|  LOG_EXEC
  708|      1|  return 
  709|      1|#ifndef UNSAFE
  710|      1|    ((((unsigned int)right) >= 32) || (left > (UINT16_MAX >> ((unsigned int)right)))) ? 
  711|      0|    (UNDEFINED(left)) : 
  712|      1|#endif
  713|      1|    (left << ((unsigned int)right));
  714|      1|}
  715|       |
  716|       |STATIC uint16_t
  717|       |FUNC_NAME(rshift_func_uint16_t_u_s)(uint16_t left, int right LOG_INDEX)
  718|      1|{
  719|      1|  LOG_EXEC
  720|      1|  return 
  721|      1|#ifndef UNSAFE
  722|      1|    ((((int)right) < 0) || (((int)right) >= 32)) ? 
  723|      0|    (UNDEFINED(left)) : 
  724|      1|#endif
  725|      1|    (left >> ((int)right));
  726|      1|}
  727|       |
  728|       |STATIC uint16_t
  729|       |FUNC_NAME(rshift_func_uint16_t_u_u)(uint16_t left, unsigned int right LOG_INDEX)
  730|      1|{
  731|      1|  LOG_EXEC
  732|      1|  return 
  733|      1|#ifndef UNSAFE
  734|      1|    (((unsigned int)right) >= 32) ? 
  735|      0|    (UNDEFINED(left)) : 
  736|      1|#endif
  737|      1|    (left >> ((unsigned int)right));
  738|      1|}
  739|       |
  740|       |
  741|       |
  742|       |STATIC uint32_t
  743|       |FUNC_NAME(unary_minus_func_uint32_t_u)(uint32_t ui LOG_INDEX)
  744|      0|{
  745|      0|  LOG_EXEC
  746|      0|  return -ui;
  747|      0|}
  748|       |
  749|       |STATIC uint32_t
  750|       |FUNC_NAME(add_func_uint32_t_u_u)(uint32_t ui1, uint32_t ui2 LOG_INDEX)
  751|      2|{
  752|      2|  LOG_EXEC
  753|      2|  return ui1 + ui2;
  754|      2|}
  755|       |
  756|       |STATIC uint32_t
  757|       |FUNC_NAME(sub_func_uint32_t_u_u)(uint32_t ui1, uint32_t ui2 LOG_INDEX)
  758|      0|{
  759|      0|  LOG_EXEC
  760|      0|  return ui1 - ui2;
  761|      0|}
  762|       |
  763|       |STATIC uint32_t
  764|       |FUNC_NAME(mul_func_uint32_t_u_u)(uint32_t ui1, uint32_t ui2 LOG_INDEX)
  765|      0|{
  766|      0|  LOG_EXEC
  767|      0|  return ((unsigned int)ui1) * ((unsigned int)ui2);
  768|      0|}
  769|       |
  770|       |STATIC uint32_t
  771|       |FUNC_NAME(mod_func_uint32_t_u_u)(uint32_t ui1, uint32_t ui2 LOG_INDEX)
  772|      0|{
  773|      0|  LOG_EXEC
  774|      0|  return 
  775|      0|#ifndef UNSAFE
  776|      0|    (ui2 == 0) ? 
  777|      0|    (UNDEFINED(ui1)) : 
  778|      0|#endif
  779|      0|    (ui1 % ui2);
  780|      0|}
  781|       |
  782|       |STATIC uint32_t
  783|       |FUNC_NAME(div_func_uint32_t_u_u)(uint32_t ui1, uint32_t ui2 LOG_INDEX)
  784|      3|{
  785|      3|  LOG_EXEC
  786|      3|  return 
  787|      3|#ifndef UNSAFE
  788|      3|    (ui2 == 0) ? 
  789|      0|    (UNDEFINED(ui1)) : 
  790|      3|#endif
  791|      3|    (ui1 / ui2);
  792|      3|}
  793|       |
  794|       |STATIC uint32_t
  795|       |FUNC_NAME(lshift_func_uint32_t_u_s)(uint32_t left, int right LOG_INDEX)
  796|      0|{
  797|      0|  LOG_EXEC
  798|      0|  return 
  799|      0|#ifndef UNSAFE
  800|      0|    ((((int)right) < 0) || (((int)right) >= 32) || (left > (UINT32_MAX >> ((int)right)))) ? 
  801|      0|    (UNDEFINED(left)) : 
  802|      0|#endif
  803|      0|    (left << ((int)right));
  804|      0|}
  805|       |
  806|       |STATIC uint32_t
  807|       |FUNC_NAME(lshift_func_uint32_t_u_u)(uint32_t left, unsigned int right LOG_INDEX)
  808|      0|{
  809|      0|  LOG_EXEC
  810|      0|  return 
  811|      0|#ifndef UNSAFE
  812|      0|    ((((unsigned int)right) >= 32) || (left > (UINT32_MAX >> ((unsigned int)right)))) ? 
  813|      0|    (UNDEFINED(left)) : 
  814|      0|#endif
  815|      0|    (left << ((unsigned int)right));
  816|      0|}
  817|       |
  818|       |STATIC uint32_t
  819|       |FUNC_NAME(rshift_func_uint32_t_u_s)(uint32_t left, int right LOG_INDEX)
  820|      0|{
  821|      0|  LOG_EXEC
  822|      0|  return 
  823|      0|#ifndef UNSAFE
  824|      0|    ((((int)right) < 0) || (((int)right) >= 32)) ? 
  825|      0|    (UNDEFINED(left)) : 
  826|      0|#endif
  827|      0|    (left >> ((int)right));
  828|      0|}
  829|       |
  830|       |STATIC uint32_t
  831|       |FUNC_NAME(rshift_func_uint32_t_u_u)(uint32_t left, unsigned int right LOG_INDEX)
  832|      0|{
  833|      0|  LOG_EXEC
  834|      0|  return 
  835|      0|#ifndef UNSAFE
  836|      0|    (((unsigned int)right) >= 32) ? 
  837|      0|    (UNDEFINED(left)) : 
  838|      0|#endif
  839|      0|    (left >> ((unsigned int)right));
  840|      0|}
  841|       |
  842|       |#ifndef NO_LONGLONG
  843|       |
  844|       |
  845|       |STATIC uint64_t
  846|       |FUNC_NAME(unary_minus_func_uint64_t_u)(uint64_t ui LOG_INDEX)
  847|      0|{
  848|      0|  LOG_EXEC
  849|      0|  return -ui;
  850|      0|}
  851|       |
  852|       |STATIC uint64_t
  853|       |FUNC_NAME(add_func_uint64_t_u_u)(uint64_t ui1, uint64_t ui2 LOG_INDEX)
  854|      0|{
  855|      0|  LOG_EXEC
  856|      0|  return ui1 + ui2;
  857|      0|}
  858|       |
  859|       |STATIC uint64_t
  860|       |FUNC_NAME(sub_func_uint64_t_u_u)(uint64_t ui1, uint64_t ui2 LOG_INDEX)
  861|      0|{
  862|      0|  LOG_EXEC
  863|      0|  return ui1 - ui2;
  864|      0|}
  865|       |
  866|       |STATIC uint64_t
  867|       |FUNC_NAME(mul_func_uint64_t_u_u)(uint64_t ui1, uint64_t ui2 LOG_INDEX)
  868|      1|{
  869|      1|  LOG_EXEC
  870|      1|  return ((unsigned long long)ui1) * ((unsigned long long)ui2);
  871|      1|}
  872|       |
  873|       |STATIC uint64_t
  874|       |FUNC_NAME(mod_func_uint64_t_u_u)(uint64_t ui1, uint64_t ui2 LOG_INDEX)
  875|      0|{
  876|      0|  LOG_EXEC
  877|      0|  return 
  878|      0|#ifndef UNSAFE
  879|      0|    (ui2 == 0) ? 
  880|      0|    (UNDEFINED(ui1)) : 
  881|      0|#endif
  882|      0|    (ui1 % ui2);
  883|      0|}
  884|       |
  885|       |STATIC uint64_t
  886|       |FUNC_NAME(div_func_uint64_t_u_u)(uint64_t ui1, uint64_t ui2 LOG_INDEX)
  887|      1|{
  888|      1|  LOG_EXEC
  889|      1|  return 
  890|      1|#ifndef UNSAFE
  891|      1|    (ui2 == 0) ? 
  892|      0|    (UNDEFINED(ui1)) : 
  893|      1|#endif
  894|      1|    (ui1 / ui2);
  895|      1|}
  896|       |
  897|       |STATIC uint64_t
  898|       |FUNC_NAME(lshift_func_uint64_t_u_s)(uint64_t left, int right LOG_INDEX)
  899|      1|{
  900|      1|  LOG_EXEC
  901|      1|  return 
  902|      1|#ifndef UNSAFE
  903|      1|    ((((int)right) < 0) || (((int)right) >= 32) || (left > (UINT64_MAX >> ((int)right)))) ? 
  904|      1|    (UNDEFINED(left)) : 
  905|      1|#endif
  906|      1|    (left << ((int)right));
  907|      1|}
  908|       |
  909|       |STATIC uint64_t
  910|       |FUNC_NAME(lshift_func_uint64_t_u_u)(uint64_t left, unsigned int right LOG_INDEX)
  911|      0|{
  912|      0|  LOG_EXEC
  913|      0|  return 
  914|      0|#ifndef UNSAFE
  915|      0|    ((((unsigned int)right) >= 32) || (left > (UINT64_MAX >> ((unsigned int)right)))) ? 
  916|      0|    (UNDEFINED(left)) : 
  917|      0|#endif
  918|      0|    (left << ((unsigned int)right));
  919|      0|}
  920|       |
  921|       |STATIC uint64_t
  922|       |FUNC_NAME(rshift_func_uint64_t_u_s)(uint64_t left, int right LOG_INDEX)
  923|      1|{
  924|      1|  LOG_EXEC
  925|      1|  return 
  926|      1|#ifndef UNSAFE
  927|      1|    ((((int)right) < 0) || (((int)right) >= 32)) ? 
  928|      1|    (UNDEFINED(left)) : 
  929|      1|#endif
  930|      1|    (left >> ((int)right));
  931|      1|}
  932|       |
  933|       |STATIC uint64_t
  934|       |FUNC_NAME(rshift_func_uint64_t_u_u)(uint64_t left, unsigned int right LOG_INDEX)
  935|      2|{
  936|      2|  LOG_EXEC
  937|      2|  return 
  938|      2|#ifndef UNSAFE
  939|      2|    (((unsigned int)right) >= 32) ? 
  940|      0|    (UNDEFINED(left)) : 
  941|      2|#endif
  942|      2|    (left >> ((unsigned int)right));
  943|      2|}
  944|       |
  945|       |#endif
  946|       |
  947|       |
  948|       |
  949|       |
  950|       |#ifdef __STDC__
  951|       |float fabsf(float);
  952|       |double fabs(double);
  953|       |
  954|       |
  955|       |STATIC float
  956|       |FUNC_NAME(add_func_float_f_f)(float sf1, float sf2 LOG_INDEX)
  957|      0|{
  958|      0|  LOG_EXEC
  959|      0|  return 
  960|      0|#ifndef UNSAFE_FLOAT
  961|      0|    (fabsf((0.5f * sf1) + (0.5f * sf2)) > (0.5f * FLT_MAX)) ? 
  962|      0|    UNDEFINED(sf1) :
  963|      0|#endif
  964|      0|    (sf1 + sf2);
  965|      0|}
  966|       |
  967|       |STATIC float
  968|       |FUNC_NAME(sub_func_float_f_f)(float sf1, float sf2 LOG_INDEX)
  969|      0|{
  970|      0|  LOG_EXEC
  971|      0|  return 
  972|      0|#ifndef UNSAFE_FLOAT
  973|      0|    (fabsf((0.5f * sf1) - (0.5f * sf2)) > (0.5f * FLT_MAX)) ? 
  974|      0|    UNDEFINED(sf1) :
  975|      0|#endif
  976|      0|    (sf1 - sf2);
  977|      0|}
  978|       |
  979|       |STATIC float
  980|       |FUNC_NAME(mul_func_float_f_f)(float sf1, float sf2 LOG_INDEX)
  981|      0|{
  982|      0|  LOG_EXEC
  983|      0|  return
  984|      0|#ifndef UNSAFE_FLOAT
  985|      0|#ifdef __STDC__
  986|      0|    (fabsf((0x1.0p-100f * sf1) * (0x1.0p-28f * sf2)) > (0x1.0p-100f * (0x1.0p-28f * FLT_MAX))) ?
  987|      0|#else
  988|      0|    (fabsf((ldexpf(1.0, -100) * sf1) * (0x1.0p-28f * sf2)) > (ldexpf(1.0, -100) * (0x1.0p-28f * FLT_MAX))) ?
  989|      0|#endif
  990|      0|    UNDEFINED(sf1) :
  991|      0|#endif
  992|      0|    (sf1 * sf2);
  993|      0|}
  994|       |
  995|       |STATIC float
  996|       |FUNC_NAME(div_func_float_f_f)(float sf1, float sf2 LOG_INDEX)
  997|      0|{
  998|      0|  LOG_EXEC
  999|      0|  return
 1000|      0|#ifndef UNSAFE_FLOAT
 1001|      0|#ifdef __STDC__
 1002|      0|    ((fabsf(sf2) < 1.0f) && (((sf2 == 0.0f) || (fabsf((0x1.0p-49f * sf1) / (0x1.0p100f * sf2))) > (0x1.0p-100f * (0x1.0p-49f * FLT_MAX))))) ?
 1003|      0|#else
 1004|      0|    ((fabsf(sf2) < 1.0f) && (((sf2 == 0.0f) || (fabsf((0x1.0p-49f * sf1) / (ldexpf(1.0, 100) * sf2))) > (ldexpf(1.0, -100) * (0x1.0p-49f * FLT_MAX))))) ?
 1005|      0|#endif
 1006|      0|    UNDEFINED(sf1) :
 1007|      0|#endif
 1008|      0|    (sf1 / sf2);
 1009|      0|}
 1010|       |
 1011|       |
 1012|       |
 1013|       |
 1014|       |STATIC double
 1015|       |FUNC_NAME(add_func_double_f_f)(double sf1, double sf2 LOG_INDEX)
 1016|      0|{
 1017|      0|  LOG_EXEC
 1018|      0|  return 
 1019|      0|#ifndef UNSAFE_FLOAT
 1020|      0|    (fabs((0.5 * sf1) + (0.5 * sf2)) > (0.5 * DBL_MAX)) ? 
 1021|      0|    UNDEFINED(sf1) :
 1022|      0|#endif
 1023|      0|    (sf1 + sf2);
 1024|      0|}
 1025|       |
 1026|       |STATIC double
 1027|       |FUNC_NAME(sub_func_double_f_f)(double sf1, double sf2 LOG_INDEX)
 1028|      0|{
 1029|      0|  LOG_EXEC
 1030|      0|  return 
 1031|      0|#ifndef UNSAFE_FLOAT
 1032|      0|    (fabs((0.5 * sf1) - (0.5 * sf2)) > (0.5 * DBL_MAX)) ? 
 1033|      0|    UNDEFINED(sf1) :
 1034|      0|#endif
 1035|      0|    (sf1 - sf2);
 1036|      0|}
 1037|       |
 1038|       |STATIC double
 1039|       |FUNC_NAME(mul_func_double_f_f)(double sf1, double sf2 LOG_INDEX)
 1040|      0|{
 1041|      0|  LOG_EXEC
 1042|      0|  return
 1043|      0|#ifndef UNSAFE_FLOAT
 1044|      0|#ifdef __STDC__
 1045|      0|    (fabs((0x1.0p-100 * sf1) * (0x1.0p-924 * sf2)) > (0x1.0p-100 * (0x1.0p-924 * DBL_MAX))) ?
 1046|      0|#else
 1047|      0|    (fabs((ldexp(1.0, -100) * sf1) * (0x1.0p-924 * sf2)) > (ldexp(1.0, -100) * (0x1.0p-924 * DBL_MAX))) ?
 1048|      0|#endif
 1049|      0|    UNDEFINED(sf1) :
 1050|      0|#endif
 1051|      0|    (sf1 * sf2);
 1052|      0|}
 1053|       |
 1054|       |STATIC double
 1055|       |FUNC_NAME(div_func_double_f_f)(double sf1, double sf2 LOG_INDEX)
 1056|      0|{
 1057|      0|  LOG_EXEC
 1058|      0|  return
 1059|      0|#ifndef UNSAFE_FLOAT
 1060|      0|#ifdef __STDC__
 1061|      0|    ((fabs(sf2) < 1.0) && (((sf2 == 0.0) || (fabs((0x1.0p-974 * sf1) / (0x1.0p100 * sf2))) > (0x1.0p-100 * (0x1.0p-974 * DBL_MAX))))) ?
 1062|      0|#else
 1063|      0|    ((fabs(sf2) < 1.0) && (((sf2 == 0.0) || (fabs((0x1.0p-974 * sf1) / (ldexp(1.0, 100) * sf2))) > (ldexp(1.0, -100) * (0x1.0p-974 * DBL_MAX))))) ?
 1064|      0|#endif
 1065|      0|    UNDEFINED(sf1) :
 1066|      0|#endif
 1067|      0|    (sf1 / sf2);
 1068|      0|}
 1069|       |
 1070|       |
 1071|       |#else
 1072|       |
 1073|       |
 1074|       |STATIC float
 1075|       |FUNC_NAME(add_func_float_f_f)(float sf1, float sf2 LOG_INDEX)
 1076|       |{
 1077|       |  LOG_EXEC
 1078|       |  return 
 1079|       |#ifndef UNSAFE_FLOAT
 1080|       |    (fabsf((0.5f * sf1) + (0.5f * sf2)) > (0.5f * FLT_MAX)) ? 
 1081|       |    UNDEFINED(sf1) :
 1082|       |#endif
 1083|       |    (sf1 + sf2);
 1084|       |}
 1085|       |
 1086|       |STATIC float
 1087|       |FUNC_NAME(sub_func_float_f_f)(float sf1, float sf2 LOG_INDEX)
 1088|       |{
 1089|       |  LOG_EXEC
 1090|       |  return 
 1091|       |#ifndef UNSAFE_FLOAT
 1092|       |    (fabsf((0.5f * sf1) - (0.5f * sf2)) > (0.5f * FLT_MAX)) ? 
 1093|       |    UNDEFINED(sf1) :
 1094|       |#endif
 1095|       |    (sf1 - sf2);
 1096|       |}
 1097|       |
 1098|       |STATIC float
 1099|       |FUNC_NAME(mul_func_float_f_f)(float sf1, float sf2 LOG_INDEX)
 1100|       |{
 1101|       |  LOG_EXEC
 1102|       |  return
 1103|       |#ifndef UNSAFE_FLOAT
 1104|       |#ifdef __STDC__
 1105|       |    (fabsf((0x1.0p-100f * sf1) * (ldexpf(1.0, -28) * sf2)) > (0x1.0p-100f * (ldexpf(1.0, -28) * FLT_MAX))) ?
 1106|       |#else
 1107|       |    (fabsf((ldexpf(1.0, -100) * sf1) * (ldexpf(1.0, -28) * sf2)) > (ldexpf(1.0, -100) * (ldexpf(1.0, -28) * FLT_MAX))) ?
 1108|       |#endif
 1109|       |    UNDEFINED(sf1) :
 1110|       |#endif
 1111|       |    (sf1 * sf2);
 1112|       |}
 1113|       |
 1114|       |STATIC float
 1115|       |FUNC_NAME(div_func_float_f_f)(float sf1, float sf2 LOG_INDEX)
 1116|       |{
 1117|       |  LOG_EXEC
 1118|       |  return
 1119|       |#ifndef UNSAFE_FLOAT
 1120|       |#ifdef __STDC__
 1121|       |    ((fabsf(sf2) < 1.0f) && (((sf2 == 0.0f) || (fabsf((ldexpf(1.0, -49) * sf1) / (0x1.0p100f * sf2))) > (0x1.0p-100f * (ldexpf(1.0, -49) * FLT_MAX))))) ?
 1122|       |#else
 1123|       |    ((fabsf(sf2) < 1.0f) && (((sf2 == 0.0f) || (fabsf((ldexpf(1.0, -49) * sf1) / (ldexpf(1.0, 100) * sf2))) > (ldexpf(1.0, -100) * (ldexpf(1.0, -49) * FLT_MAX))))) ?
 1124|       |#endif
 1125|       |    UNDEFINED(sf1) :
 1126|       |#endif
 1127|       |    (sf1 / sf2);
 1128|       |}
 1129|       |
 1130|       |
 1131|       |
 1132|       |
 1133|       |STATIC double
 1134|       |FUNC_NAME(add_func_double_f_f)(double sf1, double sf2 LOG_INDEX)
 1135|       |{
 1136|       |  LOG_EXEC
 1137|       |  return 
 1138|       |#ifndef UNSAFE_FLOAT
 1139|       |    (fabs((0.5 * sf1) + (0.5 * sf2)) > (0.5 * DBL_MAX)) ? 
 1140|       |    UNDEFINED(sf1) :
 1141|       |#endif
 1142|       |    (sf1 + sf2);
 1143|       |}
 1144|       |
 1145|       |STATIC double
 1146|       |FUNC_NAME(sub_func_double_f_f)(double sf1, double sf2 LOG_INDEX)
 1147|       |{
 1148|       |  LOG_EXEC
 1149|       |  return 
 1150|       |#ifndef UNSAFE_FLOAT
 1151|       |    (fabs((0.5 * sf1) - (0.5 * sf2)) > (0.5 * DBL_MAX)) ? 
 1152|       |    UNDEFINED(sf1) :
 1153|       |#endif
 1154|       |    (sf1 - sf2);
 1155|       |}
 1156|       |
 1157|       |STATIC double
 1158|       |FUNC_NAME(mul_func_double_f_f)(double sf1, double sf2 LOG_INDEX)
 1159|       |{
 1160|       |  LOG_EXEC
 1161|       |  return
 1162|       |#ifndef UNSAFE_FLOAT
 1163|       |#ifdef __STDC__
 1164|       |    (fabs((0x1.0p-100 * sf1) * (ldexp(1.0, -924) * sf2)) > (0x1.0p-100 * (ldexp(1.0, -924) * DBL_MAX))) ?
 1165|       |#else
 1166|       |    (fabs((ldexp(1.0, -100) * sf1) * (ldexp(1.0, -924) * sf2)) > (ldexp(1.0, -100) * (ldexp(1.0, -924) * DBL_MAX))) ?
 1167|       |#endif
 1168|       |    UNDEFINED(sf1) :
 1169|       |#endif
 1170|       |    (sf1 * sf2);
 1171|       |}
 1172|       |
 1173|       |STATIC double
 1174|       |FUNC_NAME(div_func_double_f_f)(double sf1, double sf2 LOG_INDEX)
 1175|       |{
 1176|       |  LOG_EXEC
 1177|       |  return
 1178|       |#ifndef UNSAFE_FLOAT
 1179|       |#ifdef __STDC__
 1180|       |    ((fabs(sf2) < 1.0) && (((sf2 == 0.0) || (fabs((ldexp(1.0, -974) * sf1) / (0x1.0p100 * sf2))) > (0x1.0p-100 * (ldexp(1.0, -974) * DBL_MAX))))) ?
 1181|       |#else
 1182|       |    ((fabs(sf2) < 1.0) && (((sf2 == 0.0) || (fabs((ldexp(1.0, -974) * sf1) / (ldexp(1.0, 100) * sf2))) > (ldexp(1.0, -100) * (ldexp(1.0, -974) * DBL_MAX))))) ?
 1183|       |#endif
 1184|       |    UNDEFINED(sf1) :
 1185|       |#endif
 1186|       |    (sf1 / sf2);
 1187|       |}
 1188|       |
 1189|       |
 1190|       |#endif
 1191|       |
 1192|       |
 1193|       |
 1194|       |
 1195|       |STATIC int32_t
 1196|       |FUNC_NAME(convert_func_float_to_int32_t)(float sf1 LOG_INDEX)
 1197|      0|{
 1198|      0|  LOG_EXEC
 1199|      0|  return 
 1200|      0|#ifndef UNSAFE_FLOAT
 1201|      0|    ((sf1 <= INT32_MIN) || (sf1 >= INT32_MAX)) ?
 1202|      0|    UNDEFINED(INT32_MAX) :
 1203|      0|#endif
 1204|      0|    ((int32_t)(sf1));
 1205|      0|}
 1206|       |
 1207|       |
 1208|       |
 1209|       |#endif

