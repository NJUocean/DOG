        -:    0:Source:831.c
        -:    0:Graph:831.gcno
        -:    0:Data:831.gcda
        -:    0:Runs:1
        -:    1:// Options:   --concise --max-struct-fields 5 --max-funcs 2 --max-array-len-per-dim 5 --max-block-depth 3 --max-block-size 2
        -:    2:#include "csmith.h"
        -:    3:
        -:    4:static long __undefined;
        -:    5:
        -:    6:union U0 {
        -:    7:  volatile int64_t f0;
        -:    8:  int8_t f1;
        -:    9:  volatile uint16_t f2;
        -:   10:  const int32_t f3;
        -:   11:  int32_t f4;
        -:   12:};
        -:   13:
        -:   14:static volatile int32_t g_2 = (-1L);
        -:   15:static volatile int32_t g_3[3][1] = {{(-6L)}, {(-6L)}, {(-6L)}};
        -:   16:static int32_t g_4 = 0x0C170CD5L;
        -:   17:static volatile union U0 g_7[1] = {{5L}};
        -:   18:static uint8_t g_36[3][5] = {{0x48L, 0x48L, 0xA4L, 0x48L, 0x48L}, {0xB6L, 0x48L, 0xB6L, 0xB6L, 0x48L}, {0x48L, 0xB6L, 0xB6L, 0x48L, 0xB6L}};
        -:   19:
        -:   20:static const int64_t func_1(void);
        -:   21:static int32_t *func_9(int32_t *p_10, int8_t p_11);
        -:   22:
        1:   23:static const int64_t func_1(void) {
        1:   24:  int64_t l_12 = 1L;
        -:   25:  int32_t *l_40[2][4];
        1:   26:  int32_t **l_39 = &l_40[1][3];
        -:   27:  int i, j;
        3:   28:  for (i = 0; i < 2; i++) {
       10:   29:    for (j = 0; j < 4; j++)
        8:   30:      l_40[i][j] = &g_4;
        -:   31:  }
       1*:   32:  for (g_4 = 0; (g_4 <= (-9)); --g_4) {
    #####:   33:    volatile int32_t *l_8 = &g_3[2][0];
    #####:   34:    (*l_8) = (g_7[0], g_7[0].f0);
        -:   35:  }
        1:   36:  (*l_39) = func_9(&g_4, l_12);
        1:   37:  return g_4;
        -:   38:}
        -:   39:
        1:   40:static int32_t *func_9(int32_t *p_10, int8_t p_11) {
        1:   41:  int32_t *l_13 = (void *)0;
        1:   42:  int32_t l_24 = (-2L);
        1:   43:  int32_t l_29 = 0L;
        1:   44:  int32_t l_30 = 0x498A597FL;
        1:   45:  int32_t l_31 = 0L;
        1:   46:  int32_t l_32 = 1L;
        -:   47:  int32_t l_34[3];
        -:   48:  int i;
        4:   49:  for (i = 0; i < 3; i++)
        3:   50:    l_34[i] = (-3L);
        1:   51:  if ((*p_10)) {
    #####:   52:    return l_13;
        -:   53:  } else {
        1:   54:    int32_t l_25 = (-1L);
        1:   55:    int32_t l_26 = 4L;
        -:   56:    int32_t l_33[3];
        -:   57:    int i;
        4:   58:    for (i = 0; i < 3; i++)
        3:   59:      l_33[i] = 0xC5815DA7L;
       1*:   60:    for (p_11 = (-17); (p_11 <= (-28)); p_11 = safe_sub_func_int16_t_s_s(p_11, 1)) {
    #####:   61:      int16_t l_22[3][5] = {{(-1L), 1L, (-1L), (-1L), 1L}, {5L, 0x237FL, (-1L), 1L, 1L}, {0x237FL, 5L, 0x237FL, (-1L), 1L}};
    #####:   62:      int32_t l_23 = (-1L);
    #####:   63:      int32_t l_27 = (-1L);
        -:   64:      int32_t l_28[3][3][1];
    #####:   65:      int16_t l_35 = 0xB7CAL;
        -:   66:      int i, j, k;
    #####:   67:      for (i = 0; i < 3; i++) {
    #####:   68:        for (j = 0; j < 3; j++) {
    #####:   69:          for (k = 0; k < 1; k++)
    #####:   70:            l_28[i][j][k] = 0x36FE5438L;
        -:   71:        }
        -:   72:      }
    #####:   73:      for (g_4 = 0; (g_4 != 22); g_4++) {
    #####:   74:        int32_t l_18 = 0x6B3E713EL;
    #####:   75:        int32_t l_19 = 0L;
    #####:   76:        int32_t *l_20 = &l_19;
    #####:   77:        int32_t *l_21[5][5][2] = {{{&g_4, &g_4}, {&l_19, (void *)0}, {(void *)0, &l_19}, {&g_4, &g_4}, {&g_4, &l_19}}, {{(void *)0, (void *)0}, {&g_4, &l_19}, {&l_19, &l_19}, {&g_4, &g_4}, {&g_4, &g_4}}, {{&l_19, &l_19}, {&l_19, &g_4}, {&g_4, &g_4}, {&g_4, &l_19}, {&l_19, &l_19}}, {{&g_4, &g_4}, {&g_4, &g_4}, {&l_19, &l_19}, {&l_19, &g_4}, {&g_4, &g_4}}, {{&g_4, &l_19}, {&l_19, &l_19}, {&g_4, &g_4}, {&g_4, &g_4}, {&l_19, &l_19}}};
        -:   78:        int i, j, k;
    #####:   79:        ++g_36[0][0];
    #####:   80:        l_23 = 0x200A2DC1L;
        -:   81:      }
        -:   82:    }
        -:   83:  }
        1:   84:  (*p_10) = ((void *)0 == &l_34[0]);
        1:   85:  return p_10;
        -:   86:}
        -:   87:
        1:   88:int main(int argc, char *argv[]) {
        -:   89:  int i, j;
        1:   90:  int print_hash_value = 0;
       1*:   91:  if (argc == 2 && strcmp(argv[1], "1") == 0)
    #####:   92:    print_hash_value = 1;
        1:   93:  platform_main_begin();
        1:   94:  crc32_gentab();
        1:   95:  func_1();
        1:   96:  transparent_crc(g_2, "g_2", print_hash_value);
        4:   97:  for (i = 0; i < 3; i++) {
        6:   98:    for (j = 0; j < 1; j++) {
        3:   99:      transparent_crc(g_3[i][j], "g_3[i][j]", print_hash_value);
        3:  100:      if (print_hash_value)
    #####:  101:        printf("index = [%d][%d]\n", i, j);
        -:  102:    }
        -:  103:  }
        1:  104:  transparent_crc(g_4, "g_4", print_hash_value);
        2:  105:  for (i = 0; i < 1; i++) {
        1:  106:    transparent_crc(g_7[i].f0, "g_7[i].f0", print_hash_value);
        1:  107:    if (print_hash_value)
    #####:  108:      printf("index = [%d]\n", i);
        -:  109:  }
        4:  110:  for (i = 0; i < 3; i++) {
       18:  111:    for (j = 0; j < 5; j++) {
       15:  112:      transparent_crc(g_36[i][j], "g_36[i][j]", print_hash_value);
       15:  113:      if (print_hash_value)
    #####:  114:        printf("index = [%d][%d]\n", i, j);
        -:  115:    }
        -:  116:  }
        1:  117:  platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
        1:  118:  return 0;
        -:  119:}
