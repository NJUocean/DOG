        -:    0:Source:368.c
        -:    0:Graph:368.gcno
        -:    0:Data:368.gcda
        -:    0:Runs:1
        -:    1:// Options:   --concise --max-struct-fields 5 --max-funcs 2 --max-array-len-per-dim 5 --max-block-depth 3 --max-block-size 2
        -:    2:#include "csmith.h"
        -:    3:
        -:    4:static long __undefined;
        -:    5:
        -:    6:static int32_t g_10 = 0x96B779C6L;
        -:    7:static uint32_t g_15 = 0UL;
        -:    8:static const int8_t g_25 = 0xBDL;
        -:    9:static int32_t g_27 = 0L;
        -:   10:static volatile uint8_t g_34[3][5][5] = {{{0UL, 0x1FL, 255UL, 255UL, 0x1FL}, {1UL, 0x80L, 1UL, 0x95L, 251UL}, {0UL, 0x1FL, 255UL, 255UL, 0x1FL}, {1UL, 0x80L, 1UL, 0x95L, 251UL}, {0UL, 0x1FL, 255UL, 255UL, 0x1FL}}, {{1UL, 0x80L, 1UL, 0x95L, 251UL}, {0UL, 0x1FL, 255UL, 255UL, 0x1FL}, {1UL, 0x80L, 1UL, 0x95L, 251UL}, {0UL, 0x1FL, 255UL, 255UL, 0x1FL}, {1UL, 0x4DL, 251UL, 0x80L, 0xA5L}}, {{251UL, 0UL, 0x1FL, 0x1FL, 0UL}, {1UL, 0x4DL, 251UL, 0x80L, 0xA5L}, {251UL, 0UL, 0x1FL, 0x1FL, 0UL}, {1UL, 0x4DL, 251UL, 0x80L, 0xA5L}, {251UL, 0UL, 0x1FL, 0x1FL, 0UL}}};
        -:   11:static int32_t g_39 = 7L;
        -:   12:static int64_t g_58[1] = {0xF15F1D345D190450LL};
        -:   13:static uint32_t *g_65 = &g_15;
        -:   14:static uint32_t *g_68[1][2][3] = {{{&g_15, &g_15, &g_15}, {(void *)0, (void *)0, (void *)0}}};
        -:   15:static uint32_t **g_67 = &g_68[0][0][2];
        -:   16:static uint16_t g_70[4][5][4] = {{{0x5195L, 0x2088L, 0xA668L, 1UL}, {1UL, 65526UL, 0xA90DL, 0x2088L}, {0x2088L, 65532UL, 0xA90DL, 0x5B35L}, {1UL, 0x5F1FL, 0xA668L, 0xA90DL}, {0x5195L, 0xE2E6L, 0xF5C6L, 0x7437L}}, {{0xF5C6L, 0x7437L, 65526UL, 0x5AC2L}, {0x5F1FL, 65526UL, 1UL, 0xA668L}, {0x7437L, 65535UL, 0xB00CL, 0xB00CL}, {1UL, 1UL, 65535UL, 0xE27FL}, {0x5AC2L, 65532UL, 5UL, 0x7437L}}, {{0x5669L, 0x64A2L, 0xA668L, 5UL}, {0x45A0L, 0x64A2L, 1UL, 0x7437L}, {0x64A2L, 65532UL, 1UL, 0xE27FL}, {0x5F1FL, 1UL, 0x64A2L, 0xB00CL}, {0x5195L, 65535UL, 1UL, 0xA668L}}, {{0x5669L, 65526UL, 65535UL, 0x5AC2L}, {65534UL, 0x7437L, 0xA90DL, 0x7437L}, {65526UL, 0xE2E6L, 0xB00CL, 0xA90DL}, {0x45A0L, 0x5F1FL, 0x64A2L, 0x5B35L}, {0xF5C6L, 65532UL, 0x5669L, 0x2088L}}};
        -:   17:
        -:   18:static uint32_t func_1(void);
        -:   19:static const int64_t func_11(uint32_t p_12, int64_t p_13);
        -:   20:
        1:   21:static uint32_t func_1(void) {
        1:   22:  int8_t l_7 = (-9L);
        1:   23:  uint32_t *l_14 = &g_15;
        1:   24:  int32_t *l_26 = &g_27;
        1:   25:  int32_t *l_37 = (void *)0;
        1:   26:  int32_t *l_38 = &g_39;
        1:   27:  int32_t l_40 = 0L;
        1:   28:  uint8_t l_71 = 0x0FL;
        1:   29:  int32_t l_72 = 0L;
       1*:   30:  if (((((safe_div_func_int8_t_s_s((safe_mul_func_uint32_t_u_u((((*l_38) |= ((safe_unary_minus_func_uint8_t_u(((0x21AC4888L && l_7) & ((safe_add_func_int64_t_s_s((g_10 <= func_11(((*l_14)--), (l_7 != (g_10 || (g_10 & (safe_add_func_int32_t_s_s(((*l_26) = ((safe_sub_func_int16_t_s_s((((safe_sub_func_uint8_t_u_u(0x99L, 0x3CL)), ((safe_unary_minus_func_int32_t_s((0x7413L ^ g_25))) <= g_10)) > g_25), l_7)), g_25)), g_10))))))), 0x8D58945CB296AD98LL)) | 0x9AEB9D3763964E48LL)))), g_10)), 0x8EF5D3CCL), 0x4FF6A91AL)), 255UL)) ^ g_10) <= l_40) == 4294967295UL)) {
        -:   31:    return g_15;
        -:   32:  } else {
        4:   33:    for (g_39 = 0; g_39 < 3; g_39 += 1) {
       18:   34:      for (l_40 = 0; l_40 < 5; l_40 += 1) {
       90:   35:        for (g_15 = 0; g_15 < 5; g_15 += 1) {
       75:   36:          g_34[g_39][l_40][g_15] = 0x9CL;
        -:   37:        }
        -:   38:      }
        -:   39:    }
        4:   40:    for (l_7 = 2; (l_7 >= 0); l_7 -= 1) {
       12:   41:      for (g_39 = 0; g_39 < 3; g_39 += 1) {
       54:   42:        for (g_10 = 0; g_10 < 5; g_10 += 1) {
      270:   43:          for (g_15 = 0; g_15 < 5; g_15 += 1) {
      225:   44:            g_34[g_39][g_10][g_15] = 7UL;
        -:   45:          }
        -:   46:        }
        -:   47:      }
       12:   48:      for (l_40 = 0; (l_40 <= 2); l_40 += 1) {
        9:   49:        (*l_26) &= (0xE1L == g_10);
        -:   50:      }
        -:   51:    }
        -:   52:  }
       1*:   53:  for (l_40 = 12; (l_40 < 10); l_40--) {
    #####:   54:    uint32_t l_45 = 18446744073709551615UL;
    #####:   55:    uint32_t **l_46 = &l_14;
    #####:   56:    uint32_t *l_48[5][2] = {{&g_15, &g_15}, {&g_15, &g_15}, {&g_15, &g_15}, {&g_15, &g_15}, {&g_15, &g_15}};
    #####:   57:    uint32_t **l_47 = &l_48[2][0];
    #####:   58:    int64_t *l_57 = &g_58[0];
    #####:   59:    uint32_t *l_64 = &g_15;
    #####:   60:    uint32_t **l_63 = &l_64;
        -:   61:    uint32_t ***l_66[2];
        -:   62:    uint16_t *l_69[1][5];
        -:   63:    int i, j;
    #####:   64:    for (i = 0; i < 2; i++)
    #####:   65:      l_66[i] = &l_63;
    #####:   66:    for (i = 0; i < 1; i++) {
    #####:   67:      for (j = 0; j < 5; j++)
    #####:   68:        l_69[i][j] = &g_70[2][2][3];
        -:   69:    }
    #####:   70:    l_72 |= ((safe_mod_func_uint16_t_u_u((*l_26), l_45)) & ((((*l_47) = ((*l_46) = l_26)) == (void *)0) | (safe_add_func_int64_t_s_s(1L, (safe_sub_func_int64_t_s_s((safe_div_func_int16_t_s_s((0x7CL != ((safe_mod_func_int8_t_s_s((l_45 & (((*l_57) |= 0xF1A9F139888327BCLL) & ((safe_mul_func_uint8_t_u_u(((((((g_70[0][3][1] &= ((g_67 = ((safe_lshift_func_uint8_t_u_u(((g_65 = ((*l_63) = &g_15)) != &g_15), 5)), (void *)0)) != &g_68[0][0][2])) < 0UL), (*l_38)) > 0xD7CB4F91L) >= g_27) >= (*l_38)), l_45)), 0xE6D0914BD6B41A24LL))), g_25)) & l_45)), l_45)), l_71))))));
        -:   71:  }
        1:   72:  return (*l_38);
        -:   73:}
        -:   74:
        1:   75:static const int64_t func_11(uint32_t p_12, int64_t p_13) {
        1:   76:  uint32_t *l_29 = &g_15;
        1:   77:  uint32_t **l_28 = &l_29;
        1:   78:  int32_t *l_30 = &g_27;
        1:   79:  int32_t *l_31 = (void *)0;
        -:   80:  int32_t l_32[2];
        1:   81:  int32_t *l_33[2][4][5] = {{{(void *)0, &g_27, (void *)0, (void *)0, (void *)0}, {&g_27, &g_27, &l_32[1], &l_32[1], &l_32[0]}, {&g_27, (void *)0, (void *)0, &g_27, (void *)0}, {&l_32[0], &l_32[1], &l_32[1], &l_32[1], &l_32[1]}}, {{(void *)0, (void *)0, (void *)0, &g_27, &g_27}, {&g_27, &g_27, &g_27, &l_32[1], &l_32[1]}, {(void *)0, &g_27, &g_27, &g_27, (void *)0}, {&g_27, &l_32[0], &g_27, &l_32[1], &g_27}}};
        -:   82:  int i, j, k;
        3:   83:  for (i = 0; i < 2; i++)
        2:   84:    l_32[i] = 0L;
        1:   85:  l_28 = l_28;
        1:   86:  ++g_34[2][1][2];
        1:   87:  return g_25;
        -:   88:}
        -:   89:
        1:   90:int main(int argc, char *argv[]) {
        -:   91:  int i, j, k;
        1:   92:  int print_hash_value = 0;
       1*:   93:  if (argc == 2 && strcmp(argv[1], "1") == 0)
    #####:   94:    print_hash_value = 1;
        1:   95:  platform_main_begin();
        1:   96:  crc32_gentab();
        1:   97:  func_1();
        1:   98:  transparent_crc(g_10, "g_10", print_hash_value);
        1:   99:  transparent_crc(g_15, "g_15", print_hash_value);
        1:  100:  transparent_crc(g_25, "g_25", print_hash_value);
        1:  101:  transparent_crc(g_27, "g_27", print_hash_value);
        4:  102:  for (i = 0; i < 3; i++) {
       18:  103:    for (j = 0; j < 5; j++) {
       90:  104:      for (k = 0; k < 5; k++) {
       75:  105:        transparent_crc(g_34[i][j][k], "g_34[i][j][k]", print_hash_value);
       75:  106:        if (print_hash_value)
    #####:  107:          printf("index = [%d][%d][%d]\n", i, j, k);
        -:  108:      }
        -:  109:    }
        -:  110:  }
        1:  111:  transparent_crc(g_39, "g_39", print_hash_value);
        2:  112:  for (i = 0; i < 1; i++) {
        1:  113:    transparent_crc(g_58[i], "g_58[i]", print_hash_value);
        1:  114:    if (print_hash_value)
    #####:  115:      printf("index = [%d]\n", i);
        -:  116:  }
        5:  117:  for (i = 0; i < 4; i++) {
       24:  118:    for (j = 0; j < 5; j++) {
      100:  119:      for (k = 0; k < 4; k++) {
       80:  120:        transparent_crc(g_70[i][j][k], "g_70[i][j][k]", print_hash_value);
       80:  121:        if (print_hash_value)
    #####:  122:          printf("index = [%d][%d][%d]\n", i, j, k);
        -:  123:      }
        -:  124:    }
        -:  125:  }
        1:  126:  platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
        1:  127:  return 0;
        -:  128:}
