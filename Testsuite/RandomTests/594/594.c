// Options:   --concise --max-struct-fields 5 --max-funcs 2 --max-array-len-per-dim 5 --max-block-depth 3 --max-block-size 2
#include "csmith.h"

static long __undefined;

struct S0 {
  int32_t f0;
  uint8_t f1;
};

union U1 {
  volatile unsigned f0 : 9;
  int16_t f1;
};

union U2 {
  volatile struct S0 f0;
  int64_t f1;
};

static int32_t g_3 = 0x9CC14173L;
static int32_t g_4 = 0xA6957688L;
static int16_t g_14 = 0xAE0FL;
static int16_t g_16 = 0x641BL;
static union U1 g_26[2][1][3] = {{{{0UL}, {0UL}, {0UL}}}, {{{4294967295UL}, {4294967295UL}, {4294967295UL}}}};
static int32_t g_34 = 6L;
static uint64_t g_40 = 18446744073709551615UL;
static uint32_t g_49 = 0x7F141C5AL;
static struct S0 g_55 = {0xA95A2E20L, 1UL};
static struct S0 *volatile g_57[4][5] = {{(void *)0, (void *)0, (void *)0, (void *)0, (void *)0}, {&g_55, &g_55, &g_55, &g_55, &g_55}, {(void *)0, (void *)0, (void *)0, (void *)0, (void *)0}, {&g_55, &g_55, &g_55, &g_55, &g_55}};
static struct S0 *volatile g_58 = &g_55;
static volatile struct S0 g_62 = {1L, 1UL};
static volatile struct S0 *volatile g_61 = &g_62;
static volatile struct S0 *volatile *volatile g_60[3][2][4] = {{{&g_61, &g_61, &g_61, &g_61}, {&g_61, &g_61, &g_61, &g_61}}, {{&g_61, &g_61, &g_61, &g_61}, {&g_61, &g_61, &g_61, &g_61}}, {{&g_61, &g_61, &g_61, &g_61}, {&g_61, &g_61, &g_61, &g_61}}};
static volatile union U1 g_70 = {0x85F4F6E0L};
static uint32_t g_83 = 0UL;
static int16_t g_85 = (-9L);
static struct S0 g_92 = {6L, 0x79L};
static struct S0 *volatile g_91 = &g_92;
static union U2 g_94[3][1][5] = {{{{{0xFC517259L, 0xCBL}}, {{2L, 0xA5L}}, {{2L, 0xA5L}}, {{0xFC517259L, 0xCBL}}, {{2L, 0xA5L}}}}, {{{{0x38B96EC4L, 0xE7L}}, {{0x38B96EC4L, 0xE7L}}, {{3L, 0x86L}}, {{0x38B96EC4L, 0xE7L}}, {{0x38B96EC4L, 0xE7L}}}}, {{{{2L, 0xA5L}}, {{0xFC517259L, 0xCBL}}, {{2L, 0xA5L}}, {{2L, 0xA5L}}, {{0xFC517259L, 0xCBL}}}}};
static const union U2 g_98 = {{0x01C69F0BL, 255UL}};

static const union U2 func_1(void);
static const int32_t func_5(uint32_t p_6, uint8_t p_7, int8_t p_8, uint64_t p_9, uint16_t p_10);

static const union U2 func_1(void) {
  struct S0 l_2[2] = {{0x7555B7CEL, 1UL}, {0x7555B7CEL, 1UL}};
  int32_t l_17 = 2L;
  int32_t l_30[2];
  int8_t l_31[3][3] = {{0x04L, 0x04L, 0x04L}, {(-8L), (-8L), (-8L)}, {0x04L, 0x04L, 0x04L}};
  volatile struct S0 *volatile *volatile *l_97 = &g_60[0][1][2];
  int i, j;
  for (i = 0; i < 2; i++)
    l_30[i] = 0x20EA1BCAL;
  for (g_3 = 0; (g_3 <= 1); g_3 += 1) {
    const int8_t l_27 = 0x14L;
    int16_t *l_32 = (void *)0;
    union U2 *const l_93 = &g_94[0][0][3];
    for (g_4 = 1; (g_4 >= 0); g_4 -= 1) {
      uint32_t l_11 = 0xA53F0D3EL;
      int16_t *l_12 = (void *)0;
      int16_t *l_13 = &g_14;
      int16_t *l_15[5][4] = {{(void *)0, &g_16, &g_16, &g_16}, {&g_16, &g_16, &g_16, &g_16}, {(void *)0, (void *)0, &g_16, &g_16}, {&g_16, &g_16, &g_16, &g_16}, {&g_16, &g_16, &g_16, &g_16}};
      int32_t *l_33 = &g_34;
      int i, j;
    }
    for (g_40 = 0; (g_40 <= 1); g_40 += 1) {
      union U2 *l_96[4] = {(void *)0, (void *)0, (void *)0, (void *)0};
      union U2 **l_95 = &l_96[1];
      int i;
      (*l_95) = l_93;
    }
  }
  l_97 = &g_60[0][1][2];
  return g_98;
}

static const int32_t func_5(uint32_t p_6, uint8_t p_7, int8_t p_8, uint64_t p_9, uint16_t p_10) {
  const int16_t *l_37 = &g_14;
  int32_t l_43 = 0x0E816884L;
  int16_t l_81 = 0xC36EL;
  for (p_10 = 0; (p_10 <= 0); p_10 += 1) {
    uint64_t *l_39[1][4][5] = {{{&g_40, (void *)0, (void *)0, &g_40, &g_40}, {&g_40, (void *)0, &g_40, (void *)0, &g_40}, {&g_40, &g_40, (void *)0, (void *)0, &g_40}, {&g_40, (void *)0, &g_40, (void *)0, &g_40}}};
    int i, j, k;
    if ((safe_rshift_func_int64_t_s_u(((void *)0 == l_37), (g_40 = (~g_16))))) {
      int16_t l_48 = (-7L);
      if ((safe_sub_func_uint64_t_u_u(g_40, l_43))) {
        int32_t *l_44 = &g_34;
        int32_t *l_45 = &g_34;
        int32_t *l_46 = &l_43;
        int32_t *l_47[4] = {&l_43, &l_43, &l_43, &l_43};
        int i;
        --g_49;
      } else {
        int64_t l_52[5][2];
        int i, j;
        for (i = 0; i < 5; i++) {
          for (j = 0; j < 2; j++)
            l_52[i][j] = 4L;
        }
        if (l_52[3][1])
          break;
      }
    } else {
      for (g_14 = 0; (g_14 >= 0); g_14 -= 1) {
        struct S0 *l_54[1][3][5];
        struct S0 **l_53 = &l_54[0][0][0];
        int i, j, k;
        for (i = 0; i < 1; i++) {
          for (j = 0; j < 3; j++) {
            for (k = 0; k < 5; k++)
              l_54[i][j][k] = &g_55;
          }
        }
        (*l_53) = (void *)0;
      }
    }
    for (p_8 = 0; (p_8 >= 0); p_8 -= 1) {
      struct S0 l_56 = {0xCCBD95D6L, 0x68L};
      (*g_58) = l_56;
      for (p_9 = 0; (p_9 <= 0); p_9 += 1) {
        return l_43;
      }
      for (l_56.f0 = 0; (l_56.f0 >= 0); l_56.f0 -= 1) {
        struct S0 ***l_59[1];
        union U1 *l_64 = &g_26[1][0][2];
        union U1 **l_63 = &l_64;
        int i;
        for (i = 0; i < 1; i++)
          l_59[i] = (void *)0;
        g_60[0][1][2] = (void *)0;
        (*l_63) = (void *)0;
      }
    }
  }
  for (g_14 = (-1); (g_14 > 3); g_14++) {
    int8_t l_67 = 0x92L;
    int32_t l_69[3][5];
    int i, j;
    for (i = 0; i < 3; i++) {
      for (j = 0; j < 5; j++)
        l_69[i][j] = 0x60710019L;
    }
    if (l_67) {
      int32_t *l_68[3][3] = {{&l_43, &l_43, &l_43}, {&l_43, &g_34, &l_43}, {&l_43, &l_43, &l_43}};
      int i, j;
      l_69[1][4] |= 0x77DDBA47L;
      if (p_9)
        continue;
    } else {
      int16_t *l_76 = &g_26[1][0][2].f1;
      uint32_t *l_82 = &g_83;
      int32_t l_84 = (-1L);
      int32_t *l_86[3];
      int i;
      for (i = 0; i < 3; i++)
        l_86[i] = &g_34;
      g_34 = (((65529UL < (g_85 |= (((((g_70, ((((*l_82) &= (safe_add_func_uint16_t_u_u((+(-2L)), (((p_6 <= ((safe_sub_func_uint64_t_u_u(((((((*l_76) = p_6) < (g_55.f0 != 0x7DECC76BL)) == (safe_lshift_func_uint32_t_u_s((0xCFL <= ((safe_sub_func_int16_t_s_s(l_43, g_55.f1)), 3UL)), 6))), l_81) != 5L), g_49)) | p_7)), g_16) <= 0L)))) ^ g_49) <= g_16)) != 0x521466050866D820LL) <= l_84), p_6) < 5UL))) >= l_84) > l_84);
      for (l_67 = 0; (l_67 == (-28)); l_67 = safe_sub_func_int32_t_s_s(l_67, 2)) {
        return p_7;
      }
    }
  }
  return p_10;
}

int main(int argc, char *argv[]) {
  int i, j, k;
  int print_hash_value = 0;
  if (argc == 2 && strcmp(argv[1], "1") == 0)
    print_hash_value = 1;
  platform_main_begin();
  crc32_gentab();
  func_1();
  transparent_crc(g_3, "g_3", print_hash_value);
  transparent_crc(g_4, "g_4", print_hash_value);
  transparent_crc(g_14, "g_14", print_hash_value);
  transparent_crc(g_16, "g_16", print_hash_value);
  for (i = 0; i < 2; i++) {
    for (j = 0; j < 1; j++) {
      for (k = 0; k < 3; k++) {
        transparent_crc(g_26[i][j][k].f0, "g_26[i][j][k].f0", print_hash_value);
        if (print_hash_value)
          printf("index = [%d][%d][%d]\n", i, j, k);
      }
    }
  }
  transparent_crc(g_34, "g_34", print_hash_value);
  transparent_crc(g_40, "g_40", print_hash_value);
  transparent_crc(g_49, "g_49", print_hash_value);
  transparent_crc(g_55.f0, "g_55.f0", print_hash_value);
  transparent_crc(g_55.f1, "g_55.f1", print_hash_value);
  transparent_crc(g_62.f0, "g_62.f0", print_hash_value);
  transparent_crc(g_62.f1, "g_62.f1", print_hash_value);
  transparent_crc(g_70.f0, "g_70.f0", print_hash_value);
  transparent_crc(g_83, "g_83", print_hash_value);
  transparent_crc(g_85, "g_85", print_hash_value);
  transparent_crc(g_92.f0, "g_92.f0", print_hash_value);
  transparent_crc(g_92.f1, "g_92.f1", print_hash_value);
  for (i = 0; i < 3; i++) {
    for (j = 0; j < 1; j++) {
      for (k = 0; k < 5; k++) {
        transparent_crc(g_94[i][j][k].f0.f0, "g_94[i][j][k].f0.f0", print_hash_value);
        transparent_crc(g_94[i][j][k].f0.f1, "g_94[i][j][k].f0.f1", print_hash_value);
        if (print_hash_value)
          printf("index = [%d][%d][%d]\n", i, j, k);
      }
    }
  }
  transparent_crc(g_98.f0.f0, "g_98.f0.f0", print_hash_value);
  transparent_crc(g_98.f0.f1, "g_98.f0.f1", print_hash_value);
  platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
  return 0;
}
