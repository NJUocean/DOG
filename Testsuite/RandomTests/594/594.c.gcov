        -:    0:Source:594.c
        -:    0:Graph:594.gcno
        -:    0:Data:594.gcda
        -:    0:Runs:1
        -:    1:// Options:   --concise --max-struct-fields 5 --max-funcs 2 --max-array-len-per-dim 5 --max-block-depth 3 --max-block-size 2
        -:    2:#include "csmith.h"
        -:    3:
        -:    4:static long __undefined;
        -:    5:
        -:    6:struct S0 {
        -:    7:  int32_t f0;
        -:    8:  uint8_t f1;
        -:    9:};
        -:   10:
        -:   11:union U1 {
        -:   12:  volatile unsigned f0 : 9;
        -:   13:  int16_t f1;
        -:   14:};
        -:   15:
        -:   16:union U2 {
        -:   17:  volatile struct S0 f0;
        -:   18:  int64_t f1;
        -:   19:};
        -:   20:
        -:   21:static int32_t g_3 = 0x9CC14173L;
        -:   22:static int32_t g_4 = 0xA6957688L;
        -:   23:static int16_t g_14 = 0xAE0FL;
        -:   24:static int16_t g_16 = 0x641BL;
        -:   25:static union U1 g_26[2][1][3] = {{{{0UL}, {0UL}, {0UL}}}, {{{4294967295UL}, {4294967295UL}, {4294967295UL}}}};
        -:   26:static int32_t g_34 = 6L;
        -:   27:static uint64_t g_40 = 18446744073709551615UL;
        -:   28:static uint32_t g_49 = 0x7F141C5AL;
        -:   29:static struct S0 g_55 = {0xA95A2E20L, 1UL};
        -:   30:static struct S0 *volatile g_57[4][5] = {{(void *)0, (void *)0, (void *)0, (void *)0, (void *)0}, {&g_55, &g_55, &g_55, &g_55, &g_55}, {(void *)0, (void *)0, (void *)0, (void *)0, (void *)0}, {&g_55, &g_55, &g_55, &g_55, &g_55}};
        -:   31:static struct S0 *volatile g_58 = &g_55;
        -:   32:static volatile struct S0 g_62 = {1L, 1UL};
        -:   33:static volatile struct S0 *volatile g_61 = &g_62;
        -:   34:static volatile struct S0 *volatile *volatile g_60[3][2][4] = {{{&g_61, &g_61, &g_61, &g_61}, {&g_61, &g_61, &g_61, &g_61}}, {{&g_61, &g_61, &g_61, &g_61}, {&g_61, &g_61, &g_61, &g_61}}, {{&g_61, &g_61, &g_61, &g_61}, {&g_61, &g_61, &g_61, &g_61}}};
        -:   35:static volatile union U1 g_70 = {0x85F4F6E0L};
        -:   36:static uint32_t g_83 = 0UL;
        -:   37:static int16_t g_85 = (-9L);
        -:   38:static struct S0 g_92 = {6L, 0x79L};
        -:   39:static struct S0 *volatile g_91 = &g_92;
        -:   40:static union U2 g_94[3][1][5] = {{{{{0xFC517259L, 0xCBL}}, {{2L, 0xA5L}}, {{2L, 0xA5L}}, {{0xFC517259L, 0xCBL}}, {{2L, 0xA5L}}}}, {{{{0x38B96EC4L, 0xE7L}}, {{0x38B96EC4L, 0xE7L}}, {{3L, 0x86L}}, {{0x38B96EC4L, 0xE7L}}, {{0x38B96EC4L, 0xE7L}}}}, {{{{2L, 0xA5L}}, {{0xFC517259L, 0xCBL}}, {{2L, 0xA5L}}, {{2L, 0xA5L}}, {{0xFC517259L, 0xCBL}}}}};
        -:   41:static const union U2 g_98 = {{0x01C69F0BL, 255UL}};
        -:   42:
        -:   43:static const union U2 func_1(void);
        -:   44:static const int32_t func_5(uint32_t p_6, uint8_t p_7, int8_t p_8, uint64_t p_9, uint16_t p_10);
        -:   45:
        1:   46:static const union U2 func_1(void) {
        1:   47:  struct S0 l_2[2] = {{0x7555B7CEL, 1UL}, {0x7555B7CEL, 1UL}};
        1:   48:  int32_t l_17 = 2L;
        -:   49:  int32_t l_30[2];
        1:   50:  int8_t l_31[3][3] = {{0x04L, 0x04L, 0x04L}, {(-8L), (-8L), (-8L)}, {0x04L, 0x04L, 0x04L}};
        1:   51:  volatile struct S0 *volatile *volatile *l_97 = &g_60[0][1][2];
        -:   52:  int i, j;
        3:   53:  for (i = 0; i < 2; i++)
        2:   54:    l_30[i] = 0x20EA1BCAL;
        3:   55:  for (g_3 = 0; (g_3 <= 1); g_3 += 1) {
        2:   56:    const int8_t l_27 = 0x14L;
        2:   57:    int16_t *l_32 = (void *)0;
        2:   58:    union U2 *const l_93 = &g_94[0][0][3];
        6:   59:    for (g_4 = 1; (g_4 >= 0); g_4 -= 1) {
        4:   60:      uint32_t l_11 = 0xA53F0D3EL;
        4:   61:      int16_t *l_12 = (void *)0;
        4:   62:      int16_t *l_13 = &g_14;
        4:   63:      int16_t *l_15[5][4] = {{(void *)0, &g_16, &g_16, &g_16}, {&g_16, &g_16, &g_16, &g_16}, {(void *)0, (void *)0, &g_16, &g_16}, {&g_16, &g_16, &g_16, &g_16}, {&g_16, &g_16, &g_16, &g_16}};
        4:   64:      int32_t *l_33 = &g_34;
        -:   65:      int i, j;
        -:   66:    }
        6:   67:    for (g_40 = 0; (g_40 <= 1); g_40 += 1) {
        4:   68:      union U2 *l_96[4] = {(void *)0, (void *)0, (void *)0, (void *)0};
        4:   69:      union U2 **l_95 = &l_96[1];
        -:   70:      int i;
        4:   71:      (*l_95) = l_93;
        -:   72:    }
        -:   73:  }
        1:   74:  l_97 = &g_60[0][1][2];
        1:   75:  return g_98;
        -:   76:}
        -:   77:
    #####:   78:static const int32_t func_5(uint32_t p_6, uint8_t p_7, int8_t p_8, uint64_t p_9, uint16_t p_10) {
    #####:   79:  const int16_t *l_37 = &g_14;
    #####:   80:  int32_t l_43 = 0x0E816884L;
    #####:   81:  int16_t l_81 = 0xC36EL;
    #####:   82:  for (p_10 = 0; (p_10 <= 0); p_10 += 1) {
    #####:   83:    uint64_t *l_39[1][4][5] = {{{&g_40, (void *)0, (void *)0, &g_40, &g_40}, {&g_40, (void *)0, &g_40, (void *)0, &g_40}, {&g_40, &g_40, (void *)0, (void *)0, &g_40}, {&g_40, (void *)0, &g_40, (void *)0, &g_40}}};
        -:   84:    int i, j, k;
    #####:   85:    if ((safe_rshift_func_int64_t_s_u(((void *)0 == l_37), (g_40 = (~g_16))))) {
    #####:   86:      int16_t l_48 = (-7L);
    #####:   87:      if ((safe_sub_func_uint64_t_u_u(g_40, l_43))) {
    #####:   88:        int32_t *l_44 = &g_34;
    #####:   89:        int32_t *l_45 = &g_34;
    #####:   90:        int32_t *l_46 = &l_43;
    #####:   91:        int32_t *l_47[4] = {&l_43, &l_43, &l_43, &l_43};
        -:   92:        int i;
    #####:   93:        --g_49;
        -:   94:      } else {
        -:   95:        int64_t l_52[5][2];
        -:   96:        int i, j;
    #####:   97:        for (i = 0; i < 5; i++) {
    #####:   98:          for (j = 0; j < 2; j++)
    #####:   99:            l_52[i][j] = 4L;
        -:  100:        }
    #####:  101:        if (l_52[3][1])
    #####:  102:          break;
        -:  103:      }
        -:  104:    } else {
    #####:  105:      for (g_14 = 0; (g_14 >= 0); g_14 -= 1) {
        -:  106:        struct S0 *l_54[1][3][5];
    #####:  107:        struct S0 **l_53 = &l_54[0][0][0];
        -:  108:        int i, j, k;
    #####:  109:        for (i = 0; i < 1; i++) {
    #####:  110:          for (j = 0; j < 3; j++) {
    #####:  111:            for (k = 0; k < 5; k++)
    #####:  112:              l_54[i][j][k] = &g_55;
        -:  113:          }
        -:  114:        }
    #####:  115:        (*l_53) = (void *)0;
        -:  116:      }
        -:  117:    }
    #####:  118:    for (p_8 = 0; (p_8 >= 0); p_8 -= 1) {
    #####:  119:      struct S0 l_56 = {0xCCBD95D6L, 0x68L};
    #####:  120:      (*g_58) = l_56;
    #####:  121:      for (p_9 = 0; (p_9 <= 0); p_9 += 1) {
    #####:  122:        return l_43;
        -:  123:      }
    #####:  124:      for (l_56.f0 = 0; (l_56.f0 >= 0); l_56.f0 -= 1) {
        -:  125:        struct S0 ***l_59[1];
    #####:  126:        union U1 *l_64 = &g_26[1][0][2];
    #####:  127:        union U1 **l_63 = &l_64;
        -:  128:        int i;
    #####:  129:        for (i = 0; i < 1; i++)
    #####:  130:          l_59[i] = (void *)0;
    #####:  131:        g_60[0][1][2] = (void *)0;
    #####:  132:        (*l_63) = (void *)0;
        -:  133:      }
        -:  134:    }
        -:  135:  }
    #####:  136:  for (g_14 = (-1); (g_14 > 3); g_14++) {
    #####:  137:    int8_t l_67 = 0x92L;
        -:  138:    int32_t l_69[3][5];
        -:  139:    int i, j;
    #####:  140:    for (i = 0; i < 3; i++) {
    #####:  141:      for (j = 0; j < 5; j++)
    #####:  142:        l_69[i][j] = 0x60710019L;
        -:  143:    }
    #####:  144:    if (l_67) {
    #####:  145:      int32_t *l_68[3][3] = {{&l_43, &l_43, &l_43}, {&l_43, &g_34, &l_43}, {&l_43, &l_43, &l_43}};
        -:  146:      int i, j;
    #####:  147:      l_69[1][4] |= 0x77DDBA47L;
    #####:  148:      if (p_9)
    #####:  149:        continue;
        -:  150:    } else {
    #####:  151:      int16_t *l_76 = &g_26[1][0][2].f1;
    #####:  152:      uint32_t *l_82 = &g_83;
    #####:  153:      int32_t l_84 = (-1L);
        -:  154:      int32_t *l_86[3];
        -:  155:      int i;
    #####:  156:      for (i = 0; i < 3; i++)
    #####:  157:        l_86[i] = &g_34;
    #####:  158:      g_34 = (((65529UL < (g_85 |= (((((g_70, ((((*l_82) &= (safe_add_func_uint16_t_u_u((+(-2L)), (((p_6 <= ((safe_sub_func_uint64_t_u_u(((((((*l_76) = p_6) < (g_55.f0 != 0x7DECC76BL)) == (safe_lshift_func_uint32_t_u_s((0xCFL <= ((safe_sub_func_int16_t_s_s(l_43, g_55.f1)), 3UL)), 6))), l_81) != 5L), g_49)) | p_7)), g_16) <= 0L)))) ^ g_49) <= g_16)) != 0x521466050866D820LL) <= l_84), p_6) < 5UL))) >= l_84) > l_84);
    #####:  159:      for (l_67 = 0; (l_67 == (-28)); l_67 = safe_sub_func_int32_t_s_s(l_67, 2)) {
    #####:  160:        return p_7;
        -:  161:      }
        -:  162:    }
        -:  163:  }
    #####:  164:  return p_10;
        -:  165:}
        -:  166:
        1:  167:int main(int argc, char *argv[]) {
        -:  168:  int i, j, k;
        1:  169:  int print_hash_value = 0;
       1*:  170:  if (argc == 2 && strcmp(argv[1], "1") == 0)
    #####:  171:    print_hash_value = 1;
        1:  172:  platform_main_begin();
        1:  173:  crc32_gentab();
        1:  174:  func_1();
        1:  175:  transparent_crc(g_3, "g_3", print_hash_value);
        1:  176:  transparent_crc(g_4, "g_4", print_hash_value);
        1:  177:  transparent_crc(g_14, "g_14", print_hash_value);
        1:  178:  transparent_crc(g_16, "g_16", print_hash_value);
        3:  179:  for (i = 0; i < 2; i++) {
        4:  180:    for (j = 0; j < 1; j++) {
        8:  181:      for (k = 0; k < 3; k++) {
        6:  182:        transparent_crc(g_26[i][j][k].f0, "g_26[i][j][k].f0", print_hash_value);
        6:  183:        if (print_hash_value)
    #####:  184:          printf("index = [%d][%d][%d]\n", i, j, k);
        -:  185:      }
        -:  186:    }
        -:  187:  }
        1:  188:  transparent_crc(g_34, "g_34", print_hash_value);
        1:  189:  transparent_crc(g_40, "g_40", print_hash_value);
        1:  190:  transparent_crc(g_49, "g_49", print_hash_value);
        1:  191:  transparent_crc(g_55.f0, "g_55.f0", print_hash_value);
        1:  192:  transparent_crc(g_55.f1, "g_55.f1", print_hash_value);
        1:  193:  transparent_crc(g_62.f0, "g_62.f0", print_hash_value);
        1:  194:  transparent_crc(g_62.f1, "g_62.f1", print_hash_value);
        1:  195:  transparent_crc(g_70.f0, "g_70.f0", print_hash_value);
        1:  196:  transparent_crc(g_83, "g_83", print_hash_value);
        1:  197:  transparent_crc(g_85, "g_85", print_hash_value);
        1:  198:  transparent_crc(g_92.f0, "g_92.f0", print_hash_value);
        1:  199:  transparent_crc(g_92.f1, "g_92.f1", print_hash_value);
        4:  200:  for (i = 0; i < 3; i++) {
        6:  201:    for (j = 0; j < 1; j++) {
       18:  202:      for (k = 0; k < 5; k++) {
       15:  203:        transparent_crc(g_94[i][j][k].f0.f0, "g_94[i][j][k].f0.f0", print_hash_value);
       15:  204:        transparent_crc(g_94[i][j][k].f0.f1, "g_94[i][j][k].f0.f1", print_hash_value);
       15:  205:        if (print_hash_value)
    #####:  206:          printf("index = [%d][%d][%d]\n", i, j, k);
        -:  207:      }
        -:  208:    }
        -:  209:  }
        1:  210:  transparent_crc(g_98.f0.f0, "g_98.f0.f0", print_hash_value);
        1:  211:  transparent_crc(g_98.f0.f1, "g_98.f0.f1", print_hash_value);
        1:  212:  platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
        1:  213:  return 0;
        -:  214:}
