        -:    0:Source:278.c
        -:    0:Graph:278.gcno
        -:    0:Data:278.gcda
        -:    0:Runs:1
        -:    1:// Options:   --concise --max-struct-fields 5 --max-funcs 2 --max-array-len-per-dim 5 --max-block-depth 3 --max-block-size 2
        -:    2:#include "csmith.h"
        -:    3:
        -:    4:static long __undefined;
        -:    5:
        -:    6:static int8_t g_12 = 0x1FL;
        -:    7:static int32_t g_14 = 0x5D7249AAL;
        -:    8:static int32_t g_25 = (-4L);
        -:    9:static int32_t *g_24 = &g_25;
        -:   10:static uint64_t g_27 = 18446744073709551615UL;
        -:   11:static int64_t g_54 = 1L;
        -:   12:static uint8_t g_72 = 0x59L;
        -:   13:static volatile int16_t g_74 = 1L;
        -:   14:static volatile int16_t *volatile g_73 = &g_74;
        -:   15:static int16_t g_76[1] = {0L};
        -:   16:static uint32_t g_78 = 0x14C35F52L;
        -:   17:static uint16_t g_85 = 65526UL;
        -:   18:
        -:   19:static int32_t func_1(void);
        -:   20:static int32_t *func_2(int64_t p_3, int16_t p_4);
        -:   21:
        1:   22:static int32_t func_1(void) {
        1:   23:  int32_t *l_13 = &g_14;
        -:   24:  int32_t *l_16[3];
        1:   25:  int32_t **l_15 = &l_16[2];
        -:   26:  int32_t **l_23[2];
        1:   27:  uint64_t *l_26 = &g_27;
        -:   28:  int i;
        4:   29:  for (i = 0; i < 3; i++)
        3:   30:    l_16[i] = &g_14;
        3:   31:  for (i = 0; i < 2; i++)
        2:   32:    l_23[i] = (void *)0;
       1*:   33:  (*l_15) = func_2(((safe_lshift_func_uint16_t_u_s(0xB407L, ((((safe_unary_minus_func_int16_t_s((safe_sub_func_uint64_t_u_u((safe_mul_func_int64_t_s_s(g_12, ((*l_26) = ((((l_13 == ((*l_15) = l_13)) | ((safe_lshift_func_int8_t_s_u((safe_mod_func_int64_t_s_s((*l_13), ((safe_sub_func_uint16_t_u_u(((g_14 < ((g_24 = (void *)0) != &g_25)), ((((((g_25 = 6L) && g_12) == 6UL), g_25) == (*l_13)) >= g_12)), g_14)) ^ 3L))), 7)) != g_14)), g_25), 0x418EB0BADCAB3915LL)))), g_14)))) <= g_14) | g_14) && 4L))) > g_12), g_14);
        1:   34:  return (**l_15);
        -:   35:}
        -:   36:
        1:   37:static int32_t *func_2(int64_t p_3, int16_t p_4) {
        1:   38:  const uint8_t l_38 = 4UL;
        -:   39:  int32_t **l_45[2];
        1:   40:  uint16_t l_46 = 0x2F3AL;
        1:   41:  uint32_t l_51 = 0xF814D196L;
        1:   42:  int32_t ***l_52 = &l_45[0];
        -:   43:  int16_t *l_53[2][2];
        1:   44:  uint32_t *l_98 = (void *)0;
        -:   45:  int i, j;
        3:   46:  for (i = 0; i < 2; i++)
        2:   47:    l_45[i] = (void *)0;
        3:   48:  for (i = 0; i < 2; i++) {
        6:   49:    for (j = 0; j < 2; j++)
        4:   50:      l_53[i][j] = (void *)0;
        -:   51:  }
       1*:   52:  g_14 ^= (safe_lshift_func_int64_t_s_s((safe_rshift_func_int16_t_s_s((safe_rshift_func_uint64_t_u_u(((safe_mod_func_uint16_t_u_u(p_3, g_27)) > ((safe_rshift_func_int64_t_s_u(((l_38 || (safe_add_func_int16_t_s_s((((l_38 == 0xB637L) == (safe_add_func_uint16_t_u_u(p_3, ((safe_rshift_func_uint8_t_u_u(0x49L, 1)) < (g_27 | (((void *)0 != l_45[0]), p_4)))))) != p_3), 1UL))) || g_12), p_3)), l_46)), 24)), p_3)), 46));
       1*:   53:  if ((safe_sub_func_uint16_t_u_u((safe_sub_func_uint8_t_u_u((p_4 && p_4), l_51)), (g_54 ^= (&g_24 != ((*l_52) = l_45[0])))))) {
        1:   54:    int16_t *l_75 = &g_76[0];
        1:   55:    int32_t l_80 = 1L;
        1:   56:    int32_t l_96 = 0xCCF6B01AL;
        1:   57:    int32_t l_99 = 0x016C9CC5L;
        1:   58:    const int32_t *l_103 = &l_96;
        1:   59:    const int32_t **l_102 = &l_103;
        3:   60:    for (l_46 = 0; (l_46 != 6); l_46 = safe_add_func_int16_t_s_s(l_46, 3)) {
        2:   61:      uint8_t *l_71 = &g_72;
        -:   62:      uint32_t *l_77[3][1][1];
        2:   63:      int32_t l_79 = 0x775B4C71L;
        2:   64:      uint16_t *l_84 = &g_85;
        2:   65:      int8_t *l_97[5] = {&g_12, &g_12, &g_12, &g_12, &g_12};
        -:   66:      int i, j, k;
        8:   67:      for (i = 0; i < 3; i++) {
       12:   68:        for (j = 0; j < 1; j++) {
       12:   69:          for (k = 0; k < 1; k++)
        6:   70:            l_77[i][j][k] = &g_78;
        -:   71:        }
        -:   72:      }
       2*:   73:      l_80 = (safe_div_func_uint64_t_u_u((safe_div_func_uint64_t_u_u(((safe_unary_minus_func_uint64_t_u((safe_rshift_func_int64_t_s_u(0x9721CB4F50F898D4LL, 61)))) != ((void *)0 == &l_45[0])), g_25)), ((safe_mul_func_int64_t_s_s((((l_79 ^= (safe_rshift_func_int64_t_s_u(((((((void *)0 == &l_45[0]), (((safe_rshift_func_uint32_t_u_u((((*l_71) = (~0xCFL)) > g_54), 22)), g_73) == l_75)), 0x5AA0404CL), &g_24) == (void *)0), g_27))) < p_3) && p_3), g_54)), p_4)));
        2:   74:      l_99 |= (((18446744073709551607UL ^ (((((((+(((safe_div_func_uint64_t_u_u(((((0xBAL | ((-5L) ^ 0x95F91B207691369FLL)) ^ ((*l_84) = p_3)), ((-1L) || (((g_12 = (safe_lshift_func_int32_t_s_s((safe_mul_func_uint16_t_u_u((l_80 = (safe_lshift_func_uint16_t_u_s((safe_mod_func_int16_t_s_s(p_3, l_79)), 14))), ((safe_sub_func_int8_t_s_s(0xB5L, p_4)) < l_96))), p_4))) == 5L) | 0x6ED2L))), g_54), 1UL)) | l_79), p_3)), g_85), 1UL) || 7UL) < p_3) <= 0xF7F6FD02479DA46ALL) < 0x61L)), l_98) != &g_78);
        -:   75:    }
        5:   76:    for (l_96 = 0; (l_96 != 8); l_96 = safe_add_func_int32_t_s_s(l_96, 2)) {
        4:   77:      const int32_t ***l_104 = &l_102;
        4:   78:      (*l_104) = l_102;
        -:   79:    }
        -:   80:  } else {
    #####:   81:    for (g_14 = 0; (g_14 <= 1); g_14++) {
    #####:   82:      for (g_25 = 0; g_25 < 2; g_25 += 1) {
    #####:   83:        l_45[g_25] = (void *)0;
        -:   84:      }
    #####:   85:      for (g_12 = 0; g_12 < 2; g_12 += 1) {
    #####:   86:        l_45[g_12] = &g_24;
        -:   87:      }
        -:   88:    }
        -:   89:  }
        1:   90:  return &g_25;
        -:   91:}
        -:   92:
        1:   93:int main(int argc, char *argv[]) {
        -:   94:  int i;
        1:   95:  int print_hash_value = 0;
       1*:   96:  if (argc == 2 && strcmp(argv[1], "1") == 0)
    #####:   97:    print_hash_value = 1;
        1:   98:  platform_main_begin();
        1:   99:  crc32_gentab();
        1:  100:  func_1();
        1:  101:  transparent_crc(g_12, "g_12", print_hash_value);
        1:  102:  transparent_crc(g_14, "g_14", print_hash_value);
        1:  103:  transparent_crc(g_25, "g_25", print_hash_value);
        1:  104:  transparent_crc(g_27, "g_27", print_hash_value);
        1:  105:  transparent_crc(g_54, "g_54", print_hash_value);
        1:  106:  transparent_crc(g_72, "g_72", print_hash_value);
        1:  107:  transparent_crc(g_74, "g_74", print_hash_value);
        2:  108:  for (i = 0; i < 1; i++) {
        1:  109:    transparent_crc(g_76[i], "g_76[i]", print_hash_value);
        1:  110:    if (print_hash_value)
    #####:  111:      printf("index = [%d]\n", i);
        -:  112:  }
        1:  113:  transparent_crc(g_78, "g_78", print_hash_value);
        1:  114:  transparent_crc(g_85, "g_85", print_hash_value);
        1:  115:  platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
        1:  116:  return 0;
        -:  117:}
