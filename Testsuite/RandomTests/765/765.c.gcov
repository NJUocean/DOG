        -:    0:Source:765.c
        -:    0:Graph:765.gcno
        -:    0:Data:765.gcda
        -:    0:Runs:1
        -:    1:// Options:   --concise --max-struct-fields 5 --max-funcs 2 --max-array-len-per-dim 5 --max-block-depth 3 --max-block-size 2
        -:    2:#include "csmith.h"
        -:    3:
        -:    4:static long __undefined;
        -:    5:
        -:    6:struct S0 {
        -:    7:  volatile unsigned f0 : 16;
        -:    8:  volatile signed f1 : 5;
        -:    9:};
        -:   10:
        -:   11:static int32_t g_3 = (-1L);
        -:   12:static volatile int32_t g_7[2] = {0x737A9A97L, 0x737A9A97L};
        -:   13:static volatile uint16_t g_8[5][5] = {{0x265EL, 0x265EL, 0x265EL, 0x265EL, 0x265EL}, {0x391CL, 5UL, 0x391CL, 5UL, 0x391CL}, {0x265EL, 0x265EL, 0x265EL, 0x265EL, 0x265EL}, {0x391CL, 5UL, 0x391CL, 5UL, 0x391CL}, {0x265EL, 0x265EL, 0x265EL, 0x265EL, 0x265EL}};
        -:   14:static uint64_t g_18 = 4UL;
        -:   15:static uint32_t g_22 = 0xB38EB16EL;
        -:   16:static int32_t *g_41 = &g_3;
        -:   17:static uint8_t g_44[3] = {0xFAL, 0xFAL, 0xFAL};
        -:   18:static int16_t g_46 = 3L;
        -:   19:static int16_t g_81 = 0x582BL;
        -:   20:static int16_t *g_88[4] = {&g_46, &g_46, &g_46, &g_46};
        -:   21:static int64_t g_98 = 0xD6F689573D52B769LL;
        -:   22:
        -:   23:static int16_t func_1(void);
        -:   24:static int32_t func_11(int32_t *const p_12, uint32_t p_13, uint64_t p_14, int32_t *p_15);
        -:   25:
        1:   26:static int16_t func_1(void) {
        1:   27:  int32_t *l_2 = &g_3;
        1:   28:  int32_t *l_4 = &g_3;
        1:   29:  int32_t l_5 = (-2L);
        -:   30:  int32_t *l_6[5];
        1:   31:  int32_t *const l_16 = &g_3;
        1:   32:  uint64_t *l_17 = &g_18;
        1:   33:  int32_t **l_19 = &l_4;
        1:   34:  uint32_t *l_21[5][4][3] = {{{(void *)0, (void *)0, (void *)0}, {&g_22, (void *)0, &g_22}, {(void *)0, (void *)0, (void *)0}, {&g_22, (void *)0, &g_22}}, {{(void *)0, (void *)0, (void *)0}, {&g_22, (void *)0, &g_22}, {(void *)0, (void *)0, (void *)0}, {&g_22, (void *)0, &g_22}}, {{(void *)0, (void *)0, (void *)0}, {&g_22, (void *)0, &g_22}, {(void *)0, (void *)0, (void *)0}, {&g_22, (void *)0, &g_22}}, {{(void *)0, (void *)0, (void *)0}, {&g_22, (void *)0, &g_22}, {(void *)0, (void *)0, (void *)0}, {&g_22, (void *)0, &g_22}}, {{(void *)0, (void *)0, (void *)0}, {&g_22, (void *)0, &g_22}, {(void *)0, (void *)0, (void *)0}, {&g_22, (void *)0, &g_22}}};
        1:   35:  uint16_t l_60 = 0xE444L;
        1:   36:  int64_t l_62 = 0L;
        1:   37:  int32_t l_79 = 0xA2B86846L;
        -:   38:  uint32_t l_82[1];
        1:   39:  int16_t *l_86 = &g_81;
        1:   40:  int32_t l_97 = (-5L);
        -:   41:  int i, j, k;
        6:   42:  for (i = 0; i < 5; i++)
        5:   43:    l_6[i] = &g_3;
        2:   44:  for (i = 0; i < 1; i++)
        1:   45:    l_82[i] = 4294967293UL;
        1:   46:  ++g_8[1][0];
       1*:   47:  if (func_11(l_16, (*l_2), ((*l_17) = (&g_3 != &l_5)), ((((&l_5 == ((*l_19) = (void *)0)) ^ ((+((0x523DD972C40A98CELL && g_7[1]) ^ ((g_22 = 4294967288UL) && g_22))) == g_3)) > g_3), (*l_19)))) {
        1:   48:    int8_t l_30 = 0x86L;
        1:   49:    uint16_t l_42 = 0UL;
        1:   50:    uint8_t *l_43[4][2][3] = {{{&g_44[0], &g_44[0], (void *)0}, {(void *)0, (void *)0, &g_44[0]}}, {{&g_44[0], &g_44[0], (void *)0}, {(void *)0, (void *)0, &g_44[0]}}, {{&g_44[0], &g_44[0], (void *)0}, {(void *)0, (void *)0, &g_44[0]}}, {{&g_44[0], &g_44[0], (void *)0}, {(void *)0, (void *)0, &g_44[0]}}};
        1:   51:    int16_t *l_45 = &g_46;
        1:   52:    int32_t l_47 = 0L;
        1:   53:    struct S0 *l_63 = (void *)0;
        1:   54:    uint16_t l_64 = 0UL;
        -:   55:    int i, j, k;
        1:   56:    l_47 &= ((*l_16) = (safe_mod_func_int16_t_s_s(((*l_45) = (safe_sub_func_uint64_t_u_u((safe_mul_func_uint32_t_u_u((g_8[1][0] > l_30), (safe_mul_func_int8_t_s_s((safe_div_func_uint16_t_u_u((safe_lshift_func_uint16_t_u_s(0UL, (((*l_19) = &g_3) != ((((g_44[0] |= (safe_lshift_func_int64_t_s_u((safe_lshift_func_uint32_t_u_u(((0x88F15EA3L && g_18) | ((((g_22, &g_3) != g_41) == g_22), l_42)), 22)), g_3))), g_44[1]), g_44[1]), (void *)0)))), g_22)), 0xB3L)))), g_22))), l_42)));
       1*:   57:    for (l_5 = 0; (l_5 <= (-23)); l_5--) {
        -:   58:      const uint16_t l_50[3] = {1UL, 1UL, 1UL};
    #####:   59:      uint16_t *l_59 = &l_42;
    #####:   60:      int8_t *l_61 = (void *)0;
        -:   61:      int i;
    #####:   62:      if (((l_50[2] < (safe_div_func_uint64_t_u_u(l_50[0], ((safe_mul_func_int64_t_s_s((((g_44[2] <= l_50[2]) != (0xF72DA61EB613644CLL || ((l_62 = (safe_sub_func_int16_t_s_s(((**l_19) > ((safe_add_func_int16_t_s_s((((*l_59) |= g_8[1][0]) < l_60), ((**l_19) | l_47))) > g_44[0])), g_44[2]))) & l_30))) >= g_44[1]), 0x1FA943C7D870105CLL)), l_50[2])))), (*g_41))) {
    #####:   63:        l_63 = (void *)0;
        -:   64:      } else {
    #####:   65:        return l_64;
        -:   66:      }
    #####:   67:      if ((*g_41))
    #####:   68:        break;
        -:   69:    }
        -:   70:  } else {
    #####:   71:    int64_t l_68 = 0xCB0470BDE7D1E91BLL;
    #####:   72:    int16_t *l_80 = &g_81;
    #####:   73:    int32_t l_96 = 8L;
    #####:   74:    uint32_t l_99 = 9UL;
    #####:   75:    if ((g_7[1] < (safe_sub_func_uint16_t_u_u(0xEF21L, (safe_unary_minus_func_uint64_t_u((((((l_68 & ((safe_add_func_uint8_t_u_u((safe_add_func_uint8_t_u_u((safe_mod_func_uint64_t_u_u((((((safe_mod_func_int8_t_s_s(g_46, ((g_3 != 7L) | (l_68 > (((*l_80) = (((safe_lshift_func_int8_t_s_s(((l_79 & ((1UL < 0xF6L), g_44[1])), g_46), 1)) > (*l_2)) || 0xA32D9FB0E7FB9BE9LL)) ^ g_18))))) >= g_18) <= 0xEBL), g_3) <= g_44[0]), 8L)), 0L)), l_68)), l_68)) | 0L), 0x3CACAAAB22D3B6D3LL), 0xC3E4L) == l_82[0]))))))) {
    #####:   76:      int16_t **l_85 = &l_80;
    #####:   77:      int16_t **l_87[4][5] = {{&l_86, &l_86, &l_86, &l_86, &l_86}, {&l_86, &l_86, &l_86, &l_86, &l_86}, {&l_86, &l_86, &l_86, &l_86, &l_86}, {&l_86, &l_86, &l_86, &l_86, &l_86}};
    #####:   78:      const int32_t l_95 = 0x4792CDF4L;
        -:   79:      int i, j;
    #####:   80:      (*g_41) = (g_8[4][4], ((g_44[0] >= ((((255UL >= g_7[1]) != 0UL) ^ (l_96 = (((((*l_85) = &g_46) == (g_88[0] = l_86)) != (((safe_div_func_uint8_t_u_u((*l_2), ((safe_rshift_func_uint16_t_u_s(((((safe_div_func_uint32_t_u_u(((*l_2) != (*g_41)), (*g_41))) > l_95) == (*l_2)), g_81), 4)), 250UL))) & g_18) && (*g_41))), 0xDA69L))) < l_95)) & l_97));
        -:   81:    } else {
    #####:   82:      --l_99;
    #####:   83:      return l_68;
        -:   84:    }
        -:   85:  }
        1:   86:  return (*l_16);
        -:   87:}
        -:   88:
        1:   89:static int32_t func_11(int32_t *const p_12, uint32_t p_13, uint64_t p_14, int32_t *p_15) {
        1:   90:  int32_t *l_23 = &g_3;
        1:   91:  l_23 = &g_3;
        1:   92:  return g_18;
        -:   93:}
        -:   94:
        1:   95:int main(int argc, char *argv[]) {
        -:   96:  int i, j;
        1:   97:  int print_hash_value = 0;
       1*:   98:  if (argc == 2 && strcmp(argv[1], "1") == 0)
    #####:   99:    print_hash_value = 1;
        1:  100:  platform_main_begin();
        1:  101:  crc32_gentab();
        1:  102:  func_1();
        1:  103:  transparent_crc(g_3, "g_3", print_hash_value);
        3:  104:  for (i = 0; i < 2; i++) {
        2:  105:    transparent_crc(g_7[i], "g_7[i]", print_hash_value);
        2:  106:    if (print_hash_value)
    #####:  107:      printf("index = [%d]\n", i);
        -:  108:  }
        6:  109:  for (i = 0; i < 5; i++) {
       30:  110:    for (j = 0; j < 5; j++) {
       25:  111:      transparent_crc(g_8[i][j], "g_8[i][j]", print_hash_value);
       25:  112:      if (print_hash_value)
    #####:  113:        printf("index = [%d][%d]\n", i, j);
        -:  114:    }
        -:  115:  }
        1:  116:  transparent_crc(g_18, "g_18", print_hash_value);
        1:  117:  transparent_crc(g_22, "g_22", print_hash_value);
        4:  118:  for (i = 0; i < 3; i++) {
        3:  119:    transparent_crc(g_44[i], "g_44[i]", print_hash_value);
        3:  120:    if (print_hash_value)
    #####:  121:      printf("index = [%d]\n", i);
        -:  122:  }
        1:  123:  transparent_crc(g_46, "g_46", print_hash_value);
        1:  124:  transparent_crc(g_81, "g_81", print_hash_value);
        1:  125:  transparent_crc(g_98, "g_98", print_hash_value);
        1:  126:  platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
        1:  127:  return 0;
        -:  128:}
