// Options:   --concise --max-struct-fields 5 --max-funcs 2 --max-array-len-per-dim 5 --max-block-depth 3 --max-block-size 2
#include "csmith.h"

static long __undefined;

union U0 {
  const int32_t f0;
  int64_t f1;
};

static volatile int32_t g_2 = 4L;
static volatile int32_t g_3[1] = {(-1L)};
static volatile int32_t g_4 = 0x768C0AA3L;
static volatile int32_t g_5[2][1][2] = {{{(-1L), (-1L)}}, {{(-1L), (-1L)}}};
static int32_t g_6[3] = {0x78F3C34EL, 0x78F3C34EL, 0x78F3C34EL};
static int32_t g_9[4] = {3L, 3L, 3L, 3L};
static volatile int32_t g_12[5][4][1] = {{{1L}, {0x7E6AA165L}, {1L}, {2L}}, {{0x91B68DEEL}, {0x91B68DEEL}, {2L}, {1L}}, {{0x7E6AA165L}, {1L}, {2L}, {0x91B68DEEL}}, {{0x91B68DEEL}, {2L}, {1L}, {0x7E6AA165L}}, {{1L}, {2L}, {0x91B68DEEL}, {0x91B68DEEL}}};
static int32_t g_13 = (-10L);
static uint8_t g_24 = 0x15L;
static uint8_t g_30 = 255UL;
static uint8_t **g_34 = (void *)0;
static uint16_t g_41[3][1] = {{65534UL}, {65534UL}, {65534UL}};
static int32_t g_45 = 0xD2CF1A50L;
static volatile int32_t *g_47 = &g_2;
static volatile int32_t **volatile g_46 = &g_47;
static int32_t *volatile g_50 = (void *)0;

static int32_t func_1(void);
static uint32_t func_17(union U0 p_18, uint32_t p_19);

static int32_t func_1(void) {
  int16_t l_52 = (-10L);
  for (g_6[2] = 0; (g_6[2] <= (-19)); --g_6[2]) {
    const int64_t l_16[1] = {5L};
    int32_t l_49 = 0x008693C2L;
    int i;
    for (g_9[1] = (-27); (g_9[1] > (-30)); --g_9[1]) {
      for (g_13 = 0; (g_13 != (-13)); --g_13) {
        union U0 l_20 = {3L};
        int32_t *l_48 = (void *)0;
        int32_t *l_51 = &g_45;
        if (l_16[0])
          break;
        (*l_51) = (func_17(l_20, g_9[1]) == (l_49 = g_6[2]));
      }
      if (l_16[0])
        continue;
    }
  }
  return l_52;
}

static uint32_t func_17(union U0 p_18, uint32_t p_19) {
  int32_t l_27[1][2];
  uint8_t **l_31 = (void *)0;
  int i, j;
  for (i = 0; i < 1; i++) {
    for (j = 0; j < 2; j++)
      l_27[i][j] = (-3L);
  }
  for (p_19 = 0; (p_19 <= 0); p_19 += 1) {
    uint8_t *l_23 = &g_24;
    uint8_t *l_29 = &g_30;
    uint8_t **l_28 = &l_29;
    uint8_t ***l_32[1][5];
    int32_t l_42 = 3L;
    int i, j;
    for (i = 0; i < 1; i++) {
      for (j = 0; j < 5; j++)
        l_32[i][j] = (void *)0;
    }
    g_3[p_19] = ((safe_mod_func_uint8_t_u_u((g_3[p_19], ((*l_23) = 0xD7L)), 0x9FL)) > ((((safe_mul_func_uint64_t_u_u((l_23 != (void *)0), (l_27[0][1] ^ ((((((*l_28) = l_23) == ((&l_23 == (l_31 = l_31)), &g_30)) | g_6[2]) <= l_27[0][1]) & g_6[2])))) > 4294967289UL), g_9[3]), 8L));
    for (p_18.f1 = 0; (p_18.f1 <= 0); p_18.f1 += 1) {
      uint8_t **l_33[3];
      uint16_t *l_40[3][3][5] = {{{&g_41[2][0], (void *)0, &g_41[2][0], &g_41[2][0], &g_41[2][0]}, {(void *)0, &g_41[2][0], &g_41[1][0], &g_41[2][0], (void *)0}, {(void *)0, (void *)0, &g_41[1][0], &g_41[2][0], &g_41[2][0]}}, {{(void *)0, &g_41[2][0], &g_41[2][0], &g_41[2][0], &g_41[2][0]}, {&g_41[2][0], &g_41[1][0], &g_41[2][0], (void *)0, &g_41[2][0]}, {(void *)0, &g_41[2][0], &g_41[2][0], (void *)0, &g_41[2][0]}}, {{&g_41[2][0], &g_41[2][0], &g_41[2][0], &g_41[2][0], &g_41[2][0]}, {&g_41[2][0], &g_41[2][0], &g_41[2][0], &g_41[2][0], &g_41[1][0]}, {&g_41[1][0], &g_41[2][0], &g_41[2][0], &g_41[0][0], &g_41[2][0]}}};
      int32_t *l_43 = &l_27[0][0];
      int32_t *l_44 = &g_45;
      int i, j, k;
      for (i = 0; i < 3; i++)
        l_33[i] = &l_23;
      (*l_44) &= ((*l_43) = ((((l_33[2] = l_33[2]) != (g_34 = (void *)0)) == 0xB2213AABDC9A81FFLL) >= (safe_lshift_func_uint16_t_u_u((safe_lshift_func_uint16_t_u_u((l_42 = (~0x34E4A53E8AF80453LL)), 3)), (0xA35E06C08385637ELL > g_2)))));
      for (g_24 = 0; (g_24 <= 0); g_24 += 1) {
        int i, j, k;
        (*g_46) = &g_12[p_19][(p_19 + 3)][g_24];
      }
    }
  }
  return p_19;
}

int main(int argc, char *argv[]) {
  int i, j, k;
  int print_hash_value = 0;
  if (argc == 2 && strcmp(argv[1], "1") == 0)
    print_hash_value = 1;
  platform_main_begin();
  crc32_gentab();
  func_1();
  transparent_crc(g_2, "g_2", print_hash_value);
  for (i = 0; i < 1; i++) {
    transparent_crc(g_3[i], "g_3[i]", print_hash_value);
    if (print_hash_value)
      printf("index = [%d]\n", i);
  }
  transparent_crc(g_4, "g_4", print_hash_value);
  for (i = 0; i < 2; i++) {
    for (j = 0; j < 1; j++) {
      for (k = 0; k < 2; k++) {
        transparent_crc(g_5[i][j][k], "g_5[i][j][k]", print_hash_value);
        if (print_hash_value)
          printf("index = [%d][%d][%d]\n", i, j, k);
      }
    }
  }
  for (i = 0; i < 3; i++) {
    transparent_crc(g_6[i], "g_6[i]", print_hash_value);
    if (print_hash_value)
      printf("index = [%d]\n", i);
  }
  for (i = 0; i < 4; i++) {
    transparent_crc(g_9[i], "g_9[i]", print_hash_value);
    if (print_hash_value)
      printf("index = [%d]\n", i);
  }
  for (i = 0; i < 5; i++) {
    for (j = 0; j < 4; j++) {
      for (k = 0; k < 1; k++) {
        transparent_crc(g_12[i][j][k], "g_12[i][j][k]", print_hash_value);
        if (print_hash_value)
          printf("index = [%d][%d][%d]\n", i, j, k);
      }
    }
  }
  transparent_crc(g_13, "g_13", print_hash_value);
  transparent_crc(g_24, "g_24", print_hash_value);
  transparent_crc(g_30, "g_30", print_hash_value);
  for (i = 0; i < 3; i++) {
    for (j = 0; j < 1; j++) {
      transparent_crc(g_41[i][j], "g_41[i][j]", print_hash_value);
      if (print_hash_value)
        printf("index = [%d][%d]\n", i, j);
    }
  }
  transparent_crc(g_45, "g_45", print_hash_value);
  platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
  return 0;
}
