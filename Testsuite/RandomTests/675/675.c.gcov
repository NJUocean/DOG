        -:    0:Source:675.c
        -:    0:Graph:675.gcno
        -:    0:Data:675.gcda
        -:    0:Runs:1
        -:    1:// Options:   --concise --max-struct-fields 5 --max-funcs 2 --max-array-len-per-dim 5 --max-block-depth 3 --max-block-size 2
        -:    2:#include "csmith.h"
        -:    3:
        -:    4:static long __undefined;
        -:    5:
        -:    6:static volatile uint32_t g_4 = 0xB733C633L;
        -:    7:static int16_t g_5 = 0L;
        -:    8:static uint32_t g_44 = 0x87122A22L;
        -:    9:static int64_t g_46 = 7L;
        -:   10:static uint16_t g_47[2] = {65535UL, 65535UL};
        -:   11:static uint8_t g_49 = 0x52L;
        -:   12:static int32_t g_52 = 0xBF9CC53AL;
        -:   13:static int32_t *volatile g_51 = &g_52;
        -:   14:static int32_t g_56 = (-10L);
        -:   15:static volatile int32_t g_68 = 0L;
        -:   16:static volatile int64_t g_69 = (-6L);
        -:   17:static volatile int32_t g_71 = 0xCD5900A0L;
        -:   18:static volatile uint16_t g_72[3] = {0x2314L, 0x2314L, 0x2314L};
        -:   19:static int32_t g_78 = 8L;
        -:   20:static int8_t g_88 = 0x84L;
        -:   21:static int8_t g_94 = 1L;
        -:   22:static int8_t *g_93 = &g_94;
        -:   23:
        -:   24:static int64_t func_1(void);
        -:   25:static uint32_t func_20(int64_t p_21, uint16_t p_22, int32_t p_23);
        -:   26:
        1:   27:static int64_t func_1(void) {
        1:   28:  int32_t l_8 = 1L;
        1:   29:  int32_t l_11 = 0x9A5A40F2L;
        1:   30:  int32_t l_24 = 0xBB9CF7D1L;
        1:   31:  int64_t *l_85 = &g_46;
        1:   32:  int8_t *const l_112 = &g_88;
        1:   33:  int32_t *l_130 = &g_78;
        -:   34:  int32_t **l_129[2];
        1:   35:  int32_t ***l_128 = &l_129[0];
        1:   36:  uint8_t l_131 = 1UL;
        1:   37:  uint8_t l_134 = 250UL;
        -:   38:  int i;
        3:   39:  for (i = 0; i < 2; i++)
        2:   40:    l_129[i] = &l_130;
        1:   41:  if ((((g_4 & g_5) == ((safe_mul_func_uint8_t_u_u(254UL, l_8)) > ((((safe_add_func_int32_t_s_s(0xC865B49DL, (l_11 = (-6L)))), ((safe_mod_func_uint64_t_u_u(g_5, 7UL)) ^ (l_8 >= g_5))), 0xAFD061A652065C82LL) || l_8))), l_8)) {
        1:   42:    int32_t l_38 = 0L;
        1:   43:    uint32_t *l_43 = &g_44;
        1:   44:    int64_t *l_45 = &g_46;
        1:   45:    uint8_t *l_48[2][5] = {{&g_49, &g_49, (void *)0, (void *)0, &g_49}, {&g_49, &g_49, (void *)0, (void *)0, &g_49}};
        1:   46:    int32_t *l_77 = &g_78;
        -:   47:    int i, j;
       1*:   48:    (*l_77) &= (safe_rshift_func_int32_t_s_u(((safe_add_func_uint64_t_u_u((safe_lshift_func_uint32_t_u_s(func_20((l_24, (((-2L) | 0xFBL) && (safe_mod_func_int16_t_s_s(g_4, (safe_sub_func_int16_t_s_s(((g_49 = (g_47[1] = (safe_rshift_func_int8_t_s_s(((((safe_mod_func_int64_t_s_s((0L > ((safe_rshift_func_uint8_t_u_s((safe_rshift_func_uint32_t_u_s(((!l_38) > (0xCD538770CE404D46LL || g_5)), 9)), (((*l_45) |= (safe_add_func_uint64_t_u_u(((((((safe_add_func_uint32_t_u_u(((*l_43) |= 0xC411E69DL), g_5)) ^ l_11) >= g_5) || g_44) || 0xDA1E1CF2BBA2D3C5LL), g_5), 18446744073709551606UL))) > g_5))) & 4294967295UL)), g_5)) | g_5) >= 0xCFFAE3C77D98A9A2LL) | g_5), l_8)))) < g_5), g_5)))))), g_5, g_5), g_56)), l_38)) | l_38), 19));
        1:   49:    g_56 |= (*g_51);
        -:   50:  } else {
    #####:   51:    uint8_t l_100 = 0xD6L;
    #####:   52:    int16_t l_125 = 9L;
    #####:   53:    for (g_49 = 0; (g_49 < 41); ++g_49) {
    #####:   54:      int8_t *l_86 = (void *)0;
    #####:   55:      int8_t *l_87 = &g_88;
    #####:   56:      int32_t l_101 = 1L;
    #####:   57:      int32_t *l_103 = &g_56;
    #####:   58:      int32_t **l_102 = &l_103;
        -:   59:      int32_t ***l_122[2];
        -:   60:      int i;
    #####:   61:      for (i = 0; i < 2; i++)
    #####:   62:        l_122[i] = (void *)0;
    #####:   63:      if ((safe_lshift_func_uint32_t_u_s((((safe_sub_func_uint16_t_u_u((&g_46 == l_85), ((g_44, (((*l_87) = g_68) ^ (safe_sub_func_int8_t_s_s(((safe_div_func_uint16_t_u_u((0x79L && (((l_87 != (g_93 = g_93)) && ((safe_sub_func_uint16_t_u_u(((safe_rshift_func_uint32_t_u_u((((+0xB4L), ((*l_85) = (((l_100 < g_47[0]) != l_100) | 65535UL))) >= 0L), l_101)), l_101), 65531UL)) <= 0x98L)) > l_100)), 0x8E69L)) <= g_44), l_101)))) <= g_52))) || g_68) | g_44), 7))) {
    #####:   64:        if ((*g_51))
    #####:   65:          break;
        -:   66:      } else {
    #####:   67:        int32_t **l_104 = &l_103;
    #####:   68:        int32_t ***l_105 = &l_104;
    #####:   69:        int32_t **l_117 = (void *)0;
    #####:   70:        int32_t ***l_116 = &l_117;
    #####:   71:        int32_t ****l_115 = &l_116;
    #####:   72:        int32_t ****l_123 = &l_122[0];
    #####:   73:        uint8_t *l_124 = &l_100;
    #####:   74:        (*l_103) = ((((&g_46 == (void *)0), (l_102 = (void *)0)) == ((*l_105) = l_104)) >= (safe_mod_func_uint8_t_u_u((safe_add_func_int8_t_s_s((safe_mod_func_uint8_t_u_u(((*l_124) = (((l_112 == &g_94) == (((safe_mul_func_int8_t_s_s((*g_93), (((*l_115) = l_105) == ((*l_123) = (((((safe_rshift_func_int64_t_s_u(((((safe_div_func_int8_t_s_s((*g_93), g_49)), l_100) < (*g_93)) & g_71), 8)) <= g_5), (*l_103)) <= 2L), l_122[0]))))) | 4294967289UL) < (*l_103))) & (*l_103))), l_125)), (*g_93))), 1L)));
    #####:   75:        if ((****l_115))
    #####:   76:          break;
        -:   77:      }
        -:   78:    }
    #####:   79:    (*g_51) = (((((safe_add_func_int32_t_s_s(((l_24, (&g_51 == (void *)0)), ((((g_44 = (((void *)0 == l_128) ^ 0xF68EFB8CL)), &g_78) != ((*l_130), (**l_128))) >= (***l_128))), 0xA84C6C14L)) && 7L) >= l_100), (*g_51)) < g_49);
        -:   80:  }
        1:   81:  l_131--;
        1:   82:  return l_134;
        -:   83:}
        -:   84:
        1:   85:static uint32_t func_20(int64_t p_21, uint16_t p_22, int32_t p_23) {
        1:   86:  int8_t l_50 = 0xD4L;
        1:   87:  int32_t l_67 = (-9L);
        1:   88:  (*g_51) = (l_50 |= g_49);
       14:   89:  for (g_52 = (-7); (g_52 <= 5); g_52 = safe_add_func_uint64_t_u_u(g_52, 1)) {
       13:   90:    int64_t l_70 = 0xADDA102F310E27A8LL;
       13:   91:    int32_t *const l_75 = &g_56;
       39:   92:    for (p_23 = 0; (p_23 <= 1); p_23 += 1) {
       26:   93:      int32_t *l_55 = &g_56;
       26:   94:      int32_t *l_57 = &g_56;
       26:   95:      int32_t *l_58 = &g_56;
       26:   96:      int32_t *l_59 = &g_56;
       26:   97:      int32_t *l_60 = &g_56;
       26:   98:      int32_t l_61 = 0xCFE74D02L;
       26:   99:      int32_t *l_62 = &g_56;
       26:  100:      int32_t *l_63 = &g_56;
       26:  101:      int32_t *l_64 = &g_56;
       26:  102:      int32_t *l_65 = &g_56;
       26:  103:      int32_t *l_66[1][5] = {{&g_56, &g_56, &g_56, &g_56, &g_56}};
       26:  104:      int32_t **l_76 = &l_62;
        -:  105:      int i, j;
       26:  106:      ++g_72[0];
       26:  107:      (*l_76) = l_75;
        -:  108:    }
        -:  109:  }
        1:  110:  return g_5;
        -:  111:}
        -:  112:
        1:  113:int main(int argc, char *argv[]) {
        -:  114:  int i;
        1:  115:  int print_hash_value = 0;
       1*:  116:  if (argc == 2 && strcmp(argv[1], "1") == 0)
    #####:  117:    print_hash_value = 1;
        1:  118:  platform_main_begin();
        1:  119:  crc32_gentab();
        1:  120:  func_1();
        1:  121:  transparent_crc(g_4, "g_4", print_hash_value);
        1:  122:  transparent_crc(g_5, "g_5", print_hash_value);
        1:  123:  transparent_crc(g_44, "g_44", print_hash_value);
        1:  124:  transparent_crc(g_46, "g_46", print_hash_value);
        3:  125:  for (i = 0; i < 2; i++) {
        2:  126:    transparent_crc(g_47[i], "g_47[i]", print_hash_value);
        2:  127:    if (print_hash_value)
    #####:  128:      printf("index = [%d]\n", i);
        -:  129:  }
        1:  130:  transparent_crc(g_49, "g_49", print_hash_value);
        1:  131:  transparent_crc(g_52, "g_52", print_hash_value);
        1:  132:  transparent_crc(g_56, "g_56", print_hash_value);
        1:  133:  transparent_crc(g_68, "g_68", print_hash_value);
        1:  134:  transparent_crc(g_69, "g_69", print_hash_value);
        1:  135:  transparent_crc(g_71, "g_71", print_hash_value);
        4:  136:  for (i = 0; i < 3; i++) {
        3:  137:    transparent_crc(g_72[i], "g_72[i]", print_hash_value);
        3:  138:    if (print_hash_value)
    #####:  139:      printf("index = [%d]\n", i);
        -:  140:  }
        1:  141:  transparent_crc(g_78, "g_78", print_hash_value);
        1:  142:  transparent_crc(g_88, "g_88", print_hash_value);
        1:  143:  transparent_crc(g_94, "g_94", print_hash_value);
        1:  144:  platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
        1:  145:  return 0;
        -:  146:}
