        -:    0:Source:641.c
        -:    0:Graph:641.gcno
        -:    0:Data:641.gcda
        -:    0:Runs:1
        -:    1:// Options:   --concise --max-struct-fields 5 --max-funcs 2 --max-array-len-per-dim 5 --max-block-depth 3 --max-block-size 2
        -:    2:#include "csmith.h"
        -:    3:
        -:    4:static long __undefined;
        -:    5:
        -:    6:static uint32_t g_9 = 0xE86F8C7BL;
        -:    7:static int32_t g_13 = (-1L);
        -:    8:static int64_t g_24 = 5L;
        -:    9:static int32_t g_26 = 0x47D17017L;
        -:   10:static const int32_t g_29 = (-1L);
        -:   11:static const int32_t *g_31 = &g_29;
        -:   12:static const int32_t **volatile g_30 = &g_31;
        -:   13:static uint16_t g_45 = 0x21E5L;
        -:   14:static int16_t g_47 = 0xF5B0L;
        -:   15:static uint32_t g_50 = 0x20B2DE47L;
        -:   16:static uint32_t g_65 = 3UL;
        -:   17:static int16_t g_76 = 0x09D7L;
        -:   18:static volatile uint8_t g_77[2] = {8UL, 8UL};
        -:   19:
        -:   20:static int32_t func_1(void);
        -:   21:static int32_t *func_2(uint16_t p_3);
        -:   22:
        1:   23:static int32_t func_1(void) {
        1:   24:  int8_t l_4 = (-1L);
        1:   25:  const int32_t *l_28 = &g_29;
        1:   26:  const int32_t **l_27 = &l_28;
        1:   27:  int32_t *const l_43 = &g_13;
        1:   28:  uint16_t *l_44 = &g_45;
        1:   29:  int16_t *l_46 = &g_47;
        1:   30:  int64_t *l_48 = &g_24;
        -:   31:  int8_t *l_49[3];
        -:   32:  int i;
        4:   33:  for (i = 0; i < 3; i++)
        3:   34:    l_49[i] = &l_4;
        1:   35:  (*g_30) = ((*l_27) = func_2(l_4));
       1*:   36:  if (((g_50 ^= (safe_mod_func_int64_t_s_s(((*l_48) &= (safe_add_func_uint8_t_u_u(((&l_28 == &g_31), (((*l_46) = (safe_add_func_int64_t_s_s((safe_lshift_func_int16_t_s_u((((**l_27) >= (~(safe_add_func_uint32_t_u_u(((*l_28) < 0xCF9E8BFAL), (((*l_44) |= (l_43 != (*l_27))) >= ((void *)0 != &g_31)))))) && (**l_27)), (**l_27))), (*l_28)))), (**l_27))), (*l_43)))), g_13))) > 0x3CL)) {
        1:   37:    const int32_t **l_53 = (void *)0;
        1:   38:    const int32_t ***l_54 = &l_53;
        1:   39:    uint16_t *l_61 = (void *)0;
        1:   40:    int32_t ***l_62 = (void *)0;
        1:   41:    int32_t ****l_63 = (void *)0;
        1:   42:    int32_t ****l_64 = &l_62;
        1:   43:    uint32_t l_69 = 0x66802143L;
        1:   44:    uint64_t l_72 = 0xB7192EEDB0E1D9D3LL;
       1*:   45:    (*l_43) = (((safe_add_func_int32_t_s_s(4L, (((*l_54) = l_53) == (void *)0))) && (safe_add_func_uint16_t_u_u(((g_65 = (safe_sub_func_int64_t_s_s(((18446744073709551609UL ^ (safe_add_func_int32_t_s_s((l_61 != (g_45, &g_45)), (((((*l_64) = l_62) != (void *)0) && (*l_43)) ^ 6L)))) < g_29), g_45))), g_47), 0xBF33L))) != g_47);
       35:   46:    for (l_4 = 28; (l_4 > (-6)); --l_4) {
       34:   47:      uint32_t l_68 = 1UL;
       34:   48:      l_69 = ((*l_43) = (g_26 |= l_68));
      136:   49:      for (g_45 = 0; (g_45 <= 2); g_45 += 1) {
      102:   50:        const int32_t l_71 = 0xEDC67586L;
        -:   51:        int i;
      102:   52:        (*l_43) ^= (safe_unary_minus_func_int8_t_s(l_71));
      102:   53:        if (l_72)
      102:   54:          continue;
        -:   55:      }
        -:   56:    }
        -:   57:  } else {
    #####:   58:    int32_t *l_73 = &g_13;
    #####:   59:    int32_t *l_74 = &g_13;
    #####:   60:    int32_t *l_75[5][3] = {{&g_26, &g_26, &g_26}, {&g_13, &g_13, &g_13}, {&g_26, &g_26, &g_26}, {&g_13, &g_13, &g_13}, {&g_26, &g_26, &g_26}};
        -:   61:    int i, j;
    #####:   62:    --g_77[0];
        -:   63:  }
        1:   64:  return (*l_43);
        -:   65:}
        -:   66:
        1:   67:static int32_t *func_2(uint16_t p_3) {
        1:   68:  int32_t *l_12 = &g_13;
        1:   69:  int32_t *l_25 = &g_26;
       1*:   70:  (*l_25) ^= (safe_lshift_func_int64_t_s_u(((((safe_div_func_int32_t_s_s(((((g_9 < (safe_add_func_int64_t_s_s(((g_9 | (((l_12 == (void *)0) ^ (0x2858L && (safe_lshift_func_int64_t_s_s((0x008B15E314A5EA96LL & (p_3 & 0x4309L)), 36)))) <= (g_24 = (safe_rshift_func_uint16_t_u_u(((safe_mod_func_int32_t_s_s((safe_lshift_func_int64_t_s_u((safe_mod_func_uint32_t_u_u((*l_12), 4294967289UL)), 0)), (*l_12))), (*l_12)), 4))))) && (*l_12)), (*l_12)))) == p_3), p_3), p_3), p_3)) == 0x2E11914CC5C6A3F1LL) || 0x95L) <= 0x712C51978E60D743LL), g_9));
        1:   71:  (*l_12) = 8L;
        1:   72:  return &g_13;
        -:   73:}
        -:   74:
        1:   75:int main(int argc, char *argv[]) {
        -:   76:  int i;
        1:   77:  int print_hash_value = 0;
       1*:   78:  if (argc == 2 && strcmp(argv[1], "1") == 0)
    #####:   79:    print_hash_value = 1;
        1:   80:  platform_main_begin();
        1:   81:  crc32_gentab();
        1:   82:  func_1();
        1:   83:  transparent_crc(g_9, "g_9", print_hash_value);
        1:   84:  transparent_crc(g_13, "g_13", print_hash_value);
        1:   85:  transparent_crc(g_24, "g_24", print_hash_value);
        1:   86:  transparent_crc(g_26, "g_26", print_hash_value);
        1:   87:  transparent_crc(g_29, "g_29", print_hash_value);
        1:   88:  transparent_crc(g_45, "g_45", print_hash_value);
        1:   89:  transparent_crc(g_47, "g_47", print_hash_value);
        1:   90:  transparent_crc(g_50, "g_50", print_hash_value);
        1:   91:  transparent_crc(g_65, "g_65", print_hash_value);
        1:   92:  transparent_crc(g_76, "g_76", print_hash_value);
        3:   93:  for (i = 0; i < 2; i++) {
        2:   94:    transparent_crc(g_77[i], "g_77[i]", print_hash_value);
        2:   95:    if (print_hash_value)
    #####:   96:      printf("index = [%d]\n", i);
        -:   97:  }
        1:   98:  platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
        1:   99:  return 0;
        -:  100:}
