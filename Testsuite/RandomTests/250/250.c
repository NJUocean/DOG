// Options:   --concise --max-struct-fields 5 --max-funcs 2 --max-array-len-per-dim 5 --max-block-depth 3 --max-block-size 2
#include "csmith.h"

static long __undefined;

#pragma pack(push)
#pragma pack(1)
struct S0 {
  const volatile signed f0 : 5;
  signed f1 : 6;
  signed f2 : 16;
};
#pragma pack(pop)

static int32_t g_4 = 0L;
static int32_t *volatile g_3 = &g_4;
static volatile struct S0 g_24 = {-2, -6, -151};
static int8_t g_31 = 0x5EL;
static int32_t g_32 = (-8L);
static int32_t *g_33 = &g_4;
static volatile int32_t g_48[4][3][3] = {{{6L, 3L, 6L}, {(-1L), 1L, 0x830386B9L}, {6L, 0xCC8E11F3L, 1L}}, {{(-1L), 5L, (-1L)}, {6L, (-1L), 0xAF6DDF93L}, {(-1L), (-1L), 1L}}, {{6L, 3L, 6L}, {(-1L), 1L, 0x830386B9L}, {6L, 0xCC8E11F3L, 1L}}, {{(-1L), 5L, (-1L)}, {6L, (-1L), 0xAF6DDF93L}, {(-1L), (-1L), 1L}}};
static volatile int32_t *g_47[2][4] = {{&g_48[2][1][2], &g_48[2][1][2], &g_48[2][1][2], &g_48[2][1][2]}, {&g_48[2][1][2], &g_48[2][1][2], &g_48[2][1][2], &g_48[2][1][2]}};
static volatile int32_t *volatile *g_46 = &g_47[0][2];
static volatile int32_t *volatile *volatile *g_45 = &g_46;
static volatile struct S0 *g_51[2][5][3] = {{{&g_24, &g_24, &g_24}, {(void *)0, (void *)0, &g_24}, {&g_24, &g_24, &g_24}, {(void *)0, (void *)0, &g_24}, {&g_24, &g_24, &g_24}}, {{(void *)0, (void *)0, &g_24}, {&g_24, &g_24, &g_24}, {(void *)0, (void *)0, &g_24}, {&g_24, &g_24, &g_24}, {(void *)0, (void *)0, &g_24}}};
static volatile struct S0 **volatile g_50 = &g_51[0][4][2];
static uint32_t g_64 = 0x4B24D3E4L;
static struct S0 *g_77 = (void *)0;
static struct S0 **g_76 = &g_77;
static struct S0 **g_79 = (void *)0;
static int8_t g_83 = (-6L);
static struct S0 g_84 = {-3, 5, 84};
static volatile struct S0 g_85 = {-4, 6, -73};
static const volatile struct S0 g_88[5][3] = {{{2, 2, -234}, {1, 2, 118}, {-0, 6, 225}}, {{1, 2, 118}, {2, 2, -234}, {2, 2, -234}}, {{-0, 6, 225}, {2, 2, -234}, {-4, -4, -143}}, {{-1, 0, 72}, {1, 2, 118}, {1, -0, 54}}, {{-0, 6, 225}, {-0, 6, 225}, {1, -0, 54}}};
static uint64_t g_90 = 18446744073709551614UL;
static int64_t g_92 = 0L;

static uint32_t func_1(void);
static uint32_t func_14(int32_t **p_15, int32_t *p_16, int32_t p_17);

static uint32_t func_1(void) {
  int8_t l_2 = 0x8DL;
  int32_t *volatile *l_5 = &g_3;
  int32_t *l_19 = &g_4;
  int32_t **l_18 = &l_19;
  int32_t **l_23 = (void *)0;
  int32_t ***l_22 = &l_23;
  struct S0 **l_87 = &g_77;
  (*l_5) = (l_2, g_3);
  if (((**l_5) = (0x05L > ((g_33 = ((g_32 = (safe_sub_func_int8_t_s_s((safe_div_func_uint16_t_u_u((safe_mul_func_uint8_t_u_u((safe_mul_func_uint32_t_u_u((func_14(l_18, (*l_18), ((**l_18), (safe_mul_func_uint16_t_u_u((((*l_22) = &l_19) == &g_3), ((g_24, ((safe_lshift_func_int32_t_s_s(((**l_18) || (safe_add_func_uint16_t_u_u((safe_mul_func_int32_t_s_s(((void *)0 == &g_4), g_31)), g_24.f2))), g_31)), 0xB26C4F32B7B88CDFLL)), g_24.f2))))) | 0x35A12A2EL), 0x291920B2L)), g_31)), 0xD8C6L)), g_31))), &g_4)) == (void *)0)))) {
    uint32_t l_40 = 5UL;
    int64_t l_43 = 0xBBB531EAA473ECFBLL;
    const uint32_t l_44 = 1UL;
    if (((safe_rshift_func_uint32_t_u_u(((g_32 ^ (**l_23)), (((*l_19) |= (-1L)) ^ ((((g_31 | (((((*l_23) == (void *)0) == (+((+l_40) == (safe_add_func_uint8_t_u_u(((g_32 ^ g_24.f1) || l_43), g_31))))) | g_32) || g_24.f2)) == l_44) > l_44) != l_40))), g_31)) && g_24.f0)) {
      int8_t l_49 = 0x30L;
      l_49 &= (g_45 != (void *)0);
    } else {
      (*g_50) = &g_24;
      return l_43;
    }
    for (g_32 = 1; (g_32 >= 0); g_32 -= 1) {
      int32_t l_67 = (-10L);
      struct S0 **l_78 = &g_77;
      int16_t *l_80 = (void *)0;
      int32_t l_81 = 0x51C8BDC6L;
      int8_t *l_82 = &g_31;
      (*g_46) = (**g_45);
    }
  } else {
    uint8_t l_86 = 0x0BL;
    uint64_t *l_89 = &g_90;
    int64_t *l_91 = &g_92;
    int32_t l_93 = (-5L);
    if ((((l_93 &= ((g_85, (0xFCFBL || l_86)), ((*l_91) = (4294967292UL ^ ((0L != ((*l_89) = (l_87 == (((g_83 ^ ((((65535UL & l_86) < 18446744073709551609UL), 0x494CAA1CL) && (**l_5))), g_88[1][1]), l_87)))) & 0xCB25977850406789LL))))) && g_24.f2) & g_83)) {
      return g_88[1][1].f1;
    } else {
      for (l_93 = 0; (l_93 <= 2); l_93 += 1) {
        uint32_t l_94 = 0x570BAEA4L;
        if (l_94)
          break;
      }
    }
  }
  return (**l_5);
}

static uint32_t func_14(int32_t **p_15, int32_t *p_16, int32_t p_17) { return p_17; }

int main(int argc, char *argv[]) {
  int i, j, k;
  int print_hash_value = 0;
  if (argc == 2 && strcmp(argv[1], "1") == 0)
    print_hash_value = 1;
  platform_main_begin();
  crc32_gentab();
  func_1();
  transparent_crc(g_4, "g_4", print_hash_value);
  transparent_crc(g_24.f0, "g_24.f0", print_hash_value);
  transparent_crc(g_24.f1, "g_24.f1", print_hash_value);
  transparent_crc(g_24.f2, "g_24.f2", print_hash_value);
  transparent_crc(g_31, "g_31", print_hash_value);
  transparent_crc(g_32, "g_32", print_hash_value);
  for (i = 0; i < 4; i++) {
    for (j = 0; j < 3; j++) {
      for (k = 0; k < 3; k++) {
        transparent_crc(g_48[i][j][k], "g_48[i][j][k]", print_hash_value);
        if (print_hash_value)
          printf("index = [%d][%d][%d]\n", i, j, k);
      }
    }
  }
  transparent_crc(g_64, "g_64", print_hash_value);
  transparent_crc(g_83, "g_83", print_hash_value);
  transparent_crc(g_84.f0, "g_84.f0", print_hash_value);
  transparent_crc(g_84.f1, "g_84.f1", print_hash_value);
  transparent_crc(g_84.f2, "g_84.f2", print_hash_value);
  transparent_crc(g_85.f0, "g_85.f0", print_hash_value);
  transparent_crc(g_85.f1, "g_85.f1", print_hash_value);
  transparent_crc(g_85.f2, "g_85.f2", print_hash_value);
  for (i = 0; i < 5; i++) {
    for (j = 0; j < 3; j++) {
      transparent_crc(g_88[i][j].f0, "g_88[i][j].f0", print_hash_value);
      transparent_crc(g_88[i][j].f1, "g_88[i][j].f1", print_hash_value);
      transparent_crc(g_88[i][j].f2, "g_88[i][j].f2", print_hash_value);
      if (print_hash_value)
        printf("index = [%d][%d]\n", i, j);
    }
  }
  transparent_crc(g_90, "g_90", print_hash_value);
  transparent_crc(g_92, "g_92", print_hash_value);
  platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
  return 0;
}
