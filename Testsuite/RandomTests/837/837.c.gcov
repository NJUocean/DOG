        -:    0:Source:837.c
        -:    0:Graph:837.gcno
        -:    0:Data:837.gcda
        -:    0:Runs:1
        -:    1:// Options:   --concise --max-struct-fields 5 --max-funcs 2 --max-array-len-per-dim 5 --max-block-depth 3 --max-block-size 2
        -:    2:#include "csmith.h"
        -:    3:
        -:    4:static long __undefined;
        -:    5:
        -:    6:struct S0 {
        -:    7:  volatile signed f0 : 15;
        -:    8:  const volatile signed f1 : 8;
        -:    9:  signed f2 : 10;
        -:   10:};
        -:   11:
        -:   12:union U1 {
        -:   13:  uint16_t f0;
        -:   14:};
        -:   15:
        -:   16:static uint32_t g_16 = 1UL;
        -:   17:static uint8_t g_19 = 0xEAL;
        -:   18:static int16_t g_54 = 0x674EL;
        -:   19:static struct S0 g_56 = {130, -3, -11};
        -:   20:static uint32_t g_63[1] = {0x9E5FAF1BL};
        -:   21:static uint64_t g_85 = 18446744073709551615UL;
        -:   22:static uint16_t g_91[2] = {1UL, 1UL};
        -:   23:static uint64_t g_96[1] = {0x49F9AD4046E41CA9LL};
        -:   24:static uint64_t *g_95[3][5] = {{&g_96[0], &g_96[0], &g_96[0], (void *)0, &g_96[0]}, {&g_96[0], &g_96[0], &g_96[0], (void *)0, &g_96[0]}, {&g_96[0], &g_96[0], &g_96[0], &g_96[0], &g_96[0]}};
        -:   25:static volatile int16_t *const volatile g_104 = (void *)0;
        -:   26:static int16_t g_106 = 0x28F0L;
        -:   27:static uint32_t g_108 = 7UL;
        -:   28:static volatile uint32_t g_109[2][1][4] = {{{0xC39CF3F9L, 0xC39CF3F9L, 0xC39CF3F9L, 0xC39CF3F9L}}, {{0xC39CF3F9L, 0xC39CF3F9L, 0xC39CF3F9L, 0xC39CF3F9L}}};
        -:   29:static uint8_t *g_118 = &g_19;
        -:   30:static struct S0 g_121 = {-147, -2, -26};
        -:   31:static const uint32_t g_126 = 5UL;
        -:   32:static int32_t g_141 = (-10L);
        -:   33:static int32_t *volatile g_140 = &g_141;
        -:   34:static int8_t g_170 = 0L;
        -:   35:static int64_t g_173 = 1L;
        -:   36:
        -:   37:static uint32_t func_1(void);
        -:   38:static uint16_t func_10(int16_t p_11, int16_t p_12, const int64_t p_13, int32_t p_14);
        -:   39:
        1:   40:static uint32_t func_1(void) {
        1:   41:  int64_t l_4 = 0xFB770A77C8748AFALL;
        1:   42:  uint32_t *l_15 = &g_16;
        1:   43:  uint32_t **l_17 = &l_15;
        1:   44:  uint8_t *l_18 = &g_19;
        -:   45:  const uint32_t l_20[4] = {0x462CCD20L, 0x462CCD20L, 0x462CCD20L, 0x462CCD20L};
        1:   46:  int32_t l_180 = 0xA45CE9BAL;
        -:   47:  int i;
        1:   48:  l_180 ^= (safe_add_func_uint8_t_u_u((0UL ^ l_4), (safe_lshift_func_int16_t_s_u((safe_add_func_uint8_t_u_u(0xA8L, ((~func_10(l_4, ((5L & 0x19L) || ((((*l_15) = 8UL), (((*l_18) = (l_4 <= (((((*l_17) = l_15) == &g_16) >= g_16) == 1L))) & (-10L))) >= l_4)), l_20[1], l_4)) > 0L))), g_126))));
        1:   49:  return g_19;
        -:   50:}
        -:   51:
        1:   52:static uint16_t func_10(int16_t p_11, int16_t p_12, const int64_t p_13, int32_t p_14) {
        1:   53:  const union U1 l_23 = {0x5C6AL};
        1:   54:  uint32_t **l_24 = (void *)0;
        1:   55:  uint32_t *l_26 = &g_16;
        1:   56:  uint32_t **l_25 = &l_26;
        1:   57:  int32_t l_44 = 0xC0CE695EL;
        -:   58:  int32_t l_70[1][3][3];
        1:   59:  uint64_t *l_97 = (void *)0;
        1:   60:  uint8_t *l_116 = (void *)0;
        1:   61:  uint8_t **l_150 = (void *)0;
        -:   62:  int i, j, k;
        2:   63:  for (i = 0; i < 1; i++) {
        4:   64:    for (j = 0; j < 3; j++) {
       12:   65:      for (k = 0; k < 3; k++)
        9:   66:        l_70[i][j][k] = 0x6B0C4F58L;
        -:   67:    }
        -:   68:  }
       1*:   69:  if ((safe_add_func_int64_t_s_s(((l_23, (((*l_25) = &g_16) != &g_16)), (safe_rshift_func_int16_t_s_s(p_14, ((3UL >= 0x68FAL) ^ (safe_add_func_int16_t_s_s((p_12 != (~p_11)), (((l_44 &= (safe_sub_func_int8_t_s_s((safe_lshift_func_int32_t_s_u((safe_mul_func_int32_t_s_s(((safe_add_func_uint16_t_u_u((safe_mul_func_int8_t_s_s((safe_sub_func_uint16_t_u_u(g_19, l_23.f0)), p_11)), 0x2406L)) >= 0x1289ED5B6062CF9ELL), l_23.f0)), l_23.f0)), g_16))) <= 4294967288UL) ^ 0x036FFE617092FF82LL))))))), l_23.f0))) {
        1:   70:  lbl_179:
        1:   71:    if (p_12) {
        -:   72:      int32_t l_45[2];
        1:   73:      int32_t *l_48 = &l_44;
        -:   74:      int i;
        3:   75:      for (i = 0; i < 2; i++)
        2:   76:        l_45[i] = (-1L);
        3:   77:      for (g_19 = 0; g_19 < 2; g_19 += 1) {
        2:   78:        l_45[g_19] = 0x615A0349L;
        -:   79:      }
        5:   80:      for (g_16 = (-20); (g_16 != 12); g_16 = safe_add_func_int32_t_s_s(g_16, 8)) {
        4:   81:        l_48 = &p_14;
        -:   82:      }
        -:   83:    } else {
    #####:   84:      return l_44;
        -:   85:    }
        -:   86:  } else {
    #####:   87:    int16_t *l_53 = &g_54;
    #####:   88:    int32_t l_55 = 7L;
    #####:   89:    uint32_t **l_64 = (void *)0;
    #####:   90:    int32_t l_71[4] = {0xFF731867L, 0xFF731867L, 0xFF731867L, 0xFF731867L};
    #####:   91:    uint8_t l_73 = 0xF2L;
    #####:   92:    uint8_t **l_117[3][2][3] = {{{&l_116, &l_116, &l_116}, {&l_116, &l_116, (void *)0}}, {{&l_116, &l_116, &l_116}, {&l_116, &l_116, &l_116}}, {{&l_116, &l_116, &l_116}, {(void *)0, &l_116, &l_116}}};
    #####:   93:    const uint32_t *l_125 = &g_126;
    #####:   94:    const uint32_t **l_124 = &l_125;
    #####:   95:    int32_t *l_127 = &l_44;
    #####:   96:    union U1 l_138 = {0x3F61L};
        -:   97:    int i, j, k;
    #####:   98:    if ((safe_div_func_uint32_t_u_u(((((safe_div_func_uint16_t_u_u(p_14, ((*l_53) = p_13))) | g_16) & (l_55 ^ (((((g_56, g_19) | ((((!((safe_div_func_uint64_t_u_u(((g_63[0] &= (p_12 || (safe_mul_func_uint64_t_u_u(g_56.f2, ((+p_11) || g_16))))) && p_12), l_55)) >= p_12)) || 0x9388B32AL) > g_19), 0x464EB7F0L)) & p_12), &l_26) == l_64))) == 0x96AAE11E54637542LL), p_12))) {
    #####:   99:    lbl_128:
    #####:  100:      for (l_55 = 0; (l_55 > (-18)); --l_55) {
    #####:  101:        uint32_t ***l_68 = &l_25;
    #####:  102:        uint32_t ****l_67 = &l_68;
    #####:  103:        (*l_67) = &l_64;
        -:  104:      }
        -:  105:    } else {
    #####:  106:      int32_t *l_69[3][5] = {{(void *)0, (void *)0, (void *)0, (void *)0, (void *)0}, {&l_55, &l_55, &l_44, &l_55, &l_55}, {(void *)0, (void *)0, (void *)0, (void *)0, (void *)0}};
    #####:  107:      int64_t l_72[2][4][4] = {{{0xC2AD413ED7628F8CLL, (-6L), 0x2EB2EFFCBC420B16LL, 0xC8B7CF170C459F77LL}, {0x2EB2EFFCBC420B16LL, 0xC8B7CF170C459F77LL, 0x79F159E9DC621C65LL, 0x2EB2EFFCBC420B16LL}, {0L, 0xC8B7CF170C459F77LL, 0L, 0xC8B7CF170C459F77LL}, {0xC8B7CF170C459F77LL, (-6L), (-1L), 0xAC4CB544DDB7621CLL}}, {{4L, 0L, 0x79F159E9DC621C65LL, (-1L)}, {0xC2AD413ED7628F8CLL, 0L, (-1L), 0xC8B7CF170C459F77LL}, {0xC2AD413ED7628F8CLL, 0x79F159E9DC621C65LL, 0x79F159E9DC621C65LL, 0xC2AD413ED7628F8CLL}, {4L, 0xC8B7CF170C459F77LL, (-1L), 0x79F159E9DC621C65LL}}};
    #####:  108:      int8_t l_107 = 0x2DL;
        -:  109:      int i, j, k;
    #####:  110:      --l_73;
    #####:  111:      for (p_12 = 17; (p_12 > (-7)); p_12 = safe_sub_func_uint32_t_u_u(p_12, 1)) {
    #####:  112:        uint64_t *l_83 = (void *)0;
    #####:  113:        uint64_t *l_84 = &g_85;
    #####:  114:        uint16_t *l_90 = &g_91[0];
    #####:  115:        uint64_t **l_98 = &l_83;
    #####:  116:        int64_t *l_99 = &l_72[1][0][0];
    #####:  117:        int16_t *l_105 = &g_106;
    #####:  118:        g_108 ^= (safe_sub_func_int8_t_s_s(((((((safe_unary_minus_func_int16_t_s(((*l_53) &= (safe_mul_func_uint64_t_u_u(((*l_84)--), (safe_add_func_int32_t_s_s((((--(*l_90)) ^ g_16) & 0x06F5C0CD63D7C5F0LL), l_70[0][2][1]))))))) > ((((safe_unary_minus_func_uint32_t_u(p_12)), g_95[0][2]) != ((*l_98) = l_97)) || ((*l_105) = (((*l_99) ^= 0xCDF6E60FB7EBE1D7LL) <= (((safe_add_func_int8_t_s_s(((safe_mul_func_int64_t_s_s(((g_104 == &p_12) != p_13), p_11)) | 6UL), g_56.f2)), 0x37D68548L) & 1L))))) != p_14) == l_107) & g_63[0]) == p_14), 3L));
    #####:  119:        ++g_109[0][0][3];
        -:  120:      }
        -:  121:    }
    #####:  122:    if ((safe_mod_func_int64_t_s_s((safe_mod_func_int64_t_s_s(((4294967295UL && ((g_118 = l_116) != (void *)0)) >= (safe_lshift_func_int8_t_s_s(l_73, 0))), (g_121, l_55))), (((safe_rshift_func_int64_t_s_s((((((((*l_127) = (((*l_124) = (void *)0) != ((1L >= 9L), &g_16))) & p_11) >= p_13) == 0x7CABL) >= 0UL) > l_70[0][0][2]), 51)), 0x0C07D60D117829FCLL), p_13)))) {
    #####:  123:      int32_t l_130 = 1L;
    #####:  124:      uint64_t *const *l_142 = (void *)0;
    #####:  125:      int32_t l_175 = 0x402EAC0BL;
    #####:  126:      if (g_19)
    #####:  127:        goto lbl_128;
    #####:  128:      if ((0xBCL && ((~l_130) > (safe_sub_func_uint8_t_u_u(1UL, p_12))))) {
        -:  129:        uint8_t *l_135[1];
    #####:  130:        int32_t l_139 = 0x55411A66L;
    #####:  131:        uint64_t *const **l_143 = &l_142;
        -:  132:        int i;
    #####:  133:        for (i = 0; i < 1; i++)
    #####:  134:          l_135[i] = &l_73;
    #####:  135:        (*g_140) = (safe_mod_func_uint16_t_u_u(((((0x1AL ^ (l_135[0] == (void *)0)) ^ ((l_44 = (safe_sub_func_int16_t_s_s((p_12, l_130), ((l_138, g_95[2][1]) != (void *)0)))) && l_139)), 0x71L) | p_12), g_121.f0));
    #####:  136:        (*l_127) = (((*l_143) = l_142) != (l_70[0][0][0], &g_95[0][2]));
        -:  137:      } else {
    #####:  138:        int8_t *l_169 = &g_170;
    #####:  139:        int32_t l_171 = 9L;
    #####:  140:        int64_t *l_172 = &g_173;
    #####:  141:        uint16_t *l_174[3][2] = {{&g_91[0], &g_91[0]}, {&g_91[0], &g_91[0]}, {&g_91[0], &g_91[0]}};
    #####:  142:        uint64_t *l_176 = (void *)0;
    #####:  143:        uint64_t *l_177 = &g_85;
        -:  144:        int i, j;
    #####:  145:        (*l_127) = (((*l_177) = (safe_lshift_func_uint16_t_u_s((safe_mod_func_uint8_t_u_u((&g_54 == l_53), (safe_mul_func_int16_t_s_s((l_150 == (void *)0), ((l_130 = (((safe_lshift_func_int8_t_s_u((safe_lshift_func_int64_t_s_s((safe_lshift_func_int32_t_s_s((0xE84E38CD69FAF8F7LL || ((((*l_172) ^= (((safe_add_func_int16_t_s_s((safe_lshift_func_uint64_t_u_u(p_14, (1UL && ((safe_add_func_uint32_t_u_u(((safe_mod_func_int8_t_s_s((((safe_div_func_int8_t_s_s(((*l_169) = (p_13 > (safe_div_func_int16_t_s_s(l_130, 65533UL)))), p_11)) > p_13) > p_12), l_171)) | (-1L)), 0x29A07FE9L)) != 0xAC6FL)))), p_14)), l_97) != &g_96[0])) >= p_14) ^ 0x1645DA593D3CFB5FLL)), l_23.f0)), 5)), g_19)) & g_91[0]) > (*l_127))) <= l_175))))), p_12))), (*g_140));
        -:  146:      }
        -:  147:    } else {
    #####:  148:      int32_t **l_178 = &l_127;
    #####:  149:      (*l_178) = &p_14;
    #####:  150:      if (l_73)
    #####:  151:        goto lbl_179;
        -:  152:    }
        -:  153:  }
        1:  154:  return p_14;
        -:  155:}
        -:  156:
        1:  157:int main(int argc, char *argv[]) {
        -:  158:  int i, j, k;
        1:  159:  int print_hash_value = 0;
       1*:  160:  if (argc == 2 && strcmp(argv[1], "1") == 0)
    #####:  161:    print_hash_value = 1;
        1:  162:  platform_main_begin();
        1:  163:  crc32_gentab();
        1:  164:  func_1();
        1:  165:  transparent_crc(g_16, "g_16", print_hash_value);
        1:  166:  transparent_crc(g_19, "g_19", print_hash_value);
        1:  167:  transparent_crc(g_54, "g_54", print_hash_value);
        1:  168:  transparent_crc(g_56.f0, "g_56.f0", print_hash_value);
        1:  169:  transparent_crc(g_56.f1, "g_56.f1", print_hash_value);
        1:  170:  transparent_crc(g_56.f2, "g_56.f2", print_hash_value);
        2:  171:  for (i = 0; i < 1; i++) {
        1:  172:    transparent_crc(g_63[i], "g_63[i]", print_hash_value);
        1:  173:    if (print_hash_value)
    #####:  174:      printf("index = [%d]\n", i);
        -:  175:  }
        1:  176:  transparent_crc(g_85, "g_85", print_hash_value);
        3:  177:  for (i = 0; i < 2; i++) {
        2:  178:    transparent_crc(g_91[i], "g_91[i]", print_hash_value);
        2:  179:    if (print_hash_value)
    #####:  180:      printf("index = [%d]\n", i);
        -:  181:  }
        2:  182:  for (i = 0; i < 1; i++) {
        1:  183:    transparent_crc(g_96[i], "g_96[i]", print_hash_value);
        1:  184:    if (print_hash_value)
    #####:  185:      printf("index = [%d]\n", i);
        -:  186:  }
        1:  187:  transparent_crc(g_106, "g_106", print_hash_value);
        1:  188:  transparent_crc(g_108, "g_108", print_hash_value);
        3:  189:  for (i = 0; i < 2; i++) {
        4:  190:    for (j = 0; j < 1; j++) {
       10:  191:      for (k = 0; k < 4; k++) {
        8:  192:        transparent_crc(g_109[i][j][k], "g_109[i][j][k]", print_hash_value);
        8:  193:        if (print_hash_value)
    #####:  194:          printf("index = [%d][%d][%d]\n", i, j, k);
        -:  195:      }
        -:  196:    }
        -:  197:  }
        1:  198:  transparent_crc(g_121.f0, "g_121.f0", print_hash_value);
        1:  199:  transparent_crc(g_121.f1, "g_121.f1", print_hash_value);
        1:  200:  transparent_crc(g_121.f2, "g_121.f2", print_hash_value);
        1:  201:  transparent_crc(g_126, "g_126", print_hash_value);
        1:  202:  transparent_crc(g_141, "g_141", print_hash_value);
        1:  203:  transparent_crc(g_170, "g_170", print_hash_value);
        1:  204:  transparent_crc(g_173, "g_173", print_hash_value);
        1:  205:  platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
        1:  206:  return 0;
        -:  207:}
