        -:    0:Source:76.c
        -:    0:Graph:76.gcno
        -:    0:Data:76.gcda
        -:    0:Runs:1
        -:    1:// Options:   --concise --max-struct-fields 5 --max-funcs 2 --max-array-len-per-dim 5 --max-block-depth 3 --max-block-size 2
        -:    2:#include "csmith.h"
        -:    3:
        -:    4:static long __undefined;
        -:    5:
        -:    6:#pragma pack(push)
        -:    7:#pragma pack(1)
        -:    8:struct S0 {
        -:    9:  volatile signed f0 : 22;
        -:   10:};
        -:   11:#pragma pack(pop)
        -:   12:
        -:   13:#pragma pack(push)
        -:   14:#pragma pack(1)
        -:   15:struct S1 {
        -:   16:  signed f0 : 11;
        -:   17:  unsigned f1 : 1;
        -:   18:  const unsigned f2 : 2;
        -:   19:  const signed f3 : 6;
        -:   20:  volatile signed f4 : 15;
        -:   21:};
        -:   22:#pragma pack(pop)
        -:   23:
        -:   24:struct S2 {
        -:   25:  int32_t f0;
        -:   26:  const volatile int32_t f1;
        -:   27:};
        -:   28:
        -:   29:static int8_t g_9 = 0xC5L;
        -:   30:static uint64_t g_13 = 0xF29ACD409884CB8FLL;
        -:   31:static uint32_t g_18 = 0x8C84B7B8L;
        -:   32:static uint32_t g_20 = 1UL;
        -:   33:static uint16_t g_22 = 0x4353L;
        -:   34:static int16_t g_23 = 0x221EL;
        -:   35:static const volatile struct S1 g_34 = {-42, 0, 0, 1, 163};
        -:   36:static uint8_t g_41 = 9UL;
        -:   37:static struct S0 g_49 = {-712};
        -:   38:static volatile struct S2 g_58 = {-1L, 0xC16B31B7L};
        -:   39:static int32_t g_63 = (-1L);
        -:   40:static uint8_t *g_81 = (void *)0;
        -:   41:static int32_t *g_91 = &g_63;
        -:   42:static int32_t **volatile g_90[1][5] = {{&g_91, &g_91, &g_91, &g_91, &g_91}};
        -:   43:static uint32_t g_102[5] = {4294967295UL, 4294967295UL, 4294967295UL, 4294967295UL, 4294967295UL};
        -:   44:static volatile int32_t g_125[2][1][2] = {{{0L, 0L}}, {{0L, 0L}}};
        -:   45:static volatile int32_t *g_124 = &g_125[0][0][1];
        -:   46:static struct S2 g_132[2] = {{0xF6C78DD8L, 0x42B0CC67L}, {0xF6C78DD8L, 0x42B0CC67L}};
        -:   47:static int32_t **volatile g_135 = &g_91;
        -:   48:
        -:   49:static uint32_t func_1(void);
        -:   50:static int32_t func_2(uint32_t p_3, uint32_t p_4, const int32_t p_5, uint8_t p_6, int8_t p_7);
        -:   51:
        1:   52:static uint32_t func_1(void) {
        1:   53:  int16_t l_8 = (-3L);
        1:   54:  int32_t *l_62 = &g_63;
        1:   55:  uint8_t *l_79 = (void *)0;
        1:   56:  uint16_t *l_84 = &g_22;
        1:   57:  int32_t l_109 = 0xF0F14734L;
        1:   58:  int32_t l_111 = 0xCEF6A3D7L;
        1:   59:  uint32_t l_113[1][5] = {{0x18CB2972L, 0x18CB2972L, 0x18CB2972L, 0x18CB2972L, 0x18CB2972L}};
        -:   60:  int i, j;
        1:   61:  if (((*l_62) |= func_2(l_8, g_9, g_9, l_8, (g_9, g_9)))) {
        1:   62:    uint32_t *l_74 = &g_20;
        1:   63:    uint8_t *l_77 = &g_41;
        1:   64:    uint8_t **l_78 = &l_77;
        -:   65:    uint8_t **l_80[3];
        1:   66:    int64_t l_82 = 0x5BB29A1B0F83D54BLL;
        1:   67:    uint16_t *l_83 = (void *)0;
        1:   68:    int32_t *l_92 = (void *)0;
        -:   69:    int i;
        4:   70:    for (i = 0; i < 3; i++)
        3:   71:      l_80[i] = &l_79;
        1:   72:    if ((g_49, (safe_lshift_func_int16_t_s_s(((safe_sub_func_int64_t_s_s(0L, (((+(((+(safe_sub_func_int64_t_s_s((safe_mul_func_int32_t_s_s((*l_62), ((*l_74)++))), (g_18 & ((-9L) && (((*l_78) = l_77) == (g_81 = l_79))))))), l_82) || 7L)), l_83) != l_84))) & g_34.f2), 1)))) {
    #####:   73:      for (g_9 = 0; (g_9 < 16); g_9++) {
    #####:   74:        uint8_t ***l_87 = &l_80[2];
    #####:   75:        (*l_87) = &g_81;
        -:   76:      }
        -:   77:    } else {
        1:   78:      int32_t *l_88[4] = {&g_63, &g_63, &g_63, &g_63};
        1:   79:      int32_t **l_89 = (void *)0;
        -:   80:      int i;
        1:   81:      l_92 = l_88[2];
        1:   82:      (*l_62) = (safe_mul_func_uint32_t_u_u(g_9, 0x48AADD0FL));
        -:   83:    }
        1:   84:    for (g_63 = 0; (g_63 >= 0); g_63 -= 1) {
        1:   85:      return g_34.f3;
        -:   86:    }
        -:   87:  } else {
    #####:   88:    uint32_t l_99 = 0UL;
    #####:   89:    uint32_t *l_100 = &g_20;
        -:   90:    uint32_t *l_101[2];
    #####:   91:    int32_t l_110 = (-1L);
    #####:   92:    int32_t l_112 = 1L;
        -:   93:    int i;
    #####:   94:    for (i = 0; i < 2; i++)
    #####:   95:      l_101[i] = &g_102[0];
    #####:   96:    if (((g_49, (safe_sub_func_uint64_t_u_u(g_13, (safe_lshift_func_int16_t_s_u((l_99 < l_99), 14))))) ^ (((void *)0 == &g_81) <= (((((*l_100) = 0xD6DA29A6L) & l_99) >= (g_102[2] = g_13)) | 18446744073709551615UL)))) {
    #####:   97:      int32_t *l_103 = &g_63;
    #####:   98:      int32_t *l_104 = (void *)0;
    #####:   99:      int32_t *l_105 = (void *)0;
    #####:  100:      int32_t *l_106 = &g_63;
    #####:  101:      int32_t *l_107 = (void *)0;
        -:  102:      int32_t *l_108[4];
        -:  103:      int i;
    #####:  104:      for (i = 0; i < 4; i++)
    #####:  105:        l_108[i] = (void *)0;
    #####:  106:      --l_113[0][0];
        -:  107:    } else {
    #####:  108:      int32_t l_123 = (-1L);
    #####:  109:      struct S2 *l_131 = &g_132[1];
    #####:  110:      struct S2 **l_133 = (void *)0;
    #####:  111:      struct S2 **l_134 = &l_131;
    #####:  112:    lbl_130:
    #####:  113:      for (g_22 = 0; (g_22 != 22); g_22++) {
    #####:  114:        uint64_t *l_120 = &g_13;
    #####:  115:        uint8_t l_126 = 0xFDL;
    #####:  116:        int32_t *l_127 = &l_111;
    #####:  117:        int32_t **l_128 = &l_127;
    #####:  118:        int32_t **l_129 = &g_91;
    #####:  119:        (*l_129) = ((*l_128) = (((((safe_mul_func_uint64_t_u_u(((*l_120) = 0x387B99205434A3FDLL), ((safe_div_func_uint16_t_u_u(g_34.f2, ((((l_123 <= (-7L)) ^ g_41), l_110), (l_110 & ((&g_63 == g_124) <= l_126))))) < 7UL))) ^ l_126), 9L), g_34.f2), l_127));
    #####:  120:        if (g_18)
    #####:  121:          goto lbl_130;
        -:  122:      }
    #####:  123:      (*l_134) = l_131;
        -:  124:    }
    #####:  125:    (*g_135) = &l_110;
        -:  126:  }
    #####:  127:  return (*l_62);
        -:  128:}
        -:  129:
        1:  130:static int32_t func_2(uint32_t p_3, uint32_t p_4, const int32_t p_5, uint8_t p_6, int8_t p_7) {
        -:  131:  uint64_t *l_12[5];
        1:  132:  int32_t l_14[5][1] = {{1L}, {0x27A4129BL}, {1L}, {0x27A4129BL}, {1L}};
        1:  133:  uint32_t *l_17 = &g_18;
        1:  134:  uint32_t *l_19 = &g_20;
        1:  135:  int32_t *l_21[2][2] = {{&l_14[0][0], &l_14[0][0]}, {&l_14[0][0], &l_14[0][0]}};
        1:  136:  int32_t l_48 = 0x93517891L;
        1:  137:  uint32_t l_59 = 0UL;
        -:  138:  int i, j;
        6:  139:  for (i = 0; i < 5; i++)
        5:  140:    l_12[i] = &g_13;
       1*:  141:  g_23 = (g_22 = (((*l_19) = ((safe_rshift_func_uint64_t_u_s((g_13 ^= g_9), ((g_9 <= ((((((*l_17) = ((p_5 && (l_14[3][0] < ((safe_add_func_int32_t_s_s(p_4, 0xDCDA7209L)), (l_14[3][0] ^ (g_9 & 18446744073709551609UL))))) | g_9)), l_14[3][0]) >= (-2L)) > l_14[4][0]) <= l_14[1][0])), p_6))) || l_14[3][0])) || p_7));
       23:  142:  for (g_9 = 0; (g_9 <= 21); g_9 = safe_add_func_int32_t_s_s(g_9, 1)) {
       22:  143:    uint32_t l_35[2][2][3] = {{{0x23917005L, 0x23917005L, 0xD5EBAE88L}, {0x23917005L, 0x23917005L, 0xD5EBAE88L}}, {{0x23917005L, 0x23917005L, 0xD5EBAE88L}, {0x23917005L, 0x23917005L, 0xD5EBAE88L}}};
       22:  144:    uint8_t *l_40 = &g_41;
       22:  145:    uint32_t *l_42 = &g_18;
       22:  146:    int16_t *l_43 = &g_23;
       22:  147:    uint16_t *l_44 = &g_22;
       22:  148:    int32_t l_45 = (-9L);
       22:  149:    uint64_t *l_50 = &g_13;
       22:  150:    int32_t **l_60 = (void *)0;
       22:  151:    int32_t *l_61 = &l_14[3][0];
        -:  152:    int i, j, k;
       22:  153:    l_45 |= ((safe_lshift_func_uint64_t_u_u((g_13 ^= (safe_rshift_func_int8_t_s_s((safe_rshift_func_uint32_t_u_u(4294967295UL, 25)), 7))), 37)) ^ (((*l_44) = (safe_mul_func_int64_t_s_s(((((g_34, ((*l_43) |= ((l_12[2] == (l_35[0][0][2], l_12[3])) >= ((p_7 ^ (((g_34.f2 ^ (((safe_sub_func_uint32_t_u_u(((safe_lshift_func_uint8_t_u_u((0xA9D4L >= (((*l_40) = (g_9, l_35[0][0][0])), g_18)), p_4)) != 253UL), p_3)), (void *)0) == l_42)), p_3) != g_9)) >= 0L)))) > g_22) > g_22) ^ g_20), l_35[0][1][0]))) >= l_35[0][0][2]));
      22*:  154:    l_61 = (((((((g_18 & (safe_div_func_uint8_t_u_u(255UL, l_48))) < (g_49, (l_45 > (((l_50 = (g_34.f0, l_12[0])) == &g_13), ((safe_lshift_func_uint32_t_u_s((!(safe_rshift_func_uint8_t_u_u((safe_mul_func_uint16_t_u_u(p_4, p_5)), 5))), 23)) && 0x60L))))), g_58), 0x453F4779L) || l_59) < g_9), (void *)0);
        -:  155:  }
        1:  156:  return p_5;
        -:  157:}
        -:  158:
        1:  159:int main(int argc, char *argv[]) {
        -:  160:  int i, j, k;
        1:  161:  int print_hash_value = 0;
       1*:  162:  if (argc == 2 && strcmp(argv[1], "1") == 0)
    #####:  163:    print_hash_value = 1;
        1:  164:  platform_main_begin();
        1:  165:  crc32_gentab();
        1:  166:  func_1();
        1:  167:  transparent_crc(g_9, "g_9", print_hash_value);
        1:  168:  transparent_crc(g_13, "g_13", print_hash_value);
        1:  169:  transparent_crc(g_18, "g_18", print_hash_value);
        1:  170:  transparent_crc(g_20, "g_20", print_hash_value);
        1:  171:  transparent_crc(g_22, "g_22", print_hash_value);
        1:  172:  transparent_crc(g_23, "g_23", print_hash_value);
        1:  173:  transparent_crc(g_34.f0, "g_34.f0", print_hash_value);
        1:  174:  transparent_crc(g_34.f1, "g_34.f1", print_hash_value);
        1:  175:  transparent_crc(g_34.f2, "g_34.f2", print_hash_value);
        1:  176:  transparent_crc(g_34.f3, "g_34.f3", print_hash_value);
        1:  177:  transparent_crc(g_34.f4, "g_34.f4", print_hash_value);
        1:  178:  transparent_crc(g_41, "g_41", print_hash_value);
        1:  179:  transparent_crc(g_49.f0, "g_49.f0", print_hash_value);
        1:  180:  transparent_crc(g_58.f0, "g_58.f0", print_hash_value);
        1:  181:  transparent_crc(g_58.f1, "g_58.f1", print_hash_value);
        1:  182:  transparent_crc(g_63, "g_63", print_hash_value);
        6:  183:  for (i = 0; i < 5; i++) {
        5:  184:    transparent_crc(g_102[i], "g_102[i]", print_hash_value);
        5:  185:    if (print_hash_value)
    #####:  186:      printf("index = [%d]\n", i);
        -:  187:  }
        3:  188:  for (i = 0; i < 2; i++) {
        4:  189:    for (j = 0; j < 1; j++) {
        6:  190:      for (k = 0; k < 2; k++) {
        4:  191:        transparent_crc(g_125[i][j][k], "g_125[i][j][k]", print_hash_value);
        4:  192:        if (print_hash_value)
    #####:  193:          printf("index = [%d][%d][%d]\n", i, j, k);
        -:  194:      }
        -:  195:    }
        -:  196:  }
        3:  197:  for (i = 0; i < 2; i++) {
        2:  198:    transparent_crc(g_132[i].f0, "g_132[i].f0", print_hash_value);
        2:  199:    transparent_crc(g_132[i].f1, "g_132[i].f1", print_hash_value);
        2:  200:    if (print_hash_value)
    #####:  201:      printf("index = [%d]\n", i);
        -:  202:  }
        1:  203:  platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
        1:  204:  return 0;
        -:  205:}
