        -:    0:Source:884.c
        -:    0:Graph:884.gcno
        -:    0:Data:884.gcda
        -:    0:Runs:1
        -:    1:// Options:   --concise --max-struct-fields 5 --max-funcs 2 --max-array-len-per-dim 5 --max-block-depth 3 --max-block-size 2
        -:    2:#include "csmith.h"
        -:    3:
        -:    4:static long __undefined;
        -:    5:
        -:    6:static uint32_t g_2[4] = {18446744073709551615UL, 18446744073709551615UL, 18446744073709551615UL, 18446744073709551615UL};
        -:    7:static volatile int32_t g_3[1][2] = {{0x1EC2DB22L, 0x1EC2DB22L}};
        -:    8:static int32_t g_4 = 2L;
        -:    9:static int32_t g_12 = 0x69AC54C9L;
        -:   10:static int64_t g_14 = 0xE857B1A094951162LL;
        -:   11:static int64_t g_15 = 0x7C0EC0DCEE05243BLL;
        -:   12:static uint8_t g_16 = 0xB8L;
        -:   13:static uint8_t g_28 = 0x59L;
        -:   14:static uint32_t g_31[5] = {0x44BD1A6FL, 0x44BD1A6FL, 0x44BD1A6FL, 0x44BD1A6FL, 0x44BD1A6FL};
        -:   15:static int32_t *volatile g_32 = (void *)0;
        -:   16:static int32_t *volatile g_33 = &g_12;
        -:   17:static uint16_t g_45 = 0xA498L;
        -:   18:static uint16_t g_49 = 4UL;
        -:   19:static uint16_t *g_48[1] = {&g_49};
        -:   20:static uint8_t g_54[5] = {255UL, 255UL, 255UL, 255UL, 255UL};
        -:   21:static volatile uint16_t g_88 = 0xC1C1L;
        -:   22:
        -:   23:static uint16_t func_1(void);
        -:   24:static int32_t func_8(int32_t p_9);
        -:   25:
        1:   26:static uint16_t func_1(void) {
        1:   27:  int32_t *l_5 = (void *)0;
        1:   28:  int32_t l_83 = 1L;
        1:   29:  int32_t l_85 = 0x716B035EL;
        5:   30:  for (g_4 = 3; (g_4 >= 0); g_4 -= 1) {
        4:   31:    int32_t *l_7 = &g_4;
        4:   32:    int32_t **l_6 = &l_7;
        4:   33:    (*l_6) = (l_5 = l_5);
        -:   34:  }
        2:   35:  for (g_4 = 0; (g_4 >= 0); g_4 -= 1) {
        -:   36:    int32_t l_10[1];
        1:   37:    int64_t l_25 = 0x674643A64E785C2FLL;
        1:   38:    uint8_t *l_26 = (void *)0;
        1:   39:    uint8_t *l_27 = &g_28;
        1:   40:    uint32_t *l_30 = &g_31[2];
        1:   41:    int32_t l_68 = 1L;
        1:   42:    int32_t l_82 = 0L;
        1:   43:    int32_t l_84 = (-1L);
        1:   44:    int32_t l_86 = (-6L);
        1:   45:    int32_t l_87 = 0xAFD6114BL;
        -:   46:    int i;
        2:   47:    for (i = 0; i < 1; i++)
        1:   48:      l_10[i] = 3L;
       1*:   49:    (*g_33) = (((g_3[0][0] & func_8(l_10[0])) & l_10[0]) ^ (safe_rshift_func_int64_t_s_u((+(safe_mul_func_int8_t_s_s(l_10[0], ((*l_27) = l_25)))), (((!((*l_30) = 4294967293UL)) > l_10[0]) && (l_10[0] > 0L)))));
       1*:   50:    for (g_16 = 0; (g_16 <= 0); g_16 += 1) {
        1:   51:      uint16_t *l_44 = &g_45;
        1:   52:      int32_t l_50 = 0xECDCC21DL;
        1:   53:      uint8_t *l_53 = &g_54[3];
        1:   54:      int32_t l_55 = 0x955DF93CL;
        1:   55:      uint32_t *l_67 = &g_31[2];
        1:   56:      int32_t *l_78 = &l_68;
        1:   57:      int32_t *l_79 = &l_50;
        1:   58:      int32_t *l_80 = &g_12;
        1:   59:      int32_t *l_81[3][4] = {{&l_50, &g_4, &g_4, &l_50}, {&g_4, &l_50, &g_4, &g_4}, {&l_50, &l_50, &g_4, &l_50}};
        -:   60:      int i, j;
        1:   61:      if ((safe_sub_func_uint8_t_u_u((0x899DB221L <= ((((safe_mul_func_uint8_t_u_u((safe_rshift_func_uint64_t_u_s((safe_div_func_int32_t_s_s((safe_sub_func_uint32_t_u_u((((*l_44) &= g_3[g_4][(g_16 + 1)]) != (((((safe_add_func_int8_t_s_s(g_31[1], l_10[0])), g_48[0]) == (void *)0), (l_50 &= (-1L))) > (((*l_27) = g_2[2]) | ((*l_53) = ((safe_add_func_uint32_t_u_u(g_31[2], l_25)) ^ g_49))))), l_55)), (-6L))), 52)), g_12)), g_2[0]) == g_14) ^ l_55)), l_25))) {
        -:   62:        uint16_t *l_58[2];
        1:   63:        int64_t *l_59 = &g_15;
        1:   64:        uint32_t *l_66 = &g_31[2];
        -:   65:        int i, j;
        3:   66:        for (i = 0; i < 2; i++)
        2:   67:          l_58[i] = &g_49;
        1:   68:        if ((*g_33))
        1:   69:          break;
    #####:   70:        g_3[g_4][(g_16 + 1)] = (safe_div_func_int16_t_s_s(((l_58[0] != &g_45), (((((*l_59) &= g_49), (safe_mod_func_uint32_t_u_u(l_50, (((*l_53) = ((l_10[0] == g_3[g_4][(g_16 + 1)]), (((~((~(safe_mod_func_uint64_t_u_u((g_31[0] | (((&l_5 == &l_5), l_66) != &g_31[4])), g_3[g_4][(g_16 + 1)]))) && g_3[0][1])) == l_55) >= l_25))) && g_31[2])))), l_67) != l_67)), 0x9396L));
        -:   71:      } else {
    #####:   72:        int32_t *l_69 = &l_55;
    #####:   73:        int32_t *l_70 = &l_55;
    #####:   74:        int32_t *l_71 = &l_50;
    #####:   75:        int32_t *l_72 = &g_12;
    #####:   76:        int32_t *l_73 = (void *)0;
    #####:   77:        int32_t *l_74[4][1][4] = {{{&g_12, &l_50, &l_50, &g_12}}, {{&l_50, &g_12, &l_50, &l_50}}, {{&g_12, &g_12, &l_55, &g_12}}, {{&g_12, &l_50, &l_50, &g_12}}};
    #####:   78:        uint32_t l_75 = 0xB22E0064L;
        -:   79:        int i, j, k;
    #####:   80:        l_75--;
        -:   81:      }
    #####:   82:      g_88--;
        -:   83:    }
        -:   84:  }
        1:   85:  return l_83;
        -:   86:}
        -:   87:
        1:   88:static int32_t func_8(int32_t p_9) {
        1:   89:  int32_t *l_11 = &g_12;
        1:   90:  int32_t *l_13[1][2][2] = {{{&g_4, &g_4}, {&g_4, &g_4}}};
        1:   91:  uint32_t l_19 = 5UL;
        -:   92:  int i, j, k;
        1:   93:  g_16--;
        1:   94:  return l_19;
        -:   95:}
        -:   96:
        1:   97:int main(int argc, char *argv[]) {
        -:   98:  int i, j;
        1:   99:  int print_hash_value = 0;
       1*:  100:  if (argc == 2 && strcmp(argv[1], "1") == 0)
    #####:  101:    print_hash_value = 1;
        1:  102:  platform_main_begin();
        1:  103:  crc32_gentab();
        1:  104:  func_1();
        5:  105:  for (i = 0; i < 4; i++) {
        4:  106:    transparent_crc(g_2[i], "g_2[i]", print_hash_value);
        4:  107:    if (print_hash_value)
    #####:  108:      printf("index = [%d]\n", i);
        -:  109:  }
        2:  110:  for (i = 0; i < 1; i++) {
        3:  111:    for (j = 0; j < 2; j++) {
        2:  112:      transparent_crc(g_3[i][j], "g_3[i][j]", print_hash_value);
        2:  113:      if (print_hash_value)
    #####:  114:        printf("index = [%d][%d]\n", i, j);
        -:  115:    }
        -:  116:  }
        1:  117:  transparent_crc(g_4, "g_4", print_hash_value);
        1:  118:  transparent_crc(g_12, "g_12", print_hash_value);
        1:  119:  transparent_crc(g_14, "g_14", print_hash_value);
        1:  120:  transparent_crc(g_15, "g_15", print_hash_value);
        1:  121:  transparent_crc(g_16, "g_16", print_hash_value);
        1:  122:  transparent_crc(g_28, "g_28", print_hash_value);
        6:  123:  for (i = 0; i < 5; i++) {
        5:  124:    transparent_crc(g_31[i], "g_31[i]", print_hash_value);
        5:  125:    if (print_hash_value)
    #####:  126:      printf("index = [%d]\n", i);
        -:  127:  }
        1:  128:  transparent_crc(g_45, "g_45", print_hash_value);
        1:  129:  transparent_crc(g_49, "g_49", print_hash_value);
        6:  130:  for (i = 0; i < 5; i++) {
        5:  131:    transparent_crc(g_54[i], "g_54[i]", print_hash_value);
        5:  132:    if (print_hash_value)
    #####:  133:      printf("index = [%d]\n", i);
        -:  134:  }
        1:  135:  transparent_crc(g_88, "g_88", print_hash_value);
        1:  136:  platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
        1:  137:  return 0;
        -:  138:}
