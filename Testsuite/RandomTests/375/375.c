// Options:   --concise --max-struct-fields 5 --max-funcs 2 --max-array-len-per-dim 5 --max-block-depth 3 --max-block-size 2
#include "csmith.h"

static long __undefined;

#pragma pack(push)
#pragma pack(1)
struct S0 {
  const volatile unsigned f0 : 14;
  const unsigned f1 : 11;
  volatile signed f2 : 1;
  const unsigned f3 : 9;
};
#pragma pack(pop)

static uint32_t g_3 = 5UL;
static uint8_t g_11[1][5][2] = {{{7UL, 0UL}, {1UL, 7UL}, {0x7CL, 0x7CL}, {0x7CL, 7UL}, {1UL, 0UL}}};
static volatile int32_t *g_20 = (void *)0;
static uint32_t g_28 = 0x058BBE58L;
static int32_t g_31 = (-3L);
static int16_t g_34 = 0x8160L;
static int8_t g_72 = (-4L);
static uint16_t g_75 = 0x9D3FL;
static int64_t g_78 = 0xCC4EFF443A54D8FDLL;
static uint8_t g_80 = 1UL;
static struct S0 g_92 = {64, 21, 0, 8};
static int32_t **volatile g_93 = (void *)0;
static int32_t *g_95 = &g_31;
static int32_t **volatile g_94[4][5][4] = {{{&g_95, &g_95, &g_95, &g_95}, {(void *)0, &g_95, &g_95, (void *)0}, {&g_95, (void *)0, &g_95, &g_95}, {&g_95, &g_95, &g_95, &g_95}, {(void *)0, &g_95, &g_95, &g_95}}, {{&g_95, &g_95, &g_95, &g_95}, {&g_95, (void *)0, &g_95, (void *)0}, {&g_95, &g_95, &g_95, &g_95}, {(void *)0, &g_95, &g_95, (void *)0}, {&g_95, &g_95, (void *)0, &g_95}}, {{&g_95, (void *)0, &g_95, &g_95}, {&g_95, &g_95, &g_95, &g_95}, {(void *)0, (void *)0, &g_95, &g_95}, {&g_95, &g_95, &g_95, &g_95}, {(void *)0, &g_95, &g_95, &g_95}}, {{&g_95, &g_95, &g_95, &g_95}, {&g_95, &g_95, (void *)0, &g_95}, {&g_95, (void *)0, &g_95, &g_95}, {&g_95, &g_95, &g_95, &g_95}, {(void *)0, (void *)0, &g_95, &g_95}}};
static int32_t **volatile g_96 = (void *)0;
static int32_t **volatile g_97 = &g_95;
static int32_t g_124 = 0x5BAC9057L;
static int32_t g_127 = (-1L);
static struct S0 *g_130 = &g_92;
static struct S0 **volatile g_129 = &g_130;
static uint32_t g_136 = 0x0F311A8DL;

static uint32_t func_1(void);
static struct S0 func_6(int32_t p_7, uint64_t p_8, uint8_t p_9);

static uint32_t func_1(void) {
  int32_t *l_2 = (void *)0;
  int32_t l_10 = 0xD3A18E41L;
  uint32_t *l_27 = &g_28;
  int32_t *l_29 = (void *)0;
  int32_t *l_30 = &g_31;
  uint32_t l_32 = 0x9634D71BL;
  int16_t *l_33 = &g_34;
  int16_t l_35[1][2];
  int64_t *l_135[5][1] = {{&g_78}, {&g_78}, {&g_78}, {&g_78}, {&g_78}};
  int i, j;
  for (i = 0; i < 1; i++) {
    for (j = 0; j < 2; j++)
      l_35[i][j] = 0xE626L;
  }
  ++g_3;
  (*l_30) = (((g_136 = (func_6(l_10, g_11[0][2][1], (((safe_mod_func_uint16_t_u_u((safe_lshift_func_int64_t_s_u((0xF3FAA32FL <= (((safe_add_func_int16_t_s_s(((*l_33) = (((((*l_30) = (safe_mod_func_int8_t_s_s(0x13L, ((((void *)0 == g_20) || g_11[0][4][1]) ^ ((*l_27) ^= ((safe_add_func_uint8_t_u_u((g_11[0][2][1] != (safe_div_func_uint8_t_u_u((safe_mul_func_uint8_t_u_u((g_3 ^ g_11[0][4][1]), 0xEBL)), l_10))), g_3)) ^ 0xC6DD3ED2L)))))) < l_32) > g_11[0][4][1]) < g_11[0][3][1])), 0x6892L)) <= l_35[0][1]) != g_3)), 32)), 0x4D0CL)) < g_11[0][2][1]) >= g_3)), (*l_30))) && 0xC2B75F9727A2C147LL), (-7L));
  return g_80;
}

static struct S0 func_6(int32_t p_7, uint64_t p_8, uint8_t p_9) {
  int32_t l_55 = 0xE64BFCE9L;
lbl_134:
  for (p_7 = 0; (p_7 < 7); p_7++) {
    uint16_t l_40[5][2][2] = {{{0x2F52L, 0x9F88L}, {0x5F6BL, 0x2F52L}}, {{1UL, 1UL}, {1UL, 0x2F52L}}, {{0x5F6BL, 0x9F88L}, {0x2F52L, 0x9F88L}}, {{0x5F6BL, 0x2F52L}, {1UL, 1UL}}, {{1UL, 0x2F52L}, {0x5F6BL, 0x9F88L}}};
    int8_t *l_70 = (void *)0;
    int8_t *l_71 = &g_72;
    int32_t l_73[2][4][2] = {{{(-1L), 0xF019D5C0L}, {0x80627DBDL, (-1L)}, {0L, 0L}, {0L, (-1L)}}, {{0x80627DBDL, 0xF019D5C0L}, {(-1L), 0xF019D5C0L}, {0x80627DBDL, (-1L)}, {0L, 0L}}};
    uint16_t *l_74[3];
    int32_t l_76 = (-1L);
    int64_t *l_77 = &g_78;
    uint8_t *l_79 = &g_80;
    uint8_t *l_81 = &g_11[0][2][1];
    int32_t l_82[5][1];
    int32_t *l_84 = &g_31;
    int32_t **l_83 = &l_84;
    int i, j, k;
    for (i = 0; i < 3; i++)
      l_74[i] = &g_75;
    for (i = 0; i < 5; i++) {
      for (j = 0; j < 1; j++)
        l_82[i][j] = (-4L);
    }
    l_82[1][0] |= (safe_div_func_int16_t_s_s(
        ((g_3 && (l_40[1][1][0] >=
                  (safe_rshift_func_int32_t_s_u(((((*l_81) = (safe_rshift_func_int32_t_s_u((((*l_79) ^= (safe_div_func_int32_t_s_s((((safe_rshift_func_uint8_t_u_s(g_31, 5)), ((*l_77) = (((safe_rshift_func_uint64_t_u_s(g_11[0][2][0], 23)) != ((((safe_mul_func_int8_t_s_s(g_11[0][2][1], l_55)) != (safe_add_func_uint32_t_u_u((safe_rshift_func_int16_t_s_u((p_8 | ((((0x81L && (((safe_lshift_func_int32_t_s_s((safe_lshift_func_uint64_t_u_s((safe_sub_func_uint16_t_u_u((l_76 = (safe_div_func_int16_t_s_s((l_73[1][0][1] ^= (safe_rshift_func_int8_t_s_u(((*l_71) = ((l_55 <= l_55) != (-1L))), 6))), p_8))), g_28)), g_3)), 6)), (void *)0) != &g_28)), g_72) | l_40[1][1][0]) <= 0L)), 3)), p_9))) || (-4L)) && g_31)) > g_3))) <= g_75), l_40[2][1][1]))) ^ g_11[0][3][1]), 9))) | g_28) != 0L), p_7)))) == l_55),
        g_28));
    (*l_83) = &g_31;
  }
  for (p_8 = (-16); (p_8 <= 25); p_8++) {
    int8_t *l_87 = &g_72;
    int32_t l_118 = 0x4B85C557L;
    int32_t l_125 = 0xEB4CA122L;
    if (((l_87 != &g_72) | (safe_mod_func_int16_t_s_s(0x417FL, g_72)))) {
      for (p_7 = 19; (p_7 == 27); p_7 = safe_add_func_uint64_t_u_u(p_7, 9)) {
        return g_92;
      }
      (*g_97) = &g_31;
    } else {
      const int16_t l_120 = (-1L);
      struct S0 *const l_128[1] = {&g_92};
      int i;
      for (g_78 = 11; (g_78 < 5); g_78--) {
        int16_t l_119[1];
        int32_t l_121 = 0x951F222DL;
        int32_t *l_122 = &l_118;
        int32_t *l_123 = &g_124;
        int32_t *l_126 = &g_127;
        int i;
        for (i = 0; i < 1; i++)
          l_119[i] = 0L;
        (*l_126) ^= (((((*l_123) = ((*l_122) = ((l_121 = (safe_sub_func_uint16_t_u_u(((safe_add_func_uint8_t_u_u(((safe_sub_func_int32_t_s_s((((((safe_mod_func_uint8_t_u_u(((((safe_lshift_func_int64_t_s_s((((*g_95) ^= p_9) ^ p_7), (((1L | g_78) || p_8) > (((((safe_mod_func_int8_t_s_s(((g_92, p_7) && (((safe_mul_func_int8_t_s_s(((((l_118 || (6UL && 4L)) | g_72) && 0x12E219839B2FD4BBLL) & l_119[0]), 4UL)) != 0x71CFL) >= g_92.f0)), 0x78L)), 0xDA4F77C9A86FCAFALL) != p_9) ^ 4294967295UL) || p_8)))) <= 0L), p_7) >= g_3), l_119[0])), 0x33B1D787L), l_119[0]) > l_55) ^ 0L), (-1L))) <= 0x3AL), l_119[0])) | l_120), p_9))) & 0L))) || p_9) >= g_92.f1) & l_125);
        (*g_129) = l_128[0];
      }
    }
    for (g_75 = 0; (g_75 <= 0); g_75 += 1) {
      uint64_t l_131 = 0xBD61F34F691D68C9LL;
      for (l_55 = 3; (l_55 >= 0); l_55 -= 1) {
        ++l_131;
      }
      for (g_80 = 0; (g_80 <= 0); g_80 += 1) {
        if (g_92.f3)
          goto lbl_134;
        return g_92;
      }
    }
  }
  return g_92;
}

int main(int argc, char *argv[]) {
  int i, j, k;
  int print_hash_value = 0;
  if (argc == 2 && strcmp(argv[1], "1") == 0)
    print_hash_value = 1;
  platform_main_begin();
  crc32_gentab();
  func_1();
  transparent_crc(g_3, "g_3", print_hash_value);
  for (i = 0; i < 1; i++) {
    for (j = 0; j < 5; j++) {
      for (k = 0; k < 2; k++) {
        transparent_crc(g_11[i][j][k], "g_11[i][j][k]", print_hash_value);
        if (print_hash_value)
          printf("index = [%d][%d][%d]\n", i, j, k);
      }
    }
  }
  transparent_crc(g_28, "g_28", print_hash_value);
  transparent_crc(g_31, "g_31", print_hash_value);
  transparent_crc(g_34, "g_34", print_hash_value);
  transparent_crc(g_72, "g_72", print_hash_value);
  transparent_crc(g_75, "g_75", print_hash_value);
  transparent_crc(g_78, "g_78", print_hash_value);
  transparent_crc(g_80, "g_80", print_hash_value);
  transparent_crc(g_92.f0, "g_92.f0", print_hash_value);
  transparent_crc(g_92.f1, "g_92.f1", print_hash_value);
  transparent_crc(g_92.f2, "g_92.f2", print_hash_value);
  transparent_crc(g_92.f3, "g_92.f3", print_hash_value);
  transparent_crc(g_124, "g_124", print_hash_value);
  transparent_crc(g_127, "g_127", print_hash_value);
  transparent_crc(g_136, "g_136", print_hash_value);
  platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
  return 0;
}
