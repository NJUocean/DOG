        -:    0:Source:152.c
        -:    0:Graph:152.gcno
        -:    0:Data:152.gcda
        -:    0:Runs:1
        -:    1:// Options:   --concise --max-struct-fields 5 --max-funcs 2 --max-array-len-per-dim 5 --max-block-depth 3 --max-block-size 2
        -:    2:#include "csmith.h"
        -:    3:
        -:    4:static long __undefined;
        -:    5:
        -:    6:static volatile int32_t g_2 = 0xDC85F70AL;
        -:    7:static int32_t g_3 = 0x2EE76F50L;
        -:    8:static const int32_t *g_15 = &g_3;
        -:    9:static const int32_t **volatile g_14 = &g_15;
        -:   10:static uint16_t g_22 = 0xB78AL;
        -:   11:static uint16_t g_48[1][4][5] = {{{65533UL, 6UL, 65533UL, 65533UL, 6UL}, {6UL, 65533UL, 65533UL, 6UL, 65533UL}, {6UL, 6UL, 65533UL, 6UL, 6UL}, {65533UL, 6UL, 65533UL, 65533UL, 6UL}}};
        -:   12:static int32_t *const volatile g_49[2][5] = {{(void *)0, (void *)0, (void *)0, (void *)0, (void *)0}, {(void *)0, (void *)0, (void *)0, (void *)0, (void *)0}};
        -:   13:static int32_t *volatile g_50 = (void *)0;
        -:   14:static int32_t g_55 = 0xAD92EDCDL;
        -:   15:static uint64_t g_64 = 0UL;
        -:   16:static uint64_t g_73 = 18446744073709551609UL;
        -:   17:static uint8_t g_84 = 0xC7L;
        -:   18:static int32_t g_87 = (-10L);
        -:   19:static int32_t g_88 = 0x833481FFL;
        -:   20:static uint16_t g_89 = 0xFCA5L;
        -:   21:static int32_t *volatile g_92 = &g_3;
        -:   22:
        -:   23:static int32_t func_1(void);
        -:   24:static int32_t *const func_7(uint32_t p_8, int32_t p_9, uint8_t p_10, const int32_t *const p_11, uint8_t p_12);
        -:   25:
        1:   26:static int32_t func_1(void) {
        1:   27:  const int32_t *const l_13 = &g_3;
        1:   28:  uint64_t *l_72 = &g_73;
        1:   29:  uint64_t *l_76 = &g_73;
        1:   30:  uint32_t l_93 = 0xC9AC803BL;
       1*:   31:  for (g_3 = 18; (g_3 < 13); g_3 = safe_sub_func_uint16_t_u_u(g_3, 5)) {
    #####:   32:    uint8_t l_6 = 251UL;
    #####:   33:    int32_t *l_54 = &g_55;
    #####:   34:    if (l_6)
    #####:   35:      break;
    #####:   36:    l_54 = func_7((4UL | 1L), g_2, g_3, l_13, (*l_13));
        -:   37:  }
       1*:   38:  for (g_22 = 19; (g_22 == 57); g_22 = safe_add_func_int16_t_s_s(g_22, 5)) {
    #####:   39:    int32_t l_62[2][4][5] = {{{0xE5FAF1BEL, 0x202D95C7L, 0xE5463754L, 0xE5463754L, 0x202D95C7L}, {6L, 0x6BEC1606L, 1L, 0xC758019DL, 1L}, {0xE5FAF1BEL, 0x202D95C7L, 0xE5463754L, 0xE5463754L, 0x202D95C7L}, {6L, 0x859B3460L, 1L, 0x6BEC1606L, 0xE3FF50EDL}}, {{0x632CBEB0L, 1L, 0x202D95C7L, 0x202D95C7L, 1L}, {0xAC96AAE1L, 0x859B3460L, 1L, 0x6BEC1606L, 0xE3FF50EDL}, {0x632CBEB0L, 1L, 0x202D95C7L, 0x202D95C7L, 1L}, {0xAC96AAE1L, 0x859B3460L, 1L, 0x6BEC1606L, 0xE3FF50EDL}}};
    #####:   40:    uint64_t *l_63 = &g_64;
    #####:   41:    uint64_t *l_75 = &g_73;
        -:   42:    uint64_t **l_74[2];
    #####:   43:    uint8_t *l_83 = &g_84;
        -:   44:    int i, j, k;
    #####:   45:    for (i = 0; i < 2; i++)
    #####:   46:      l_74[i] = &l_75;
    #####:   47:    (*g_92) = (safe_add_func_uint8_t_u_u((safe_mod_func_uint64_t_u_u(((*l_63)++), g_55)), (0xB7L ^ ((safe_sub_func_int64_t_s_s(((safe_mod_func_uint8_t_u_u(((!(l_72 != (l_76 = l_72))) & (((void *)0 == &g_73) || (safe_lshift_func_int32_t_s_s((safe_rshift_func_uint32_t_u_u(((safe_lshift_func_uint8_t_u_s(g_73, ((((++(*l_83)) != 3UL) | ((g_89--), ((*l_13), g_87))) | 0xF8EE8584L))) >= g_22), g_87)), 4)))), 0x96L)) && g_22), l_62[1][1][0])) < g_73))));
        -:   48:  }
        1:   49:  return l_93;
        -:   50:}
        -:   51:
    #####:   52:static int32_t *const func_7(uint32_t p_8, int32_t p_9, uint8_t p_10, const int32_t *const p_11, uint8_t p_12) {
    #####:   53:  int32_t l_23 = 0x15E314A5L;
    #####:   54:  int32_t l_25 = 6L;
    #####:   55:  int32_t l_26 = 1L;
    #####:   56:  int32_t l_27[4][3] = {{0x11A796D4L, 0x11A796D4L, 0x87D6364DL}, {0x11A796D4L, 0x11A796D4L, 0x87D6364DL}, {0x11A796D4L, 0x11A796D4L, 0x87D6364DL}, {0x11A796D4L, 0x11A796D4L, 0x87D6364DL}};
    #####:   57:  uint16_t *l_47 = &g_48[0][2][1];
        -:   58:  int i, j;
    #####:   59:lbl_53:
    #####:   60:  (*g_14) = p_11;
    #####:   61:  if ((*g_15)) {
    #####:   62:    const int8_t l_18 = 1L;
    #####:   63:    uint16_t *l_19 = (void *)0;
    #####:   64:    uint16_t *l_20 = (void *)0;
        -:   65:    uint16_t *l_21[1];
    #####:   66:    int32_t l_24 = (-1L);
        -:   67:    int32_t *l_51[3][5];
        -:   68:    int i, j;
    #####:   69:    for (i = 0; i < 1; i++)
    #####:   70:      l_21[i] = &g_22;
    #####:   71:    for (i = 0; i < 3; i++) {
    #####:   72:      for (j = 0; j < 5; j++)
    #####:   73:        l_51[i][j] = &l_27[0][1];
        -:   74:    }
    #####:   75:    l_27[0][1] = (safe_add_func_int16_t_s_s((l_18 ^ (g_22--)), ((((((+(0xEE1DL | (safe_sub_func_uint32_t_u_u(p_10, (safe_unary_minus_func_uint64_t_u((safe_rshift_func_int8_t_s_s((0x3334L <= (((safe_lshift_func_int16_t_s_u(((safe_lshift_func_uint32_t_u_u(l_26, ((safe_add_func_int32_t_s_s((safe_lshift_func_uint32_t_u_s(((((**g_14) <= (!(l_18 <= (safe_mul_func_uint8_t_u_u((((*g_15), l_47) == l_47), p_8))))) < l_27[2][1]) & 0x552AL), l_25)), 0x95EF2B5DL)), l_27[1][2]))) != (-1L)), l_27[0][1])) >= l_24), g_3)), p_12)))))))) != g_48[0][2][1]) <= l_18) && l_27[0][0]) <= p_8) || p_9)));
    #####:   76:    l_26 = (~g_48[0][2][1]);
        -:   77:  } else {
    #####:   78:    if (l_26)
    #####:   79:      goto lbl_53;
        -:   80:  }
    #####:   81:  return &g_3;
        -:   82:}
        -:   83:
        1:   84:int main(int argc, char *argv[]) {
        -:   85:  int i, j, k;
        1:   86:  int print_hash_value = 0;
       1*:   87:  if (argc == 2 && strcmp(argv[1], "1") == 0)
    #####:   88:    print_hash_value = 1;
        1:   89:  platform_main_begin();
        1:   90:  crc32_gentab();
        1:   91:  func_1();
        1:   92:  transparent_crc(g_2, "g_2", print_hash_value);
        1:   93:  transparent_crc(g_3, "g_3", print_hash_value);
        1:   94:  transparent_crc(g_22, "g_22", print_hash_value);
        2:   95:  for (i = 0; i < 1; i++) {
        5:   96:    for (j = 0; j < 4; j++) {
       24:   97:      for (k = 0; k < 5; k++) {
       20:   98:        transparent_crc(g_48[i][j][k], "g_48[i][j][k]", print_hash_value);
       20:   99:        if (print_hash_value)
    #####:  100:          printf("index = [%d][%d][%d]\n", i, j, k);
        -:  101:      }
        -:  102:    }
        -:  103:  }
        1:  104:  transparent_crc(g_55, "g_55", print_hash_value);
        1:  105:  transparent_crc(g_64, "g_64", print_hash_value);
        1:  106:  transparent_crc(g_73, "g_73", print_hash_value);
        1:  107:  transparent_crc(g_84, "g_84", print_hash_value);
        1:  108:  transparent_crc(g_87, "g_87", print_hash_value);
        1:  109:  transparent_crc(g_88, "g_88", print_hash_value);
        1:  110:  transparent_crc(g_89, "g_89", print_hash_value);
        1:  111:  platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
        1:  112:  return 0;
        -:  113:}
