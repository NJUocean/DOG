// Options:   --concise --max-struct-fields 5 --max-funcs 2 --max-array-len-per-dim 5 --max-block-depth 3 --max-block-size 2
#include "csmith.h"

static long __undefined;

struct S1 {
  unsigned f0 : 3;
  signed f1 : 16;
  unsigned f2 : 1;
  volatile signed f3 : 5;
};

#pragma pack(push)
#pragma pack(1)
struct S2 {
  const unsigned f0 : 20;
  const unsigned f1 : 26;
  int8_t f2;
  unsigned f3 : 31;
  int32_t f4;
};
#pragma pack(pop)

union U3 {
  signed f0 : 17;
  volatile uint64_t f1;
  uint32_t f2;
  uint64_t f3;
  volatile signed f4 : 23;
};

union U4 {
  int32_t f0;
  volatile uint8_t f1;
  uint16_t f2;
  int8_t f3;
  uint32_t f4;
};

union U5 {
  int64_t f0;
  volatile signed f1 : 4;
  uint8_t f2;
};

union U7 {
  const int64_t f0;
  volatile int8_t f1;
  int32_t f2;
  const volatile uint32_t f3;
};

static int32_t g_15 = 0x205300CEL;
static struct S2 g_20 = {878, 6783, 0xF3L, 23431, -1L};
static uint64_t g_24 = 0x5C7E4DDBB7A2E255LL;
static uint8_t g_28[2][3] = {{255UL, 255UL, 255UL}, {255UL, 255UL, 255UL}};
static union U3 g_35 = {0L};
static const union U5 g_36 = {-1L};
static union U4 g_55[5] = {{4L}, {4L}, {4L}, {4L}, {4L}};
static int32_t g_56[4] = {0L, 0L, 0L, 0L};
static int32_t *g_63[3][5][3] = {{{&g_20.f4, &g_20.f4, &g_20.f4}, {&g_56[2], &g_56[2], &g_56[3]}, {&g_56[2], &g_20.f4, &g_56[2]}, {&g_56[2], &g_56[3], &g_56[3]}, {&g_20.f4, &g_20.f4, &g_20.f4}}, {{&g_56[2], &g_56[2], &g_56[3]}, {&g_56[2], &g_20.f4, &g_56[2]}, {&g_56[2], &g_56[3], &g_56[3]}, {&g_20.f4, &g_20.f4, &g_20.f4}, {&g_56[2], &g_56[2], &g_56[3]}}, {{&g_56[2], &g_20.f4, &g_56[2]}, {&g_56[2], &g_56[3], &g_56[3]}, {&g_20.f4, &g_20.f4, &g_20.f4}, {&g_56[2], &g_56[2], &g_56[3]}, {&g_56[2], &g_20.f4, &g_56[2]}}};
static int32_t **volatile g_62 = &g_63[1][1][0];
static uint8_t *const **volatile g_67[2] = {(void *)0, (void *)0};
static union U7 g_73 = {0xC4DC47558758A71DLL};
static int32_t *volatile g_74 = &g_56[2];
static volatile struct S1 g_77 = {1, 251, 0, -4};
static struct S1 g_88 = {1, -208, 0, 4};
static int32_t *volatile g_93 = &g_56[2];
static struct S1 ****volatile g_102 = (void *)0;
static struct S1 *g_107 = &g_88;
static struct S1 **g_106 = &g_107;
static struct S1 ***g_105 = &g_106;

static const int64_t func_1(void);
static union U7 func_6(int32_t p_7, uint8_t p_8, uint64_t p_9, uint8_t p_10, uint8_t p_11);

static const int64_t func_1(void) {
  int32_t l_14 = 0xA08BBD18L;
  int32_t l_21 = 1L;
  int32_t l_22 = (-1L);
  uint64_t *l_23 = &g_24;
  uint8_t *l_27[4][1][5] = {{{&g_28[1][1], &g_28[1][0], &g_28[1][0], &g_28[1][1], &g_28[1][0]}}, {{(void *)0, (void *)0, &g_28[0][2], (void *)0, (void *)0}}, {{&g_28[1][0], &g_28[1][1], &g_28[1][0], &g_28[1][0], &g_28[1][1]}}, {{(void *)0, &g_28[0][2], &g_28[0][2], (void *)0, &g_28[0][2]}}};
  int i, j, k;
  if (((safe_div_func_uint32_t_u_u(4294967293UL, 0xBBB4F5ACL)) | ((~(~((((l_21 = (func_6((safe_lshift_func_uint8_t_u_u((l_14, g_15), 5)), g_15, l_14, (((g_28[0][1] = (safe_rshift_func_int8_t_s_s((safe_mod_func_uint16_t_u_u((((g_20, (((((*l_23)--) && l_22) && (g_20.f3 || 0xF9L)) != 0xC53A21B78CD908FBLL)) == 0xBEC151D1A932DA3BLL) < g_20.f2), g_20.f2)), 0))) <= g_20.f1) && 0L), g_20.f4), l_14)) < g_55[0].f0), 0x55L) != g_20.f3))) ^ (-7L)))) {
    volatile struct S1 *l_78 = &g_77;
    (*g_74) &= l_14;
    (*l_78) = ((safe_div_func_uint8_t_u_u(l_22, 0x73L)), g_77);
  } else {
    int8_t *l_80 = (void *)0;
    int8_t *l_81 = &g_55[0].f3;
    int8_t *l_82 = &g_20.f2;
    int32_t l_83[4] = {5L, 5L, 5L, 5L};
    struct S1 *l_101 = &g_88;
    struct S1 **l_100 = &l_101;
    struct S1 ***l_99 = &l_100;
    int8_t l_108 = 6L;
    int i;
    if ((!(l_83[1] = (((*l_82) |= (0L && g_56[2])) <= ((*l_81) = (-1L)))))) {
      uint64_t l_91 = 2UL;
      uint32_t l_92 = 6UL;
      if ((l_14 && ((safe_add_func_int64_t_s_s((0L & l_21), (safe_sub_func_int64_t_s_s((g_88, (7L < ((g_28[0][1], 0UL), (((l_22 > ((l_83[2], 0xE71BL) > g_56[3])), l_91) == l_92)))), g_35.f0)))) & (-1L)))) {
        struct S1 *l_95 = &g_88;
        struct S1 **l_94 = &l_95;
        (*g_93) = (*g_74);
        (*l_94) = (void *)0;
      } else {
        uint8_t l_96 = 0xDBL;
        int32_t *l_97 = (void *)0;
        int32_t *l_98[1];
        int i;
        for (i = 0; i < 1; i++)
          l_98[i] = (void *)0;
        (*g_93) |= ((18446744073709551611UL <= g_20.f4) >= l_96);
      }
    } else {
      struct S1 ****l_103 = (void *)0;
      struct S1 ****l_104[1];
      int i;
      for (i = 0; i < 1; i++)
        l_104[i] = &l_99;
      g_105 = l_99;
    }
    l_108 = (-1L);
  }
  return l_22;
}

static union U7 func_6(int32_t p_7, uint8_t p_8, uint64_t p_9, uint8_t p_10, uint8_t p_11) {
  uint64_t *l_31[2][3] = {{(void *)0, &g_24, &g_24}, {(void *)0, &g_24, &g_24}};
  const struct S2 l_70 = {969, 49, 0xE9L, 36375, 0x3884E3EEL};
  int32_t *l_71[2][4] = {{&g_56[2], &g_55[0].f0, &g_55[0].f0, &g_56[2]}, {&g_55[0].f0, &g_56[2], &g_55[0].f0, &g_55[0].f0}};
  int32_t l_72 = 0L;
  int i, j;
  for (g_15 = 0; (g_15 >= (-30)); g_15 = safe_sub_func_int32_t_s_s(g_15, 2)) {
    uint16_t l_57 = 5UL;
    if (((void *)0 == l_31[1][2])) {
      uint8_t *l_58 = &g_28[0][2];
      int8_t *l_59 = &g_20.f2;
      int32_t *l_60 = &g_56[2];
      int32_t l_61 = 5L;
      if ((((*l_60) = (safe_div_func_int16_t_s_s(((((!(g_35, (g_36, (safe_unary_minus_func_uint16_t_u((0x96B49548L != ((safe_lshift_func_int8_t_s_u(((*l_59) = (safe_add_func_uint32_t_u_u((safe_sub_func_uint8_t_u_u(g_15, p_8)), (safe_lshift_func_int8_t_s_u(((~(((safe_sub_func_int8_t_s_s(p_10, ((*l_58) = (g_20.f1 < (((safe_div_func_uint16_t_u_u((safe_sub_func_int64_t_s_s((-5L), (safe_mul_func_int8_t_s_s((g_55[0], g_56[2]), 1UL)))), 0x7921L)) < l_57), 0x3979D795BCD5918CLL))))) < p_9) == g_20.f1)) | p_11), g_20.f3))))), 3)) ^ (-1L)))))))) & 0x34CEL) ^ 65535UL) <= 0x75L), l_57))) >= g_36.f0)) {
        if (g_36.f0)
          break;
      } else {
        if (l_61)
          break;
        (*g_62) = &g_56[0];
      }
      for (p_10 = 15; (p_10 >= 15); --p_10) {
        uint8_t *const *const l_66 = &l_58;
        uint8_t *const *l_68 = (void *)0;
        l_68 = l_66;
      }
    } else {
      int32_t l_69 = 4L;
      for (g_35.f1 = 0; g_35.f1 < 2; g_35.f1 += 1) {
        for (g_20.f4 = 0; g_20.f4 < 3; g_20.f4 += 1) {
          l_31[g_35.f1][g_20.f4] = &g_24;
        }
      }
      if (l_69)
        continue;
    }
  }
  l_72 &= (l_70, l_70.f2);
  return g_73;
}

int main(int argc, char *argv[]) {
  int i, j, k;
  int print_hash_value = 0;
  if (argc == 2 && strcmp(argv[1], "1") == 0)
    print_hash_value = 1;
  platform_main_begin();
  crc32_gentab();
  func_1();
  transparent_crc(g_15, "g_15", print_hash_value);
  transparent_crc(g_20.f0, "g_20.f0", print_hash_value);
  transparent_crc(g_20.f1, "g_20.f1", print_hash_value);
  transparent_crc(g_20.f2, "g_20.f2", print_hash_value);
  transparent_crc(g_20.f3, "g_20.f3", print_hash_value);
  transparent_crc(g_20.f4, "g_20.f4", print_hash_value);
  transparent_crc(g_24, "g_24", print_hash_value);
  for (i = 0; i < 2; i++) {
    for (j = 0; j < 3; j++) {
      transparent_crc(g_28[i][j], "g_28[i][j]", print_hash_value);
      if (print_hash_value)
        printf("index = [%d][%d]\n", i, j);
    }
  }
  transparent_crc(g_35.f0, "g_35.f0", print_hash_value);
  transparent_crc(g_36.f0, "g_36.f0", print_hash_value);
  for (i = 0; i < 4; i++) {
    transparent_crc(g_56[i], "g_56[i]", print_hash_value);
    if (print_hash_value)
      printf("index = [%d]\n", i);
  }
  transparent_crc(g_73.f0, "g_73.f0", print_hash_value);
  transparent_crc(g_77.f0, "g_77.f0", print_hash_value);
  transparent_crc(g_77.f1, "g_77.f1", print_hash_value);
  transparent_crc(g_77.f2, "g_77.f2", print_hash_value);
  transparent_crc(g_77.f3, "g_77.f3", print_hash_value);
  transparent_crc(g_88.f0, "g_88.f0", print_hash_value);
  transparent_crc(g_88.f1, "g_88.f1", print_hash_value);
  transparent_crc(g_88.f2, "g_88.f2", print_hash_value);
  transparent_crc(g_88.f3, "g_88.f3", print_hash_value);
  platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
  return 0;
}
