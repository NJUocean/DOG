    1|       |/* { dg-do run } */
    2|       |/* { dg-options "-O2 -fmodulo-sched -fmodulo-sched-allow-regmoves -funroll-loops
    3|       | * -fdump-rtl-sms --param sms-min-sc=1" } */
    4|       |/* This is the same test as loop-2e.c test.  It is related to a fix in
    5|       |   the generation of the prolog and epilog.  */
    6|       |
    7|       |extern void abort(void);
    8|       |
    9|      1|__attribute__((noinline)) void f(int *p, int **q) {
   10|      1|  int i;
   11|     41|  for (i = 0; i < 40; i++) {
   12|     40|    *q++ = &p[i];
   13|     40|  }
   14|      1|}
   15|       |
   16|      1|int main() {
   17|      1|  void *p;
   18|      1|  int *q[40];
   19|      1|  __SIZE_TYPE__ start;
   20|      1|
   21|      1|  /* Find the signed middle of the address space.  */
   22|      1|  if (sizeof(start) == sizeof(int))
   23|      0|    start = (__SIZE_TYPE__)__INT_MAX__;
   24|      1|  else if (sizeof(start) == sizeof(long))
   25|      1|    start = (__SIZE_TYPE__)__LONG_MAX__;
   26|      0|  else if (sizeof(start) == sizeof(long long))
   27|      0|    start = (__SIZE_TYPE__)__LONG_LONG_MAX__;
   28|      0|  else
   29|      0|    return 0;
   30|      1|
   31|      1|  /* Arbitrarily align the pointer.  */
   32|      1|  start &= -32;
   33|      1|
   34|      1|  /* Pretend that's good enough to start address arithmetic.  */
   35|      1|  p = (void *)start;
   36|      1|
   37|      1|  /* Verify that GIV replacement computes the correct results.  */
   38|      1|  q[39] = 0;
   39|      1|  f(p, q);
   40|      1|  if (q[39] != (int *)p + 39)
   41|      0|    abort();
   42|      1|
   43|      1|  return 0;
   44|      1|}

