    1|       |/* PR target/17377
    2|       |   Bug in code emitted by "return" pattern on CRIS: missing pop of
    3|       |   forced return address on stack.  */
    4|       |/* { dg-require-effective-target return_address } */
    5|       |int calls = 0;
    6|       |
    7|       |void *f(int) __attribute__((__noinline__));
    8|      5|void *f(int i) {
    9|      5|  /* The code does a little brittle song and dance to trig the "return"
   10|      5|     pattern instead of the function epilogue.  This must still be a
   11|      5|     leaf function for the bug to be exposed.  */
   12|      5|
   13|      5|  if (calls++ == 0)
   14|      1|    return __builtin_return_address(0);
   15|      4|
   16|      4|  switch (i) {
   17|      1|  case 1:
   18|      1|    return f;
   19|      1|  case 0:
   20|      1|    return __builtin_return_address(0);
   21|      2|  }
   22|      2|  return 0;
   23|      2|}
   24|       |
   25|       |int x;
   26|       |
   27|       |void *y(int i) __attribute__((__noinline__, __noclone__));
   28|      5|void *y(int i) {
   29|      5|  x = 0;
   30|      5|
   31|      5|  /* This must not be a sibling call: the return address must appear
   32|      5|     constant for different calls to this function.  Postincrementing x
   33|      5|     catches otherwise unidentified multiple returns (e.g. through the
   34|      5|     return-address register and then this epilogue popping the address
   35|      5|     stored on stack in "f").  */
   36|      5|  return (char *)f(i) + x++;
   37|      5|}
   38|       |
   39|      1|int main(void) {
   40|      1|  void *v = y(4);
   41|      1|  if (y(1) != f
   42|      1|      /* Can't reasonably check the validity of the return address
   43|      1|         above, but it's not that important: the test-case will probably
   44|      1|         crash on the first call to f with the bug present, or it will
   45|      1|         run wild including returning early (in y or here), so we also
   46|      1|         try and check the number of calls.  */
   47|      1|      || y(0) != v || y(3) != 0 || y(-1) != 0 || calls != 5)
   48|      0|    abort();
   49|      1|  exit(0);
   50|      1|}

