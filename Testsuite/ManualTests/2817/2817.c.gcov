        -:    0:Source:2817.c
        -:    0:Graph:2817.gcno
        -:    0:Data:2817.gcda
        -:    0:Runs:1
        -:    1:/* PR target/17377
        -:    2:   Bug in code emitted by "return" pattern on CRIS: missing pop of
        -:    3:   forced return address on stack.  */
        -:    4:/* { dg-require-effective-target return_address } */
        -:    5:int calls = 0;
        -:    6:
        -:    7:void *f(int) __attribute__((__noinline__));
        5:    8:void *f(int i) {
        -:    9:  /* The code does a little brittle song and dance to trig the "return"
        -:   10:     pattern instead of the function epilogue.  This must still be a
        -:   11:     leaf function for the bug to be exposed.  */
        -:   12:
        5:   13:  if (calls++ == 0)
        1:   14:    return __builtin_return_address(0);
        -:   15:
        4:   16:  switch (i) {
        1:   17:  case 1:
        1:   18:    return f;
        1:   19:  case 0:
        1:   20:    return __builtin_return_address(0);
        -:   21:  }
        2:   22:  return 0;
        -:   23:}
        -:   24:
        -:   25:int x;
        -:   26:
        -:   27:void *y(int i) __attribute__((__noinline__, __noclone__));
        5:   28:void *y(int i) {
        5:   29:  x = 0;
        -:   30:
        -:   31:  /* This must not be a sibling call: the return address must appear
        -:   32:     constant for different calls to this function.  Postincrementing x
        -:   33:     catches otherwise unidentified multiple returns (e.g. through the
        -:   34:     return-address register and then this epilogue popping the address
        -:   35:     stored on stack in "f").  */
        5:   36:  return (char *)f(i) + x++;
        -:   37:}
        -:   38:
        1:   39:int main(void) {
        1:   40:  void *v = y(4);
        1:   41:  if (y(1) != f
        -:   42:      /* Can't reasonably check the validity of the return address
        -:   43:         above, but it's not that important: the test-case will probably
        -:   44:         crash on the first call to f with the bug present, or it will
        -:   45:         run wild including returning early (in y or here), so we also
        -:   46:         try and check the number of calls.  */
        1:   47:      || y(0) != v || y(3) != 0 || y(-1) != 0 || calls != 5)
    #####:   48:    abort();
        1:   49:  exit(0);
        -:   50:}
