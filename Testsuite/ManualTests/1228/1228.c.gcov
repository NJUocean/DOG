        -:    0:Source:1228.c
        -:    0:Graph:1228.gcno
        -:    0:Data:1228.gcda
        -:    0:Runs:1
        -:    1:/*
        -:    2: This test checks promotion of bitfields.  Bitfields should be promoted
        -:    3: very much like chars and shorts:
        -:    4:
        -:    5: Bitfields (signed or unsigned) should be promoted to signed int if their
        -:    6: value will fit in a signed int, otherwise to an unsigned int if their
        -:    7: value will fit in an unsigned int, otherwise we don't promote them (ANSI/ISO
        -:    8: does not specify the behavior of bitfields larger than an unsigned int).
        -:    9:
        -:   10: We test the behavior by subtracting two from the promoted value: this will
        -:   11: result in a negitive value for signed types, a positive value for unsigned
        -:   12: types.  This test (of course) assumes that the compiler is correctly
        -:   13: implementing signed and unsigned arithmetic.
        -:   14: */
        -:   15:
        -:   16:struct X {
        -:   17:  unsigned int u3 : 3;
        -:   18:  signed long int s31 : 31;
        -:   19:  signed long int s32 : 32;
        -:   20:  unsigned long int u31 : 31;
        -:   21:  unsigned long int u32 : 32;
        -:   22:  unsigned long long ull3 : 3;
        -:   23:  unsigned long long ull35 : 35;
        -:   24:  unsigned u15 : 15;
        -:   25:};
        -:   26:
        -:   27:struct X x;
        -:   28:
        1:   29:main() {
        1:   30:  if ((x.u3 - 2) >= 0) /* promoted value should be signed */
    #####:   31:    abort();
        -:   32:
        1:   33:  if ((x.s31 - 2) >= 0) /* promoted value should be signed */
    #####:   34:    abort();
        -:   35:
        1:   36:  if ((x.s32 - 2) >= 0) /* promoted value should be signed */
    #####:   37:    abort();
        -:   38:
        1:   39:  if ((x.u15 - 2) >= 0) /* promoted value should be signed */
    #####:   40:    abort();
        -:   41:
        -:   42:  /* Conditionalize check on whether integers are 4 bytes or larger, i.e.
        -:   43:     larger than a 31 bit bitfield.  */
        -:   44:  if (sizeof(int) >= 4) {
        1:   45:    if ((x.u31 - 2) >= 0) /* promoted value should be signed */
    #####:   46:      abort();
        -:   47:  } else {
        -:   48:    if ((x.u31 - 2) < 0) /* promoted value should be UNsigned */
        -:   49:      abort();
        -:   50:  }
        -:   51:
        -:   52:  if ((x.u32 - 2) < 0) /* promoted value should be UNsigned */
        -:   53:    abort();
        -:   54:
        1:   55:  if ((x.ull3 - 2) >= 0) /* promoted value should be signed */
    #####:   56:    abort();
        -:   57:
        -:   58:  if ((x.ull35 - 2) < 0) /* promoted value should be UNsigned */
        -:   59:    abort();
        -:   60:
        1:   61:  exit(0);
        -:   62:}
