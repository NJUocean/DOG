    1|       |/* Bad PTA results (incorrect store handling) was causing us to delete
    2|       | *na = 0 store.  */
    3|       |
    4|       |typedef struct E {
    5|       |  int p;
    6|       |  struct E *n;
    7|       |} * EP;
    8|       |
    9|       |typedef struct C {
   10|       |  EP x;
   11|       |  short cn, cp;
   12|       |} * CP;
   13|       |
   14|      1|__attribute__((noinline)) CP foo(CP h, EP x) {
   15|      1|  EP pl = 0, *pa = &pl;
   16|      1|  EP nl = 0, *na = &nl;
   17|      1|  EP n;
   18|      1|
   19|      3|  while (x) {
   20|      2|    n = x->n;
   21|      2|    if ((x->p & 1) == 1) {
   22|      1|      h->cp++;
   23|      1|      *pa = x;
   24|      1|      pa = &((*pa)->n);
   25|      1|    } else {
   26|      1|      h->cn++;
   27|      1|      *na = x;
   28|      1|      na = &((*na)->n);
   29|      1|    }
   30|      2|    x = n;
   31|      2|  }
   32|      1|  *pa = nl;
   33|      1|  *na = 0;
   34|      1|  h->x = pl;
   35|      1|  return h;
   36|      1|}
   37|       |
   38|      1|int main(void) {
   39|      1|  struct C c = {0, 0, 0};
   40|      1|  struct E e[2] = {{0, &e[1]}, {1, 0}};
   41|      1|  EP p;
   42|      1|
   43|      1|  foo(&c, &e[0]);
   44|      1|  if (c.cn != 1 || c.cp != 1)
   45|      0|    __builtin_abort();
   46|      1|  if (c.x != &e[1])
   47|      0|    __builtin_abort();
   48|      1|  if (e[1].n != &e[0])
   49|      0|    __builtin_abort();
   50|      1|  if (e[0].n)
   51|      0|    __builtin_abort();
   52|      1|  return 0;
   53|      1|}

