        -:    0:Source:1943.c
        -:    0:Graph:1943.gcno
        -:    0:Data:1943.gcda
        -:    0:Runs:1
        -:    1:/* Check that certain subnormal numbers (formerly known as denormalized
        -:    2:   numbers) are rounded to within 0.5 ulp.  PR other/14354.  */
        -:    3:
        -:    4:/* This test requires that float and unsigned int are the same size and
        -:    5:   that the sign-bit of the float is at MSB of the unsigned int.  */
        -:    6:
        -:    7:#if __INT_MAX__ != 2147483647L
        -:    8:int main() { exit(0); }
        -:    9:#else
        -:   10:
        -:   11:union uf {
        -:   12:  unsigned int u;
        -:   13:  float f;
        -:   14:};
        -:   15:
       12:   16:static float u2f(unsigned int v) {
        -:   17:  union uf u;
       12:   18:  u.u = v;
       12:   19:  return u.f;
        -:   20:}
        -:   21:
        6:   22:static unsigned int f2u(float v) {
        -:   23:  union uf u;
        6:   24:  u.f = v;
        6:   25:  return u.u;
        -:   26:}
        -:   27:
        -:   28:int ok = 1;
        -:   29:
        6:   30:static void tstmul(unsigned int ux, unsigned int uy, unsigned int ur) {
        6:   31:  float x = u2f(ux);
        6:   32:  float y = u2f(uy);
        -:   33:
        6:   34:  if (f2u(x * y) != ur)
        -:   35:    /* Set a variable rather than aborting here, to simplify tracing when
        -:   36:       several computations are wrong.  */
    #####:   37:    ok = 0;
        6:   38:}
        -:   39:
        -:   40:/* We don't want to make this const and static, or else we risk inlining
        -:   41:   causing the test to fold as constants at compile-time.  */
        -:   42:struct {
        -:   43:  unsigned int p1, p2, res;
        -:   44:} expected[] = {{0xfff, 0x3f800400, 0xfff},
        -:   45:                {0xf, 0x3fc88888, 0x17},
        -:   46:                {0xf, 0x3f844444, 0xf}};
        -:   47:
        1:   48:int main() {
        -:   49:  unsigned int i;
        -:   50:
        4:   51:  for (i = 0; i < sizeof(expected) / sizeof(expected[0]); i++) {
        3:   52:    tstmul(expected[i].p1, expected[i].p2, expected[i].res);
        3:   53:    tstmul(expected[i].p2, expected[i].p1, expected[i].res);
        -:   54:  }
        -:   55:
        1:   56:  if (!ok)
    #####:   57:    abort();
        -:   58:
        1:   59:  exit(0);
        -:   60:}
        -:   61:#endif
