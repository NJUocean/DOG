        -:    0:Source:2016.c
        -:    0:Graph:2016.gcno
        -:    0:Data:2016.gcda
        -:    0:Runs:1
        -:    1:/* { dg-do compile } */
        -:    2:/* { dg-do run } */
        -:    3:/* { dg-options "-O2 -funroll-loops --param max-unroll-times=8
        -:    4: * -fpredictive-commoning -fdump-tree-pcom-details -fno-tree-pre" } */
        -:    5:
        -:    6:void abort(void);
        -:    7:
        -:    8:unsigned fib[1000];
        -:    9:
        1:   10:__attribute__((noinline)) void count_fib(void) {
        -:   11:  int i;
        -:   12:
        1:   13:  fib[0] = 0;
        1:   14:  fib[1] = 1;
      999:   15:  for (i = 2; i < 1000; i++)
      998:   16:    fib[i] = (fib[i - 1] + fib[i - 2]) & 0xffff;
        1:   17:}
        -:   18:
        -:   19:unsigned avg[1000];
        -:   20:
        1:   21:__attribute__((noinline)) void count_averages(int n) {
        -:   22:  int i;
        -:   23:
      999:   24:  for (i = 1; i < n; i++)
      998:   25:    avg[i] = (((unsigned long)fib[i - 1] + fib[i] + fib[i + 1]) / 3) & 0xffff;
        1:   26:}
        -:   27:
        1:   28:int main(void) {
        1:   29:  count_fib();
        1:   30:  count_averages(999);
        -:   31:
        1:   32:  if (fib[19] != 4181 || avg[19] != 4510)
    #####:   33:    abort();
        -:   34:
        1:   35:  if (fib[999] != 162 || avg[998] != 21953)
    #####:   36:    abort();
        -:   37:
        1:   38:  return 0;
        -:   39:}
        -:   40:
        -:   41:/* Verify that both loops were transformed and unrolled.  */
        -:   42:/* { dg-final { scan-tree-dump-times "Unrolling 2 times." 2 "pcom"} } */
        -:   43:
        -:   44:/* Also check that we undid the transformation previously made by PRE.
        -:   45:   ???  PRE now does the predictive commoning in count_averages.  */
        -:   46:/* dg-final { scan-tree-dump-times "looparound ref" 1 "pcom" } */
