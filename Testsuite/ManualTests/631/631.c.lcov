    1|       |/* Limit this to known non-strict alignment targets.  */
    2|       |/* { dg-do run { target { i?86-*-linux* x86_64-*-linux* } } } */
    3|       |/* { dg-options "-fsanitize=alignment -Wno-address-of-packed-member" } */
    4|       |
    5|       |struct S {
    6|       |  int a;
    7|       |  char b;
    8|       |  long long c;
    9|       |  short d[10];
   10|       |};
   11|       |struct T {
   12|       |  char a;
   13|       |  long long b;
   14|       |};
   15|       |struct U {
   16|       |  char a;
   17|       |  int b;
   18|       |  int c;
   19|       |  long long d;
   20|       |  struct S e;
   21|       |  struct T f;
   22|       |} __attribute__((packed));
   23|       |struct V {
   24|       |  long long a;
   25|       |  struct S b;
   26|       |  struct T c;
   27|       |  struct U u;
   28|       |} v;
   29|       |
   30|       |__attribute__((noinline, noclone)) void f1(int *p, int *q, char *r,
   31|      1|                                           long long *s) {
   32|      1|  *p = *q + *r + *s;
   33|      1|}
   34|       |
   35|      1|__attribute__((noinline, noclone)) int f2(struct S *p) { return p->a; }
   36|       |
   37|      1|__attribute__((noinline, noclone)) long long f3(struct S *p, int i) {
   38|      1|  return p->c + p->d[1] + p->d[i];
   39|      1|}
   40|       |
   41|      1|__attribute__((noinline, noclone)) long long f4(long long *p) { return *p; }
   42|       |
   43|      1|int main() {
   44|      1|  f1(&v.u.b, &v.u.c, &v.u.a, &v.u.d);
   45|      1|  if (f2(&v.u.e) + f3(&v.u.e, 4) + f4(&v.u.f.b) != 0)
   46|      0|    __builtin_abort();
   47|      1|  return 0;
   48|      1|}
   49|       |
   50|       |/* { dg-output "\.c:(14|15):\[0-9]*: \[^\n\r]*load of misaligned address
   51|       | * 0x\[0-9a-fA-F]* for type 'int', which requires 4 byte alignment.*" } */
   52|       |/* { dg-output "\.c:16:\[0-9]*: \[^\n\r]*load of misaligned address
   53|       | * 0x\[0-9a-fA-F]* for type 'long long int', which requires \[48] byte
   54|       | * alignment.*" } */
   55|       |/* { dg-output "\.c:(13|16):\[0-9]*: \[^\n\r]*store to misaligned address
   56|       | * 0x\[0-9a-fA-F]* for type 'int', which requires 4 byte alignment.*" } */
   57|       |/* { dg-output "\.c:23:\[0-9]*: \[^\n\r]*member access within misaligned address
   58|       | * 0x\[0-9a-fA-F]* for type 'struct S', which requires \[48] byte alignment.*" }
   59|       | */
   60|       |/* { dg-output "\.c:(29|30):\[0-9]*: \[^\n\r]*member access within misaligned
   61|       | * address 0x\[0-9a-fA-F]* for type 'struct S', which requires \[48] byte
   62|       | * alignment.*" } */
   63|       |/* { dg-output "\.c:30:\[0-9]*: \[^\n\r]*member access within misaligned address
   64|       | * 0x\[0-9a-fA-F]* for type 'struct S', which requires \[48] byte alignment.*" }
   65|       | */
   66|       |/* { dg-output "\.c:31:\[0-9]*: \[^\n\r]*member access within misaligned address
   67|       | * 0x\[0-9a-fA-F]* for type 'struct S', which requires \[48] byte alignment.*" }
   68|       | */
   69|       |/* { dg-output "\.c:37:\[0-9]*: \[^\n\r]*load of misaligned address
   70|       | * 0x\[0-9a-fA-F]* for type 'long long int', which requires \[48] byte
   71|       | * alignment" } */

