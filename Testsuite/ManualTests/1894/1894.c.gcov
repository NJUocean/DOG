        -:    0:Source:1894.c
        -:    0:Graph:1894.gcno
        -:    0:Data:1894.gcda
        -:    0:Runs:1
        -:    1:/* { dg-do run } */
        -:    2:/* { dg-options "-O3 -ftree-loop-distribution -fdump-tree-ldist-details" } */
        -:    3:
        -:    4:extern void abort(void);
        -:    5:
        -:    6:int a[130], b[128], c[128];
        -:    7:
        1:    8:int __attribute__((noinline, noclone)) foo(int len, int x) {
        -:    9:  int i;
      128:   10:  for (i = 1; i <= len; ++i) {
      127:   11:    a[i] = a[i + 2] + 1;
      127:   12:    b[i] = 0;
      127:   13:    a[i + 1] = a[i] - 3;
      127:   14:    if (i < x)
       66:   15:      c[i] = a[i];
        -:   16:  }
        1:   17:  return i;
        -:   18:}
        -:   19:
        1:   20:int main() {
        -:   21:  int i;
      131:   22:  for (i = 0; i < 130; ++i)
      130:   23:    a[i] = i;
        1:   24:  foo(127, 67);
        1:   25:  if (a[0] != 0 || a[1] != 4 || a[127] != 130)
    #####:   26:    abort();
        1:   27:  return 0;
        -:   28:}
        -:   29:
        -:   30:/* Loop splitting splits the iteration space so we end up with two
        -:   31:   loops entering loop distribution.  Both should have the b[i] = 0
        -:   32:   part split out as memset.  */
        -:   33:/* { dg-final { scan-tree-dump-times "distributed: split to 1 loops and 1
        -:   34: * library calls" 2 "ldist" } } */
        -:   35:/* { dg-final { scan-tree-dump-times "generated memset zero" 2 "ldist" } } */
