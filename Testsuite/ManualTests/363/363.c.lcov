    1|       |/* Test for GNU extensions to compound literals */
    2|       |/* Origin: Jakub Jelinek <jakub@redhat.com> */
    3|       |/* { dg-do run } */
    4|       |/* { dg-options "-std=gnu89" } */
    5|       |
    6|       |extern void abort(void);
    7|       |extern void exit(int);
    8|       |
    9|       |struct A {
   10|       |  int i;
   11|       |  int j;
   12|       |  int k[4];
   13|       |};
   14|       |struct B {};
   15|       |struct C {
   16|       |  int i;
   17|       |};
   18|       |struct D {
   19|       |  int i;
   20|       |  struct C j;
   21|       |};
   22|       |
   23|       |/* As a GNU extension, we allow initialization of objects with static storage
   24|       |   duration by compound literals.  It is handled as if the object
   25|       |   was initialized only with the bracket enclosed list if compound literal's
   26|       |   and object types match.  If the object being initialized has array type
   27|       |   of unknown size, the size is determined by compound literal's initializer
   28|       |   list, not by size of the compound literal.  */
   29|       |
   30|       |struct A a = (struct A){.j = 6, .k[2] = 12};
   31|       |struct B b = (struct B){};
   32|       |int c[] = (int[]){[2] = 6, 7, 8};
   33|       |int d[] = (int[3]){1};
   34|       |int e[2] = (int[]){1, 2};
   35|       |int f[2] = (int[2]){1};
   36|       |struct C g[3] = {[2] = (struct C){13}, [1] = (const struct C){12}};
   37|       |struct D h = {.j = (struct C){15}, .i = 14};
   38|       |struct D i[2] = {[1].j = (const struct C){17}, [0] = {0, (struct C){16}}};
   39|       |struct C j[2][3] = {[0 ... 1] = {[0 ... 2] = (struct C){26}}};
   40|       |struct C k[3][2] = {[0 ... 2][0 ... 1] = (const struct C){27}};
   41|       |
   42|      1|int main(void) {
   43|      1|  if (a.i || a.j != 6 || a.k[0] || a.k[1] || a.k[2] != 12 || a.k[3])
   44|      0|    abort();
   45|      1|  if (c[0] || c[1] || c[2] != 6 || c[3] != 7 || c[4] != 8)
   46|      0|    abort();
   47|      1|  if (sizeof(c) != 5 * sizeof(int))
   48|      0|    abort();
   49|      1|  if (d[0] != 1 || d[1] || d[2])
   50|      0|    abort();
   51|      1|  if (sizeof(d) != 3 * sizeof(int))
   52|      0|    abort();
   53|      1|  if (e[0] != 1 || e[1] != 2)
   54|      0|    abort();
   55|      1|  if (sizeof(e) != 2 * sizeof(int))
   56|      0|    abort();
   57|      1|  if (f[0] != 1 || f[1])
   58|      0|    abort();
   59|      1|  if (sizeof(f) != 2 * sizeof(int))
   60|      0|    abort();
   61|      1|  if (g[0].i || g[1].i != 12 || g[2].i != 13)
   62|      0|    abort();
   63|      1|  if (h.i != 14 || h.j.i != 15)
   64|      0|    abort();
   65|      1|  if (i[0].i || i[0].j.i != 16 || i[1].i || i[1].j.i != 17)
   66|      0|    abort();
   67|      1|  if (j[0][0].i != 26 || j[0][1].i != 26 || j[0][2].i != 26)
   68|      0|    abort();
   69|      1|  if (j[1][0].i != 26 || j[1][1].i != 26 || j[1][2].i != 26)
   70|      0|    abort();
   71|      1|  if (k[0][0].i != 27 || k[0][1].i != 27 || k[1][0].i != 27)
   72|      0|    abort();
   73|      1|  if (k[1][1].i != 27 || k[2][0].i != 27 || k[2][1].i != 27)
   74|      0|    abort();
   75|      1|  exit(0);
   76|      1|}

