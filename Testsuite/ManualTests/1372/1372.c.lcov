    1|       |int i;
    2|       |double d;
    3|       |
    4|       |/* Make sure we return a constant.  */
    5|       |float rootbeer[__builtin_types_compatible_p(int, typeof(i))];
    6|       |
    7|       |typedef enum { hot, dog, poo, bear } dingos;
    8|       |typedef enum { janette, laura, amanda } cranberry;
    9|       |
   10|       |typedef float same1;
   11|       |typedef float same2;
   12|       |
   13|       |int main(void);
   14|       |
   15|      1|int main(void) {
   16|      1|  /* Compatible types.  */
   17|      1|  if (!(__builtin_types_compatible_p(int, const int) &&
   18|      1|        __builtin_types_compatible_p(typeof(hot), int) &&
   19|      1|        __builtin_types_compatible_p(typeof(hot), typeof(laura)) &&
   20|      1|        __builtin_types_compatible_p(int[5], int[]) &&
   21|      1|        __builtin_types_compatible_p(same1, same2)))
   22|      0|    abort();
   23|      1|
   24|      1|  /* Incompatible types.  */
   25|      1|  if (__builtin_types_compatible_p(char *, int) ||
   26|      1|      __builtin_types_compatible_p(char *, const char *) ||
   27|      1|      __builtin_types_compatible_p(long double, double) ||
   28|      1|      __builtin_types_compatible_p(typeof(i), typeof(d)) ||
   29|      1|      __builtin_types_compatible_p(typeof(dingos), typeof(cranberry)) ||
   30|      1|      __builtin_types_compatible_p(char, int) ||
   31|      1|      __builtin_types_compatible_p(char *, char **))
   32|      0|    abort();
   33|      1|  exit(0);
   34|      1|}

