    1|       |/* This bug exists in gcc-2.95, egcs-1.1.2, gcc-2.7.2 and probably
    2|       |   every other version as well.  */
    3|       |
    4|       |typedef struct int3 {
    5|       |  int a, b, c;
    6|       |} int3;
    7|       |
    8|      1|int3 one(void) { return (int3){1, 1, 1}; }
    9|       |
   10|      1|int3 zero(void) { return (int3){0, 0, 0}; }
   11|       |
   12|      1|int main(void) {
   13|      1|  int3 a;
   14|      1|
   15|      1|  /* gcc allocates a temporary for the inner expression statement
   16|      1|     to store the return value of `one'.
   17|      1|
   18|      1|     gcc frees the temporaries for the inner expression statement.
   19|      1|
   20|      1|     gcc realloates the same temporary slot to store the return
   21|      1|     value of `zero'.
   22|      1|
   23|      1|     gcc expands the call to zero ahead of the expansion of the
   24|      1|     statement expressions.  The temporary gets the value of `zero'.
   25|      1|
   26|      1|     gcc expands statement expressions and the stale temporary is
   27|      1|     clobbered with the value of `one'.  The bad value is copied from
   28|      1|     the temporary into *&a.  */
   29|      1|
   30|      1|  *({
   31|      1|    ({
   32|      1|      one();
   33|      1|      &a;
   34|      1|    });
   35|      1|  }) = zero();
   36|      1|  if (a.a && a.b && a.c)
   37|      0|    abort();
   38|      1|  exit(0);
   39|      1|}

