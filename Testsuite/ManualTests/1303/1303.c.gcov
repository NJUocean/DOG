        -:    0:Source:1303.c
        -:    0:Graph:1303.gcno
        -:    0:Data:1303.gcda
        -:    0:Runs:1
        -:    1:/* &&foo should be hoisted, but on most targets, excess register pressure
        -:    2:   forces it to be rematerialized before "data != &&foo".  On targets that
        -:    3:   have a "branch if registers are equal" instruction, this leads to the
        -:    4:   branch having two LABEL_REFs: one for the branch target and one for
        -:    5:   &&foo.  When reloading &&foo into a register, reload would wrongly
        -:    6:   say that &&foo was the target of the branch, and the real target would
        -:    7:   then be removed as dead.  */
        -:    8:/* { dg-do link } */
        -:    9:/* { dg-require-effective-target label_values } */
        -:   10:#define NVARS 30
        -:   11:#define MULTI(X)                                                               \
        -:   12:  X(0), X(1), X(2), X(3), X(4), X(5), X(6), X(7), X(8), X(9), X(10), X(11),    \
        -:   13:      X(12), X(13), X(14), X(15), X(16), X(17), X(18), X(19), X(20), X(21),    \
        -:   14:      X(22), X(23), X(24), X(25), X(26), X(27), X(28), X(29)
        -:   15:
        -:   16:#define DECLARE(INDEX) i##INDEX = gv[INDEX]
        -:   17:#define COPY(INDEX) gv[INDEX] = i##INDEX
        -:   18:
        -:   19:volatile int gv[NVARS];
        -:   20:void *volatile data;
        -:   21:
        1:   22:int main(void) {
        -:   23:  __label__ foo;
        -:   24:
        1:   25:  if (gv[0] == 1)
    #####:   26:    goto foo;
        1:   27:  data = &&foo;
        -:   28:  do {
        1:   29:    int MULTI(DECLARE);
        1:   30:    MULTI(COPY);
        1:   31:    MULTI(COPY);
        1:   32:    MULTI(COPY);
        1:   33:    if (data != &&foo)
    #####:   34:      gv[0] = 1;
        -:   35:    else
        1:   36:      gv[1] = 2;
        1:   37:  } while (gv[0] > 0);
        1:   38:foo:
        1:   39:  return 0;
        -:   40:}
