        -:    0:Source:2828.c
        -:    0:Graph:2828.gcno
        -:    0:Data:2828.gcda
        -:    0:Runs:1
        -:    1:/* { dg-do assemble } */
        -:    2:/* { dg-options "-O3 -fomit-frame-pointer -funroll-loops -march=r2 -mcdx -w" }
        -:    3: */
        -:    4:
        -:    5:/* Based on gcc.c-torture/execute/20021120-1.c.
        -:    6:   This test used to result in assembler errors with R2 CDX because of
        -:    7:   a bug in regrename; it wasn't re-validating insns after renaming, so
        -:    8:   ldwm/stwm instructions with incorrect registers were being emitted.  */
        -:    9:
        -:   10:/* Macros to emit "L Nxx R" for each octal number xx between 000 and 037.  */
        -:   11:#define OP1(L, N, R, I, J) L N##I##J R
        -:   12:#define OP2(L, N, R, I)                                                        \
        -:   13:  OP1(L, N, R, 0, I), OP1(L, N, R, 1, I), OP1(L, N, R, 2, I), OP1(L, N, R, 3, I)
        -:   14:#define OP(L, N, R)                                                            \
        -:   15:  OP2(L, N, R, 0), OP2(L, N, R, 1), OP2(L, N, R, 2), OP2(L, N, R, 3),          \
        -:   16:      OP2(L, N, R, 4), OP2(L, N, R, 5), OP2(L, N, R, 6), OP2(L, N, R, 7)
        -:   17:
        -:   18:/* Declare 32 unique variables with prefix N.  */
        -:   19:#define DECLARE(N) OP(, N, )
        -:   20:
        -:   21:/* Copy 32 variables with prefix N from the array at ADDR.
        -:   22:   Leave ADDR pointing to the end of the array.  */
        -:   23:#define COPYIN(N, ADDR) OP(, N, = *(ADDR++))
        -:   24:
        -:   25:/* Likewise, but copy the other way.  */
        -:   26:#define COPYOUT(N, ADDR) OP(*(ADDR++) =, N, )
        -:   27:
        -:   28:/* Add the contents of the array at ADDR to 32 variables with prefix N.
        -:   29:   Leave ADDR pointing to the end of the array.  */
        -:   30:#define ADD(N, ADDR) OP(, N, += *(ADDR++))
        -:   31:
        -:   32:volatile double gd[32];
        -:   33:volatile float gf[32];
        -:   34:
        1:   35:void foo(int n) {
        -:   36:  double DECLARE(d);
        -:   37:  float DECLARE(f);
        -:   38:  volatile double *pd;
        -:   39:  volatile float *pf;
        -:   40:  int i;
        -:   41:
        1:   42:  pd = gd;
        1:   43:  COPYIN(d, pd);
        2:   44:  for (i = 0; i < n; i++) {
        1:   45:    pf = gf;
        1:   46:    COPYIN(f, pf);
        1:   47:    pd = gd;
        1:   48:    ADD(d, pd);
        1:   49:    pd = gd;
        1:   50:    ADD(d, pd);
        1:   51:    pd = gd;
        1:   52:    ADD(d, pd);
        1:   53:    pf = gf;
        1:   54:    COPYOUT(f, pf);
        -:   55:  }
        1:   56:  pd = gd;
        1:   57:  COPYOUT(d, pd);
        1:   58:}
        -:   59:
        1:   60:int main() {
        -:   61:  int i;
        -:   62:
       33:   63:  for (i = 0; i < 32; i++)
       32:   64:    gd[i] = i, gf[i] = i;
        1:   65:  foo(1);
       33:   66:  for (i = 0; i < 32; i++)
       32:   67:    if (gd[i] != i * 4 || gf[i] != i)
    #####:   68:      abort();
        1:   69:  exit(0);
        -:   70:}
