    1|       |/* { dg-do assemble } */
    2|       |/* { dg-options "-O3 -fomit-frame-pointer -funroll-loops -march=r2 -mcdx -w" }
    3|       | */
    4|       |
    5|       |/* Based on gcc.c-torture/execute/20021120-1.c.
    6|       |   This test used to result in assembler errors with R2 CDX because of
    7|       |   a bug in regrename; it wasn't re-validating insns after renaming, so
    8|       |   ldwm/stwm instructions with incorrect registers were being emitted.  */
    9|       |
   10|       |/* Macros to emit "L Nxx R" for each octal number xx between 000 and 037.  */
   11|    224|#define OP1(L, N, R, I, J) L N##I##J R
   12|       |#define OP2(L, N, R, I)                                                        \
   13|     56|  OP1(L, N, R, 0, I), OP1(L, N, R, 1, I), OP1(L, N, R, 2, I), OP1(L, N, R, 3, I)
   14|       |#define OP(L, N, R)                                                            \
   15|      7|  OP2(L, N, R, 0), OP2(L, N, R, 1), OP2(L, N, R, 2), OP2(L, N, R, 3),          \
   16|      7|      OP2(L, N, R, 4), OP2(L, N, R, 5), OP2(L, N, R, 6), OP2(L, N, R, 7)
   17|       |
   18|       |/* Declare 32 unique variables with prefix N.  */
   19|       |#define DECLARE(N) OP(, N, )
   20|       |
   21|       |/* Copy 32 variables with prefix N from the array at ADDR.
   22|       |   Leave ADDR pointing to the end of the array.  */
   23|      2|#define COPYIN(N, ADDR) OP(, N, = *(ADDR++))
   24|       |
   25|       |/* Likewise, but copy the other way.  */
   26|      2|#define COPYOUT(N, ADDR) OP(*(ADDR++) =, N, )
   27|       |
   28|       |/* Add the contents of the array at ADDR to 32 variables with prefix N.
   29|       |   Leave ADDR pointing to the end of the array.  */
   30|      3|#define ADD(N, ADDR) OP(, N, += *(ADDR++))
   31|       |
   32|       |volatile double gd[32];
   33|       |volatile float gf[32];
   34|       |
   35|      1|void foo(int n) {
   36|      1|  double DECLARE(d);
   37|      1|  float DECLARE(f);
   38|      1|  volatile double *pd;
   39|      1|  volatile float *pf;
   40|      1|  int i;
   41|      1|
   42|      1|  pd = gd;
   43|      1|  COPYIN(d, pd);
   44|      2|  for (i = 0; i < n; i++) {
   45|      1|    pf = gf;
   46|      1|    COPYIN(f, pf);
   47|      1|    pd = gd;
   48|      1|    ADD(d, pd);
   49|      1|    pd = gd;
   50|      1|    ADD(d, pd);
   51|      1|    pd = gd;
   52|      1|    ADD(d, pd);
   53|      1|    pf = gf;
   54|      1|    COPYOUT(f, pf);
   55|      1|  }
   56|      1|  pd = gd;
   57|      1|  COPYOUT(d, pd);
   58|      1|}
   59|       |
   60|      1|int main() {
   61|      1|  int i;
   62|      1|
   63|     33|  for (i = 0; i < 32; i++)
   64|     32|    gd[i] = i, gf[i] = i;
   65|      1|  foo(1);
   66|     33|  for (i = 0; i < 32; i++)
   67|     32|    if (gd[i] != i * 4 || gf[i] != i)
   68|      0|      abort();
   69|      1|  exit(0);
   70|      1|}

