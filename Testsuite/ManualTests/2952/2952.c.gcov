        -:    0:Source:2952.c
        -:    0:Graph:2952.gcno
        -:    0:Data:2952.gcda
        -:    0:Runs:1
        -:    1:/* The z13 stpcpy implementation plays some alignment tricks for good
        -:    2:   performance.  This test tries to make sure it works correctly and
        -:    3:   does not access bytes beyond the source and destination
        -:    4:   strings.  */
        -:    5:
        -:    6:/* { dg-do run } */
        -:    7:/* { dg-require-effective-target s390_vx } */
        -:    8:/* { dg-options "-O3 -mzarch -march=z13" } */
        -:    9:
        -:   10:#include <stdio.h>
        -:   11:#include <sys/mman.h>
        -:   12:
        -:   13:#define PAGE_SIZE 4096
        -:   14:
        -:   15:struct {
        -:   16:  char unused[PAGE_SIZE - 32];
        -:   17:  char m32[15]; /* page bndry - 32 */
        -:   18:  char m17[1];
        -:   19:  char m16[1];
        -:   20:  char m15[14];
        -:   21:  char m1[1];
        -:   22:  char next_page[PAGE_SIZE];
        -:   23:} s, d __attribute__((aligned(PAGE_SIZE)));
        -:   24:
      250:   25:char *__attribute__((noinline)) my_stpcpy(char *dest, const char *src) {
      250:   26:  return __builtin_stpcpy(dest, src);
        -:   27:}
        -:   28:
      250:   29:void __attribute__((noinline)) check(char *dest, char *src, size_t len) {
        -:   30:  char *result;
        -:   31:
      250:   32:  result = my_stpcpy(dest, src);
      250:   33:  if (result != dest + len)
    #####:   34:    __builtin_abort();
      250:   35:  if (__builtin_memcmp(src, dest, len) != 0)
    #####:   36:    __builtin_abort();
      250:   37:}
        -:   38:
        1:   39:int main() {
        1:   40:  char *src[5] = {s.m32, s.m17, s.m16, s.m15, s.m1};
        1:   41:  char *dst[5] = {d.m32, d.m17, d.m16, d.m15, d.m1};
        1:   42:  int len[8] = {33, 32, 31, 17, 16, 15, 1, 0};
        -:   43:  int i, j, k;
        -:   44:  char backup;
        -:   45:
     8193:   46:  for (i = 0; i < sizeof(s); i++)
     8192:   47:    ((char *)&s)[i] = i % 26 + 97;
        -:   48:
        6:   49:  for (i = 0; i < 5; i++)
       30:   50:    for (j = 0; j < 5; j++)
      225:   51:      for (k = 0; k < 8; k++) {
      200:   52:        backup = src[j][len[k]];
      200:   53:        src[j][len[k]] = 0;
      200:   54:        __builtin_memset(&d, 0, sizeof(d));
      200:   55:        check(dst[i], src[j], len[k]);
      200:   56:        src[j][len[k]] = backup;
        -:   57:      }
        -:   58:
        -:   59:  /* Make all source strings end before the page boundary.  */
        1:   60:  backup = s.m1[0];
        1:   61:  s.m1[0] = 0;
        -:   62:
        1:   63:  if (mprotect(&s.next_page, PAGE_SIZE, PROT_NONE) == -1)
    #####:   64:    perror("mprotect src");
        -:   65:
        6:   66:  for (i = 0; i < 5; i++)
       30:   67:    for (j = 0; j < 5; j++)
       25:   68:      check(dst[i], src[j],
       25:   69:            PAGE_SIZE - ((unsigned long)src[j] & ((1UL << 12) - 1)) - 1);
        -:   70:
        1:   71:  if (mprotect(&s.next_page, PAGE_SIZE, PROT_READ | PROT_WRITE) == -1)
    #####:   72:    perror("mprotect src");
        -:   73:
        1:   74:  s.m1[0] = backup;
        -:   75:
        1:   76:  if (mprotect(&d.next_page, PAGE_SIZE, PROT_NONE) == -1)
    #####:   77:    perror("mprotect dst");
        -:   78:
        6:   79:  for (i = 0; i < 5; i++)
       30:   80:    for (j = 0; j < 5; j++) {
       25:   81:      int len = PAGE_SIZE - ((unsigned long)dst[i] & ((1UL << 12) - 1)) - 1;
       25:   82:      char backup = src[j][len];
        -:   83:
       25:   84:      src[j][len] = 0;
       25:   85:      __builtin_memset(&d, 0, (unsigned long)&d.next_page - (unsigned long)&d);
       25:   86:      check(dst[i], src[j], len);
       25:   87:      src[j][len] = backup;
        -:   88:    }
        -:   89:
        1:   90:  return 0;
        -:   91:}
