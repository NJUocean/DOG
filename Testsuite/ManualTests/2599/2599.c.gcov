        -:    0:Source:2599.c
        -:    0:Graph:2599.gcno
        -:    0:Data:2599.gcda
        -:    0:Runs:1
        -:    1:/* PR optimization/9888 */
        -:    2:/* Originator: Jim Bray <jb@as220.org> */
        -:    3:/* { dg-do run } */
        -:    4:/* { dg-require-effective-target ia32 } */
        -:    5:/* { dg-options "-mtune=k6 -Os" } */
        -:    6:
        -:    7:enum reload_type {
        -:    8:  RELOAD_FOR_INPUT,
        -:    9:  RELOAD_FOR_OUTPUT,
        -:   10:  RELOAD_FOR_INSN,
        -:   11:  RELOAD_FOR_INPUT_ADDRESS,
        -:   12:  RELOAD_FOR_INPADDR_ADDRESS,
        -:   13:  RELOAD_FOR_OUTPUT_ADDRESS,
        -:   14:  RELOAD_FOR_OUTADDR_ADDRESS,
        -:   15:  RELOAD_FOR_OPERAND_ADDRESS,
        -:   16:  RELOAD_FOR_OPADDR_ADDR,
        -:   17:  RELOAD_OTHER,
        -:   18:  RELOAD_FOR_OTHER_ADDRESS
        -:   19:};
        -:   20:
        -:   21:#define FOO_SIZE 3
        -:   22:
        -:   23:/* My results, varying with FOO_SIZE:
        -:   24:   30: asm error "value of ..fff77 too large:
        -:   25:   3 to 29: ....ff7d...
        -:   26:   1 to 2: no error.  */
        -:   27:
        -:   28:struct reload {
        -:   29:  int foo[FOO_SIZE];
        -:   30:  int opnum;
        -:   31:  enum reload_type when_needed;
        -:   32:  unsigned int optional : 1;
        -:   33:  unsigned int secondary_p : 1;
        -:   34:};
        -:   35:
        -:   36:#define N_RELOADS 2
        -:   37:
        -:   38:struct reload rld[N_RELOADS];
        -:   39:int n_reloads = N_RELOADS;
        -:   40:
        1:   41:int main(void) {
        -:   42:  int i;
        -:   43:
        -:   44:  enum reload_type operand_type[1];
        -:   45:
        -:   46:  enum reload_type address_type[1];
        -:   47:
        -:   48:  int operand_reloadnum[1];
        -:   49:  int goal_alternative_matches[1];
        -:   50:
        3:   51:  for (i = 0; i < n_reloads; i++) {
       2*:   52:    if (rld[i].secondary_p && rld[i].when_needed == operand_type[rld[i].opnum])
    #####:   53:      rld[i].when_needed = address_type[rld[i].opnum];
        -:   54:
        2:   55:    if ((rld[i].when_needed == RELOAD_FOR_INPUT_ADDRESS ||
        2:   56:         rld[i].when_needed == RELOAD_FOR_OUTPUT_ADDRESS ||
        2:   57:         rld[i].when_needed == RELOAD_FOR_INPADDR_ADDRESS ||
       2*:   58:         rld[i].when_needed == RELOAD_FOR_OUTADDR_ADDRESS) &&
    #####:   59:        (operand_reloadnum[rld[i].opnum] < 0 ||
    #####:   60:         rld[operand_reloadnum[rld[i].opnum]].optional)) {
        -:   61:
    #####:   62:      if (rld[i].when_needed == RELOAD_FOR_INPADDR_ADDRESS ||
    #####:   63:          rld[i].when_needed == RELOAD_FOR_OUTADDR_ADDRESS)
    #####:   64:        rld[i].when_needed = RELOAD_FOR_OPADDR_ADDR;
        -:   65:      else
    #####:   66:        rld[i].when_needed = RELOAD_FOR_OPERAND_ADDRESS;
        -:   67:    }
        -:   68:
        2:   69:    if ((rld[i].when_needed == RELOAD_FOR_INPUT_ADDRESS ||
       2*:   70:         rld[i].when_needed == RELOAD_FOR_INPADDR_ADDRESS) &&
    #####:   71:        operand_reloadnum[rld[i].opnum] >= 0 &&
    #####:   72:        (rld[operand_reloadnum[rld[i].opnum]].when_needed == RELOAD_OTHER))
    #####:   73:      rld[i].when_needed = RELOAD_FOR_OTHER_ADDRESS;
        -:   74:
        2:   75:    if (goal_alternative_matches[rld[i].opnum] >= 0)
        2:   76:      rld[i].opnum = goal_alternative_matches[rld[i].opnum];
        -:   77:  }
        -:   78:
        1:   79:  return 0;
        -:   80:}
