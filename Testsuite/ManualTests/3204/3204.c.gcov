        -:    0:Source:3204.c
        -:    0:Graph:3204.gcno
        -:    0:Data:3204.gcda
        -:    0:Runs:1
        -:    1:// Copyright 2010 The Go Authors.  All rights reserved.
        -:    2:// Use of this source code is governed by a BSD-style
        -:    3:// license that can be found in the LICENSE file.
        -:    4:
        -:    5:// gcc '-std=c99' cmplxdivide.c && a.out >cmplxdivide1.go
        -:    6:
        -:    7:#include <complex.h>
        -:    8:#include <math.h>
        -:    9:#include <stdio.h>
        -:   10:#include <string.h>
        -:   11:
        -:   12:#define nelem(x) (sizeof(x) / sizeof((x)[0]))
        -:   13:
        -:   14:double f[] = {
        -:   15:    0, 1, -1, 2, NAN, INFINITY, -INFINITY,
        -:   16:};
        -:   17:
    14406:   18:char *fmt(double g) {
        -:   19:  static char buf[10][30];
        -:   20:  static int n;
        -:   21:  char *p;
        -:   22:
    14406:   23:  p = buf[n++];
    14406:   24:  if (n == 10)
     1440:   25:    n = 0;
    14406:   26:  sprintf(p, "%g", g);
    14406:   27:  if (strcmp(p, "-0") == 0)
      368:   28:    strcpy(p, "negzero");
    14406:   29:  return p;
        -:   30:}
        -:   31:
     2401:   32:int iscnan(double complex d) {
     3724:   33:  return !isinf(creal(d)) && !isinf(cimag(d)) &&
     1323:   34:         (isnan(creal(d)) || isnan(cimag(d)));
        -:   35:}
        -:   36:
        -:   37:double complex zero; // attempt to hide zero division from gcc
        -:   38:
        1:   39:int main(void) {
        -:   40:  int i, j, k, l;
        -:   41:  double complex n, d, q;
        -:   42:
        1:   43:  printf("// skip\n");
        1:   44:  printf("// # generated by cmplxdivide.c\n");
        1:   45:  printf("\n");
        1:   46:  printf("package main\n");
        1:   47:  printf("var tests = []Test{\n");
        8:   48:  for (i = 0; i < nelem(f); i++)
       56:   49:    for (j = 0; j < nelem(f); j++)
      392:   50:      for (k = 0; k < nelem(f); k++)
     2744:   51:        for (l = 0; l < nelem(f); l++) {
     2401:   52:          n = f[i] + f[j] * I;
     2401:   53:          d = f[k] + f[l] * I;
     2401:   54:          q = n / d;
        -:   55:
        -:   56:          // BUG FIX.
        -:   57:          // Gcc gets the wrong answer for NaN/0 unless both sides are NaN.
        -:   58:          // That is, it treats (NaN+NaN*I)/0 = NaN+NaN*I (a complex NaN)
        -:   59:          // but it then computes (1+NaN*I)/0 = Inf+NaN*I (a complex infinity).
        -:   60:          // Since both numerators are complex NaNs, it seems that the
        -:   61:          // results should agree in kind.  Override the gcc computation in this
        -:   62:          // case.
     2401:   63:          if (iscnan(n) && d == 0)
       11:   64:            q = (NAN + NAN * I) / zero;
        -:   65:
     2401:   66:          printf("\tTest{complex(%s, %s), complex(%s, %s), complex(%s, %s)},\n",
        -:   67:                 fmt(creal(n)), fmt(cimag(n)), fmt(creal(d)), fmt(cimag(d)),
        -:   68:                 fmt(creal(q)), fmt(cimag(q)));
        -:   69:        }
        1:   70:  printf("}\n");
        1:   71:  return 0;
        -:   72:}
