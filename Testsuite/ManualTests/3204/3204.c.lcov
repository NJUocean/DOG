    1|       |// Copyright 2010 The Go Authors.  All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style
    3|       |// license that can be found in the LICENSE file.
    4|       |
    5|       |// gcc '-std=c99' cmplxdivide.c && a.out >cmplxdivide1.go
    6|       |
    7|       |#include <complex.h>
    8|       |#include <math.h>
    9|       |#include <stdio.h>
   10|       |#include <string.h>
   11|       |
   12|  3.20k|#define nelem(x) (sizeof(x) / sizeof((x)[0]))
   13|       |
   14|       |double f[] = {
   15|       |    0, 1, -1, 2, NAN, INFINITY, -INFINITY,
   16|       |};
   17|       |
   18|  14.4k|char *fmt(double g) {
   19|  14.4k|  static char buf[10][30];
   20|  14.4k|  static int n;
   21|  14.4k|  char *p;
   22|  14.4k|
   23|  14.4k|  p = buf[n++];
   24|  14.4k|  if (n == 10)
   25|  1.44k|    n = 0;
   26|  14.4k|  sprintf(p, "%g", g);
   27|  14.4k|  if (strcmp(p, "-0") == 0)
   28|    364|    strcpy(p, "negzero");
   29|  14.4k|  return p;
   30|  14.4k|}
   31|       |
   32|  2.40k|int iscnan(double complex d) {
   33|  2.40k|  return !isinf(creal(d)) && !isinf(cimag(d)) &&
   34|  2.40k|         (isnan(creal(d)) || isnan(cimag(d)));
   35|  2.40k|}
   36|       |
   37|       |double complex zero; // attempt to hide zero division from gcc
   38|       |
   39|      1|int main(void) {
   40|      1|  int i, j, k, l;
   41|      1|  double complex n, d, q;
   42|      1|
   43|      1|  printf("// skip\n");
   44|      1|  printf("// # generated by cmplxdivide.c\n");
   45|      1|  printf("\n");
   46|      1|  printf("package main\n");
   47|      1|  printf("var tests = []Test{\n");
   48|      8|  for (i = 0; i < nelem(f); i++)
   49|     56|    for (j = 0; j < nelem(f); j++)
   50|    392|      for (k = 0; k < nelem(f); k++)
   51|  2.74k|        for (l = 0; l < nelem(f); l++) {
   52|  2.40k|          n = f[i] + f[j] * I;
   53|  2.40k|          d = f[k] + f[l] * I;
   54|  2.40k|          q = n / d;
   55|  2.40k|
   56|  2.40k|          // BUG FIX.
   57|  2.40k|          // Gcc gets the wrong answer for NaN/0 unless both sides are NaN.
   58|  2.40k|          // That is, it treats (NaN+NaN*I)/0 = NaN+NaN*I (a complex NaN)
   59|  2.40k|          // but it then computes (1+NaN*I)/0 = Inf+NaN*I (a complex infinity).
   60|  2.40k|          // Since both numerators are complex NaNs, it seems that the
   61|  2.40k|          // results should agree in kind.  Override the gcc computation in this
   62|  2.40k|          // case.
   63|  2.40k|          if (iscnan(n) && d == 0)
   64|     11|            q = (NAN + NAN * I) / zero;
   65|  2.40k|
   66|  2.40k|          printf("\tTest{complex(%s, %s), complex(%s, %s), complex(%s, %s)},\n",
   67|  2.40k|                 fmt(creal(n)), fmt(cimag(n)), fmt(creal(d)), fmt(cimag(d)),
   68|  2.40k|                 fmt(creal(q)), fmt(cimag(q)));
   69|  2.40k|        }
   70|      1|  printf("}\n");
   71|      1|  return 0;
   72|      1|}

