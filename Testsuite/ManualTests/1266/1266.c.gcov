        -:    0:Source:1266.c
        -:    0:Graph:1266.gcno
        -:    0:Data:1266.gcda
        -:    0:Runs:1
        -:    1:/* Limit this to known non-strict alignment targets.  */
        -:    2:/* { dg-do run { target { i?86-*-linux* x86_64-*-linux* } } } */
        -:    3:/* { dg-options "-fsanitize=alignment" } */
        -:    4:
        -:    5:#define __round_mask(x, y) ((__typeof__(x))((y)-1))
        -:    6:#define round_up(x, y) ((((x)-1) | __round_mask(x, y)) + 1)
        -:    7:
        -:    8:struct test_struct {
        -:    9:  unsigned long a;
        -:   10:  int b;
        -:   11:} __attribute__((__aligned__(64)));
        -:   12:
        -:   13:char a[200];
        -:   14:
        1:   15:int main() {
        1:   16:  volatile int x =
        1:   17:      ((struct test_struct *)(round_up((unsigned long)a, 64) + 16))->b;
        1:   18:  volatile int y =
        1:   19:      ((struct test_struct *)(round_up((unsigned long)a, 64) + 15))->b;
        -:   20:
        1:   21:  return 0;
        -:   22:}
        -:   23:
        -:   24:/* { dg-output "\.c:18:\[0-9]*: \[^\n\r]*member access within misaligned address
        -:   25: * 0x\[0-9a-fA-F]* for type 'struct test_struct', which requires 64 byte
        -:   26: * alignment" } */
