        -:    0:Source:3587.c
        -:    0:Graph:3587.gcno
        -:    0:Data:3587.gcda
        -:    0:Runs:1
        -:    1:
        -:    2:typedef __SIZE_TYPE__ size_t;
        -:    3:typedef unsigned int index_ty;
        -:    4:typedef index_ty *index_list_ty;
        -:    5:
        -:    6:struct mult_index {
        -:    7:  index_ty index;
        -:    8:  unsigned int count;
        -:    9:};
        -:   10:
        -:   11:struct mult_index_list {
        -:   12:  struct mult_index *item;
        -:   13:  size_t nitems;
        -:   14:  size_t nitems_max;
        -:   15:
        -:   16:  struct mult_index *item2;
        -:   17:  size_t nitems2_max;
        -:   18:};
        -:   19:
        2:   20:int __attribute__((noinline)) hash_find_entry(size_t *result) {
        2:   21:  *result = 2;
        2:   22:  return 0;
        -:   23:}
        -:   24:
        -:   25:extern void abort(void);
        1:   26:struct mult_index *__attribute__((noinline)) foo(size_t n) {
        -:   27:  static count = 0;
        1:   28:  if (count++ > 0)
    #####:   29:    abort();
        1:   30:  return 0;
        -:   31:}
        -:   32:
        1:   33:int main(void) {
        1:   34:  size_t nitems = 0;
        -:   35:
        1:   36:  for (;;) {
        -:   37:    size_t list;
        -:   38:
        2:   39:    hash_find_entry(&list);
        -:   40:    {
        2:   41:      size_t len2 = list;
        -:   42:      struct mult_index *destptr;
        -:   43:      struct mult_index *dest;
        2:   44:      size_t new_max = nitems + len2;
        -:   45:
        2:   46:      if (new_max != len2)
        1:   47:        break;
        1:   48:      dest = foo(new_max);
        -:   49:
        1:   50:      destptr = dest;
        3:   51:      while (len2--)
        2:   52:        destptr++;
        -:   53:
        1:   54:      nitems = destptr - dest;
        -:   55:    }
        -:   56:  }
        -:   57:
        1:   58:  return 0;
        -:   59:}
