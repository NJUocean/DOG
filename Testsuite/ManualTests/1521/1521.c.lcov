    1|       |/* { dg-do run } */
    2|       |
    3|       |extern void abort(void);
    4|       |extern void *memcpy(void *, const void *, __SIZE_TYPE__);
    5|       |
    6|       |typedef struct {
    7|       |  void *v1;
    8|       |  void *v2;
    9|       |  void *v3;
   10|       |  union {
   11|       |    void *f1;
   12|       |    void *f2;
   13|       |  } u;
   14|       |} S;
   15|       |
   16|       |S *getS();
   17|       |void verify_p(void *p);
   18|       |double *getP(void *p);
   19|       |
   20|      1|void memcpy_bug() {
   21|      1|  S *s;
   22|      1|  double *p = getP(0);
   23|      1|
   24|      1|  if (p) {
   25|      1|    int intSptr[sizeof(S *) / sizeof(int)];
   26|      1|    unsigned i = 0;
   27|      3|    for (i = 0; i < sizeof(intSptr) / sizeof(*intSptr); ++i) {
   28|      2|      intSptr[i] = (int)p[i];
   29|      2|    }
   30|      1|    memcpy(&s, intSptr, sizeof(intSptr));
   31|      1|    (s)->u.f1 = p;
   32|      1|    verify_p((s)->u.f1);
   33|      1|  } else {
   34|      0|    s = getS();
   35|      0|  }
   36|      1|  verify_p(s->u.f1);
   37|      1|}
   38|       |
   39|       |double P[4];
   40|       |
   41|      1|double *getP(void *p) {
   42|      1|  union u {
   43|      1|    void *p;
   44|      1|    int i[2];
   45|      1|  } u;
   46|      1|  u.p = P;
   47|      1|  P[0] = u.i[0];
   48|      1|  P[1] = u.i[1];
   49|      1|  return P;
   50|      1|}
   51|       |
   52|      0|S *getS() { return 0; }
   53|       |
   54|      2|void verify_p(void *p) {
   55|      2|  if (p != P)
   56|      0|    abort();
   57|      2|}
   58|       |
   59|      1|int main(int argc, char *argv[]) {
   60|      1|  memcpy_bug();
   61|      1|  return 0;
   62|      1|}

