        -:    0:Source:696.c
        -:    0:Graph:696.gcno
        -:    0:Data:696.gcda
        -:    0:Runs:1
        -:    1:/* Limit this to known non-strict alignment targets.  */
        -:    2:/* { dg-do run { target { i?86-*-linux* x86_64-*-linux* } } } */
        -:    3:/* { dg-options "-O2 -fsanitize=alignment -fsanitize-recover=alignment" } */
        -:    4:
        1:    5:__attribute__((noinline, noclone)) void foo(void *p, const void *q) {
        1:    6:  *(long int *)p = *(const long int *)q;
        1:    7:}
        -:    8:
        1:    9:int main() {
        -:   10:  struct S {
        -:   11:    long c;
        -:   12:    char f[64];
        -:   13:    char d;
        -:   14:    char e[2 * sizeof(long)];
        -:   15:    char g[64];
        -:   16:  } s;
        1:   17:  __builtin_memset(&s, '\0', sizeof s);
        1:   18:  foo(&s.e[0], &s.e[sizeof(long)]);
        1:   19:  return 0;
        -:   20:}
        -:   21:
        -:   22:/* { dg-output "\.c:8:\[0-9]*: \[^\n\r]*load of misaligned address
        -:   23: * 0x\[0-9a-fA-F]* for type 'const long int', which requires \[48] byte
        -:   24: * alignment.*" } */
        -:   25:/* { dg-output "\.c:8:\[0-9]*: \[^\n\r]*store to misaligned address
        -:   26: * 0x\[0-9a-fA-F]* for type 'long int', which requires \[48] byte alignment" }
        -:   27: */
