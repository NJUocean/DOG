        -:    0:Source:1394.c
        -:    0:Graph:1394.gcno
        -:    0:Data:1394.gcda
        -:    0:Runs:1
        -:    1:/*
        -:    2: * ====================================================
        -:    3: * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
        -:    4: *
        -:    5: * Developed at SunPro, a Sun Microsystems, Inc. business.
        -:    6: * Permission to use, copy, modify, and distribute this
        -:    7: * software is freely granted, provided that this notice
        -:    8: * is preserved.
        -:    9: * ====================================================
        -:   10: */
        -:   11:
        -:   12:#ifndef __vax__
        -:   13:static const unsigned long B1 = 715094163, /* B1 = (682-0.03306235651)*2**20 */
        -:   14:    B2 = 696219795;                        /* B2 = (664-0.03306235651)*2**20 */
        -:   15:
        -:   16:static const double
        -:   17:    C = 5.42857142857142815906e-01,  /* 19/35     = 0x3FE15F15, 0xF15F15F1 */
        -:   18:    D = -7.05306122448979611050e-01, /* -864/1225 = 0xBFE691DE, 0x2532C834 */
        -:   19:    E = 1.41428571428571436819e+00,  /* 99/70     = 0x3FF6A0EA, 0x0EA0EA0F */
        -:   20:    F = 1.60714285714285720630e+00,  /* 45/28     = 0x3FF9B6DB, 0x6DB6DB6E */
        -:   21:    G = 3.57142857142857150787e-01;  /* 5/14      = 0x3FD6DB6D, 0xB6DB6DB7 */
        -:   22:
        1:   23:double cbrtl(double x) {
        -:   24:  long hx;
        -:   25:  double r, s, w;
        -:   26:  double lt;
        -:   27:  unsigned sign;
        -:   28:  typedef unsigned unsigned32 __attribute__((mode(SI)));
        -:   29:  union {
        -:   30:    double t;
        -:   31:    unsigned32 pt[2];
        -:   32:  } ut, ux;
        -:   33:  int n0;
        -:   34:
        1:   35:  ut.t = 1.0;
        1:   36:  n0 = (ut.pt[0] == 0);
        -:   37:
        1:   38:  ut.t = 0.0;
        1:   39:  ux.t = x;
        -:   40:
        1:   41:  hx = ux.pt[n0];         /* high word of x */
        1:   42:  sign = hx & 0x80000000; /* sign= sign(x) */
        1:   43:  hx ^= sign;
        1:   44:  if (hx >= 0x7ff00000)
    #####:   45:    return (x + x); /* cbrt(NaN,INF) is itself */
        1:   46:  if ((hx | ux.pt[1 - n0]) == 0)
    #####:   47:    return (ux.t); /* cbrt(0) is itself */
        -:   48:
        1:   49:  ux.pt[n0] = hx;
        -:   50:  /* rough cbrt to 5 bits */
        1:   51:  if (hx < 0x00100000) /* subnormal number */
        -:   52:  {
    #####:   53:    ut.pt[n0] = 0x43500000; /* set t= 2**54 */
    #####:   54:    ut.t *= x;
    #####:   55:    ut.pt[n0] = ut.pt[n0] / 3 + B2;
        -:   56:  } else
        1:   57:    ut.pt[n0] = hx / 3 + B1;
        -:   58:
        -:   59:  /* new cbrt to 23 bits, may be implemented in single precision */
        1:   60:  r = ut.t * ut.t / ux.t;
        1:   61:  s = C + r * ut.t;
        1:   62:  ut.t *= G + F / (s + E + D / s);
        -:   63:
        -:   64:  /* chopped to 20 bits and make it larger than cbrt(x) */
        1:   65:  ut.pt[1 - n0] = 0;
        1:   66:  ut.pt[n0] += 0x00000001;
        -:   67:
        -:   68:  /* one step newton iteration to 53 bits with error less than 0.667 ulps */
        1:   69:  s = ut.t * ut.t; /* t*t is exact */
        1:   70:  r = ux.t / s;
        1:   71:  w = ut.t + ut.t;
        1:   72:  r = (r - ut.t) / (w + r); /* r-s is exact */
        1:   73:  ut.t = ut.t + ut.t * r;
        -:   74:
        -:   75:  /* restore the sign bit */
        1:   76:  ut.pt[n0] |= sign;
        -:   77:
        1:   78:  lt = ut.t;
        1:   79:  lt -= (lt - (x / (lt * lt))) * 0.333333333333333333333;
        1:   80:  return lt;
        -:   81:}
        -:   82:
        1:   83:main() {
        1:   84:  if ((int)(cbrtl(27.0) + 0.5) != 3)
    #####:   85:    abort();
        -:   86:
        1:   87:  exit(0);
        -:   88:}
        -:   89:#else
        -:   90:main() { exit(0); }
        -:   91:#endif
