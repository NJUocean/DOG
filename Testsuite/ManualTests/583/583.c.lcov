    1|       |/* { dg-do run } */
    2|       |/* { dg-options "-O -fipa-pta -fdump-ipa-pta2-details" } */
    3|       |
    4|      1|static int __attribute__((noinline)) foo(int *p, int *q) {
    5|      1|  *p = 2;
    6|      1|  *q = 1;
    7|      1|  return *p;
    8|      1|}
    9|       |
   10|      0|static int __attribute__((noinline)) bar(int *p, int *q) {
   11|      0|  *p = -2;
   12|      0|  *q = -1;
   13|      0|  return *p;
   14|      0|}
   15|       |
   16|      1|static int __attribute__((noinline, noclone)) foobar(int foo_p) {
   17|      1|  int a;
   18|      1|  int (*fn)(int *, int *);
   19|      1|  if (foo_p)
   20|      1|    fn = foo;
   21|      0|  else
   22|      0|    fn = bar;
   23|      1|  return (*fn)(&a, &a);
   24|      1|}
   25|       |
   26|       |extern void abort(void);
   27|       |
   28|      1|int main() {
   29|      1|  if (foobar(1) != 1)
   30|      0|    abort();
   31|      1|
   32|      1|  return 0;
   33|      1|}
   34|       |
   35|       |/* IPA PTA needs to handle indirect calls properly.  Verify that
   36|       |   both bar and foo get a (and only a) in their arguments points-to sets.  */
   37|       |
   38|       |/* { dg-final { scan-ipa-dump "fn_1 = { bar foo }" "pta2" } } */
   39|       |/* { dg-final { scan-ipa-dump "bar.arg0 = { a }" "pta2" } } */
   40|       |/* { dg-final { scan-ipa-dump "bar.arg1 = { a }" "pta2" } } */
   41|       |/* { dg-final { scan-ipa-dump "foo.arg0 = { a }" "pta2" } } */
   42|       |/* { dg-final { scan-ipa-dump "foo.arg1 = { a }" "pta2" } } */

