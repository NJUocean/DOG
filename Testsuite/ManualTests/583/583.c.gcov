        -:    0:Source:583.c
        -:    0:Graph:583.gcno
        -:    0:Data:583.gcda
        -:    0:Runs:1
        -:    1:/* { dg-do run } */
        -:    2:/* { dg-options "-O -fipa-pta -fdump-ipa-pta2-details" } */
        -:    3:
        1:    4:static int __attribute__((noinline)) foo(int *p, int *q) {
        1:    5:  *p = 2;
        1:    6:  *q = 1;
        1:    7:  return *p;
        -:    8:}
        -:    9:
    #####:   10:static int __attribute__((noinline)) bar(int *p, int *q) {
    #####:   11:  *p = -2;
    #####:   12:  *q = -1;
    #####:   13:  return *p;
        -:   14:}
        -:   15:
        1:   16:static int __attribute__((noinline, noclone)) foobar(int foo_p) {
        -:   17:  int a;
        -:   18:  int (*fn)(int *, int *);
        1:   19:  if (foo_p)
        1:   20:    fn = foo;
        -:   21:  else
    #####:   22:    fn = bar;
        1:   23:  return (*fn)(&a, &a);
        -:   24:}
        -:   25:
        -:   26:extern void abort(void);
        -:   27:
        1:   28:int main() {
        1:   29:  if (foobar(1) != 1)
    #####:   30:    abort();
        -:   31:
        1:   32:  return 0;
        -:   33:}
        -:   34:
        -:   35:/* IPA PTA needs to handle indirect calls properly.  Verify that
        -:   36:   both bar and foo get a (and only a) in their arguments points-to sets.  */
        -:   37:
        -:   38:/* { dg-final { scan-ipa-dump "fn_1 = { bar foo }" "pta2" } } */
        -:   39:/* { dg-final { scan-ipa-dump "bar.arg0 = { a }" "pta2" } } */
        -:   40:/* { dg-final { scan-ipa-dump "bar.arg1 = { a }" "pta2" } } */
        -:   41:/* { dg-final { scan-ipa-dump "foo.arg0 = { a }" "pta2" } } */
        -:   42:/* { dg-final { scan-ipa-dump "foo.arg1 = { a }" "pta2" } } */
