    1|       |/* { dg-do run } */
    2|       |
    3|       |/* Testcase distilled from glibc's nss_parse_service_list in nss/nsswitch.c
    4|       |   It can't be distilled further.  Fails with `-O2' for i[3456]86.  */
    5|       |
    6|       |/* this simulates a bounded-pointer type.  */
    7|       |struct ucharp {
    8|       |  unsigned char *v, *l, *h;
    9|       |};
   10|       |
   11|       |/* this simulates bounded-pointer check prior to pointer dereference.  */
   12|       |#define AREF(var, idx)                                                         \
   13|     15|  ((((((((var).v + (idx)) < (var).l) || (((var).v + (idx) + 1) > (var).h))) && \
   14|     15|     (__builtin_trap(), 0)),                                                   \
   15|     15|    (var).v)[(idx)])
   16|       |
   17|       |struct list {
   18|       |  struct list *next;
   19|       |};
   20|       |
   21|      2|struct list *alloc_list(void) {
   22|      2|  static struct list l;
   23|      2|  return &l;
   24|      2|}
   25|       |
   26|       |int one = 1;
   27|       |
   28|      1|void foo(struct ucharp cp, struct ucharp lp, struct list **nextp) {
   29|      2|  while (1) {
   30|      2|    struct list *list;
   31|      2|    while (AREF(lp, 0) && AREF(cp, AREF(lp, 0)))
   32|      2|      ++lp.v;
   33|      2|    list = alloc_list();
   34|      2|    while (AREF(cp, AREF(lp, 0)))
   35|      2|      ++lp.v;
   36|      2|    if (AREF(lp, 0) == one)
   37|      2|      do
   38|      2|        ++lp.v;
   39|      2|      while (AREF(lp, 0) && AREF(cp, AREF(lp, 0)));
   40|      2|    /* The above AREF (cp, ...) fails because the pseudo created to
   41|      2|       hold cp.v holds garbage, having never been set.
   42|      2|       The easiest way to see the problem is to compile wiht `-O2 -da'
   43|      2|       then look at *.09.loop.  Search for something like this:
   44|      2|
   45|      2|       Hoisted regno 183 r/o from (mem/s:SI (reg:SI 16 argp) 10)
   46|      2|         Replaced reg 91, deleting init_insn (213).
   47|      2|
   48|      2|       Now, look for the use of reg 91, which has no set.  */
   49|      2|
   50|      2|    *nextp = list;
   51|      2|    nextp = &list->next;
   52|      2|    if (!*lp.v)
   53|      1|      break;
   54|      2|  }
   55|      1|}
   56|       |
   57|       |extern void exit(int);
   58|       |
   59|      1|int main(void) {
   60|      1|  static unsigned char cp0[] = "\0\0\0\0";
   61|      1|  struct ucharp cp = {cp0, cp0, cp0 + sizeof(cp0)};
   62|      1|
   63|      1|  static unsigned char lp0[] = "\1\1\0\0";
   64|      1|  struct ucharp lp = {lp0, lp0, lp0 + sizeof(lp0)};
   65|      1|
   66|      1|  struct list list;
   67|      1|  struct list *nextp = &list;
   68|      1|
   69|      1|  foo(cp, lp, &nextp);
   70|      1|
   71|      1|  exit(0);
   72|      1|}

